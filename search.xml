<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scrath3.0 插件对外通信]]></title>
    <url>%2F2019%2F01%2F04%2Fscrath%E6%8F%92%E4%BB%B6%E5%AF%B9%E5%A4%96%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[scratch3.0 插件对外通信前天scratch3.0发布，同时也发布了windows和macos离线版的scratch3.0。 今天刚好看到有人也在做GNU/Linux版本。虽然说是离线版本，但是还是不能实现本地的HTTP请求。这个跨域问题对scratch强大的扩展功能来说确实尴尬。 由于不能发送本地请求，对外的通信基本都要经过一个代理去实现。 利用第三方服务 方糖 ★★★★★ 关注方糖的微信公众号，通过发送web请求将信息推送至微信。 IFTTT ★★★★☆ if this then that,同样通过get请求推送事件信息。简单易用，就看脑洞够不够了。这里有个BUG，虽然请求会报跨域，但经测试get请求能够生效，post就不行了，无法携带上参数。 服务器自建后台 node-red ★★★☆☆ 简单入门一下，其实还是挺好用的，官方的生态做的已经很好了。大概可以理解为极客版ifttt。 手写 后台 / 本地服务 ★★☆☆☆ 官方的有scratch-link，但肯定是不够用的。非官方呢，当然自己写啦！ emmmmm本地版不能够发送本地请求真是太蠢了，真的有必要做一下这个功能。应该有个插件将请求代理给electron内的server。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反代]]></title>
    <url>%2F2018%2F11%2F26%2Fnginx%E5%8F%8D%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[记一下反代后台服务器的过程 nginx反代及路径问题基本配置12345678910111213141516171819202122server &#123; listen 80; server_name _; root /web/data; include /etc/nginx/default.d/*.conf; location / &#123; &#125; # 此处反代后台服务器至 /api location /api/ &#123; proxy_pass http://localhost:8080/; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 代理路径问题第一种：location /proxy/ { proxy_pass http://127.0.0.1:81/;}会被代理到http://127.0.0.1:81/test.html 这个url 第二种(相对于第一种，最后少一个 /)location /proxy/ { proxy_pass http://127.0.0.1:81;}会被代理到http://127.0.0.1:81/proxy/test.html 这个url 第三种：location /proxy/ { proxy_pass http://127.0.0.1:81/ftlynx/;}会被代理到http://127.0.0.1:81/ftlynx/test.html 这个url。 第四种：第四种情况(相对于第三种，最后少一个 / )：location /proxy/ { proxy_pass http://127.0.0.1:81/ftlynx;}会被代理到http://127.0.0.1:81/ftlynxtest.html 这个url]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父组件向子组件通信]]></title>
    <url>%2F2018%2F11%2F09%2F%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[昨天一个遇到的一个小问题，一时间没反应过来。父组件怎么将事件通知给子组件？ 正常操作： 子组件向父组件通信 $emit发送事件 父组件向子组件通信 props传递数据 骚操作： 父组件给子组件加上 ref，直接调用子组件的内部方法，没必要通过传递数据来触发事件。 不仅是子组件，router-view也可以这样操作。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感慨一下]]></title>
    <url>%2F2018%2F09%2F15%2F%E6%84%9F%E6%85%A8%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[大四的一年一直到现在真的太混了 混到没事就胡思乱想 我不应该是这样的]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue事件执行顺序]]></title>
    <url>%2F2018%2F09%2F03%2Fvue%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[之前一直有个问题vue中emit的执行顺序是什么？ 123456789// 父文件&lt;template @receive=&quot;receive&quot;&gt;&lt;/template&gt;receive() &#123; cosnole.log(&apos;接收到事件&apos;)&#125; 12345678910// 子组件&lt;button @click=&quot;send&quot;&gt;&lt;/button&gt;send() &#123; this.$emit(&apos;receive&apos;) cosnole.log(&apos;发送事件&apos;)&#125; 123// 控制台'接收到事件''发送事件' 原本以为结果是先打印‘发送事件’然后打印‘接收到事件’，结果却是相反，暂时还没想通这是为什么。在我认为应该是先执行send中的同步任务，然后事件的触发应该作为类似于回调在同步任务完成后执行。 关于这个，刚刚写着写着突然想通了，之前看过一个关于简易事件库的实现。简单来说父组件在注册事件时，将对应的方法和事件名做好绑定，在emit时，看起来事件的执行和这个emit时没有直接的联系的，但实际上就是执行了事件中的方法。括号中的参数就是指定的事件名，所以可以理解为emit就是执行了众多一一绑定好的事件中的某一个。所以结果是先执行’接收到事件’后执行’发送事件’。我好蠢啊！终于想通了这个这么简单的问题。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖&节流]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[函数防抖： 防止事件在某一时刻频繁触发 函数节流： 降低事件在一段长时间内频繁触发的次数 记录一下常见的几种写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 防抖 延迟执行 （事件触发后一定时间内不立刻执行）const debounce = (func, wait, ...args) =&gt; &#123; let timeout; return function()&#123; // 这里的绑定this是绑定的在addeventlistener时环境中的this const context = this; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, ...args) &#125;, wait); &#125;&#125;// 防抖 立即执行 （事件触发后立刻执行，但在一定时间内不再次执行）const debounce1 = (func, wait, ...args) =&gt; &#123; let timeout; return function(event)&#123; // 这里给个e能够拿到事件信息 const context = this; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;,wait) if (callNow) &#123; func.apply(context, ...args) &#125; &#125;&#125;// 防抖 结合版 这个没进行实际测试function debounceAll(func,wait,immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125;// 节流 时间戳版const throttle = (func, wait, ...args) =&gt; &#123; let pre = 0; return function () &#123; const context = this; let now = Date.now(); if (now - pre &gt;= wait) &#123; func.apply(context, ...args); pre = Date.now(); &#125; &#125;&#125;// 节流 定时器版const throttle1 = (func, wait, ...args) =&gt; &#123; let timeout; return function () &#123; const context = this; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, ...args); &#125;, wait) &#125; &#125;&#125;// 调用document.getElementById('button').addEventListener('click', throttle1(clickEvent, 1000))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emmm...还是画画有趣...]]></title>
    <url>%2F2018%2F07%2F29%2Femmm-%E8%BF%98%E6%98%AF%E7%94%BB%E7%94%BB%E6%9C%89%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[教练！我想学画画！前段时间突然又想学画画了，没错是‘又’，翻了一下说说，上次画画是15年9月份（大二刚开学，都三年过去啦），画了一段时间还是没能坚持下去，好可惜啊，说不定现在都是大触了呢。 然后呢，前阵子一冲动就买了块数位板，坚持每天都画点东西吧！希望能坚持下去吧！！！ 血小板还是可爱的哇 脸画崩了，真是抱歉(｀・∀・´)]]></content>
  </entry>
  <entry>
    <title><![CDATA[天啦噜，这个表情包真是太可爱了]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%A4%A9%E5%95%A6%E5%99%9C%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%A1%A8%E6%83%85%E5%8C%85%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%8F%AF%E7%88%B1%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这个表情包怎么可以这么可爱呢！ 一周事件刷完小说，现在有点不能直视这个表情包了，不过也有说这本小说和表情包没有关系的（莫非是同一个画师？） menharu酱 还有带配音的诶、小姐姐给配成傲娇属性了 (・∀・) mad也来了哦 鬼畜也有 不废话找到原著，立马下个单，话说有段时间没看日文小说啦 关于这本书 这个女主应该和表情包没关系吧 这个女高中生沙优，emmm…..怎么是个失足少女啊。还好男主是个滥好人，也不对，毕竟都开后宫了。剧情一般，人物设定略特殊（为什么是失足少女啊！心疼。大马路上就能捡到，我到也想捡一个哈），情节虽不至于跌宕起伏，还是有一段高潮的，男主的反应emmm….在下佩服….（还好安全下车），结局也不错（标准日系结局），皆大欢喜，就当巩固一下日语单词以上です。]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AE表达式]]></title>
    <url>%2F2018%2F03%2F18%2FAE%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[emmm…. 教程还是边看边整理的好，就怕自己不带脑子 AE表达式整理基本层级关系thisComp.layer(“layerName”).propertyies index二维转三维 position表达式： value + [0, 0, index] slider可以理解为一个可以赋值的变量，然后将这个变量放置于表达式中，用于批量控制 timetime就是合成窗口左上角的时间值 posterizeTime(表达式页面的Global中)posterizeTime(帧速率)按指定的速率显示动画 wigglewiggle(freq, amp) 【频率， 幅度】wiggle返回值不一定是数字，直接写在属性的表达式框框里会返回对应的数据格式的 interpolationinterpolation(time, tmin, tmax, val1, val2)在time的时间段内 tmin - tmax之间这段时间里执行动画属性从val1-val2的动画time也可以为某些运动数值的变化 randomrandom(max) 0~maxrandom(min, max) min~max Math库和js中的功能基本一致 clampclamp(property, min, max)限制某一属性值在某一范围之内 looploopIn在关键帧之前运行关键帧动画loopOut在关键帧之后继续运行关键帧动画 参数 1 string circle 重复执行 pingpong 往复执行 continue 相当于动画的无限延长（根据最后两个关键帧的动画） offset 也是动画的无限延长（但是根据的是前面整个动画的运动趋势继续下去，区别于continue） 参数 2 number numkeyframe 重复帧的区间 1的话就是根据最后一个关键帧进行loop计算，2就是最后两个关键帧帧,0就是所有啦 在loopOutDuration()中 参数2 指的是最后几秒（s）而不是最后的几个关键帧 speedproperty.speed 获得当前属性变化的速度（）property.speedAtTime（time） 获得当前属性在某一时间刻度的速度 keyproperty.key(num) 获得某一属性第num关键帧的相关信息 value 当前的值 time 关键帧对应的合成时间 index 就是指第几个关键帧 marker (shift+num添加关键帧，ctrl+click去掉关键帧)comp.marker.key(num)获得第某个标记的信息（双击标记中的信息） sourceRectAtTimecomp.layer(‘layerName’).sourceRectAtTime(time, false).property这个例子中是获得了形状图层中content的属性 没太懂]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>After Effects</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几本书]]></title>
    <url>%2F2018%2F03%2F11%2F%E8%AE%B0%E5%87%A0%E6%9C%AC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[开学两周，毕业设计什么的还没什么通知，趁现在没什么事，周末图书馆刷些小说，以后毕业了怕是没那么容易找个安静的地方了 手动害怕 各种书翻了翻kindle发现买的书都过百了，看完的不过3，40十本，下班回宿舍看书什么的不存在的，还是去图书馆靠谱。 下面打算看的 世界的凛冬 抽空补完 口吐宝石的女孩 吾辈是猫 乌合之众或者沉默的大多数 刚刷完的 恶意-东野圭吾 这本书的写法很神奇 情人-渡边淳一 湖畔-东野圭吾 布谷鸟的蛋是谁的-东野圭吾 东野圭吾那些不错的 白夜行 嫌疑人X的献身 虚无的十字架 湖畔 彷徨之刃 放学后 我的晃荡青春 一些很好看的 三体 巨人的陨落 人间失格 现在看完了或者之看了开头看不懂的，等长大了再看~~ 情人 失乐园 挪威的森林 王小波所有的 厚黑学 乌合之众]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理and吉他和弦]]></title>
    <url>%2F2018%2F02%2F16%2F%E4%B9%90%E7%90%86and%E5%92%8C%E5%BC%A6%2F</url>
    <content type="text"><![CDATA[啊，回家过个年是真的烦。就想安静地过几天啊。电脑扔学校里没带回来，游戏也没得玩了，房间里倒是还有把吃灰一年多的吉他~~ 然后今天是除夕额，我的微信为什么挂在后台好像被杀掉了，还错过了一波公司群的红包,伤心… 乐理and吉他和弦乐理doyoudo乐理基础很棒的一个网站，之前AE,C4D,PS也在这个网上学的（然而现在在写代码(┬＿┬)） 其实之前应该是看过一点乐理的，但是忘得差不多了，只记得CDEFGAB了，再复习一遍吧 大调主音与三级音构成为大三度的调式为大调 C大调1C（全音）D（全音）E（半音）F（全音）G（全音）A（全音）B（半音）C 类似于这样的（全全半全全全半）8度音称为大调，C为主音就是C大调，这样子的话D大调那就是这个样子 1D(全)E（全）F#（半）G（全）A（全）B（全）C#（半）D 音的稳定121 5 3 6 2 4 7稳定 -&gt; 不稳定 音的倾向性1 &lt;- 2 | 3 &lt;- 4 | 5 1 音程音程对照 半音数 0 1 2 3 4 5 6 7 8 9 10 11 12 音程 纯一度 小二度 大二度 小三度 大三度 纯四度 增四\减五度 纯五度 小六度 大六度 小七度 大七度 纯八度 三全音三全音： 半音为6个（增四/减五度）称为三全音 【如：B -&gt; F】 音的转位如： B -&gt; F （减五度）与 F -&gt; B （增四度） 度数相加为9 大小增减是互换 纯音程不变 E -&gt; C （小六度） C -&gt; F (大三度) C -&gt; G (纯五度) G -&gt; C（纯四度） 音的协和度 完全协和音程 纯一度、纯八度 协和音程 纯四度、纯五度 不完全协和音程 大小三度、大小六度 不协和音程 大小二度、大小七度、增四减五度 和弦根据三度叠置形成和弦 大三和弦Cmaj 简写 C123大三度 小三度C -&gt; E -&gt; G根音 三音 五音 （度数） 小三和弦Dmin 简写 Dm12小三度 大三度D -&gt; F -&gt; A C大调和弦 1 2 3 4 5 6 C Dm Em F G Am CEG DFA EGB FAC GBD ACE 减三和弦Bdim (diminished)12小三度 小三度B -&gt; D -&gt; F 和弦转位1234CEGB EGCB GCEB BCEGCM7 CM7/E CM7/G CM7/G原位 第一转位 第二转位 第三转位 三音第一位 五音第一位 大大七和弦大三和弦+距根音大七度音Cmaj7 简写 CM7 C （大三度） E （小三度） G (大三度) B 小七和弦大三和弦+距根音小七度音 Amin7 简写Am7 A (小三度) C (大三度) E (小三度) G 属七和弦大三和弦+小七度音 Gdom7 简写 G7 大调中5级音开始（G转位找大二度为F，然后高八度为F） G(大三度)B(小三度)D(小三度)F 小大七和弦小三和弦+大七度音12EminMaj7 简写 EmM7E(小三度)G(大三度)B(大三度)D# 五度循环圈C为主音，以纯五度音相连为循环 在同一个时钟点上的大小调互为“关系大小调”，也叫“平行大小调”，比如C大调和a小调都在12点 时差越近的调，关系也越近，叫做“近关系调”，比如C大调和G大调，时差1小时，关系最近 时差越远的调，关系也越远，叫做“远关系调”，比如C大调和#F大调，时差6小时，关系最远 C - G - D - A - E 音级名称 C D E F G A B C 1 2 3 4 5 6 7 1 主音 上主音 中音 下属音 属音 下中音 导音 主音 上方相邻 主音与属音中间 下方纯五度 上方纯五度 主音与下属音中间 下方相邻 小调主音与三级音构成为小三度的调式为小调 自然小调123C大调 C D E F G A B Cc小调 C D Eb F G Ab Bb C 全 半 全 全 半 全 全 关系大小调构成音一致的大小调12C大调 C D E F G A Ba小调 A B C D E F G 从五度循环圈中的音小三度的小调即为对应的关系小调 小调的变体123a自然小调 A B C D E F G Aa和声小调 A B C D E F G# Aa旋律小调 A B C D E F# G# A 吉他和弦 参考：http://www.17jita.com/hexian/cdiao/ E7 C G7 Am G F Em Dm]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用live2d给博客加个卡哇伊的挂件]]></title>
    <url>%2F2018%2F01%2F17%2F%E7%94%A8live2d%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%AA%E5%8D%A1%E5%93%87%E4%BC%8A%E7%9A%84%E6%8C%82%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[看到右下角的小东西了么，没有？是不是把侧栏打开了？还是没有？那再等等吧…加载有点慢额。其实这个东西好早就见过了，之前看bilibili直播在直播间旁边就挂着一只22还是33来着，点击还能有动画 戳这里，好好玩的，但一直不清楚怎么做的…后来在DIYGOD的博客上也发现了这个,就好好的查了一下这个小玩意儿~~ emm…. 这个插件最近升到3.0了，写这篇博客时还是2.0的，安装的时候要不指定下版本吧，新版功能我也不太清楚额…历史版本 另外推广下前段时间写的vscode的live2d插件 戳这里 Live2D这东西来自于霓虹国的神奇脑洞官网，将二维物体通过位置转换或者形变达到模拟3D的效果。虽然比不上真实3D，不过也很有趣了 HEXO插件在Github上正好有这个插件，就能够很方便的实现这个效果啦~~ 见右下角的那只小猫，以后可以云吸猫了 项目地址hexo-helper-live2d 这个插件已经自带了好些模型了，但是还是觉得不够怎么办呢戳这里,官方已经做了一个用于分享的库，只需要把对应的文件下载下来然后参照上方插件的README中的说明进行配置就能够看到效果了。（这里有个文件版本的问题，见下面） 模型文件版本的问题这个插件是v2.1的，但是上面的库里面下的文件有的是3.0的所以需要转换。 下载下来的文件包应该是类似这样的两种结构 1234567891011121314151617181920// 这种moc+json+文件夹材质的是2.x版本的工程文件│ model.model.json // 模型json数据│ model.moc // 模型文件│└─model.1024 texture_00.png // 模型材质贴图（不同分辨率用）// json文件内容 是与当前目录的文件对应的&#123; &quot;type&quot;: &quot;Live2D Model Setting&quot;, &quot;name&quot;: &quot;makoto0&quot;, &quot;model&quot;: &quot;makoto0.moc&quot;, &quot;textures&quot;: [ &quot;makoto0.2048/texture_00.png&quot; ]&#125;// 还有一种仅只有单个的.cmox文件，这是3.0版本的项目文件，需要进行转换yukari_model.cmox 2.x版本对于第一种，很简单按照上面插件里面的README，在blog的根目录建立models的文件夹，然后将对应的2.x版本的文件包放进去，最后在config.yml中的model配置上填入对应的名称就ok了 3.0版本这个版本的话，需要进行一下转换。首先要下几个东西 Locale Emulator 用于跑各种日文软件的小工具，安装完后右击要打开的软件选择到Locale Emulator，并选择在日文环境下运行，就不会出现乱码 Live2D Cubism Editor 3.1 安装的时候应该会乱码，不用管，装完用上方的工具打开就行 Live2d-viewer 参照下载的说明就是需要先安装adobe air（下面有链接直接点击下载）,然后下载这个双击安装。 全部安装好了，打开Live2D Cubism Editor 3.1（右击选择Locale Emulator，并选择run in japanses）然后按照步骤 左上角ファイル、ファイルを開く,选择到.cmox的文件打开 应该会跳个框，不用管ok就行 左上角ファイル、組み込む用ファイル書き出し、mocファイル書き出し（2.1） 弹出的框框直接点OK，然后打开文件的目录下就会有类似上面说的2.x版本的那些文件了 然后的处理方法就和上面的2.x版本一样了]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2017%2F11%2F14%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[每天学一点Python ing python学习平时记录 *args是可变参数，args接收的是一个tuple; **kw是关键字参数，kw接收的是一个dict 迭代 dict迭代 12345678// 默认为key d = &#123;'a': 1, 'b': 2, 'c': 3&#125; for key in d: print(key)// 迭代value的话for value in d.values()print(value) str迭代 123str = 'hello'for ch in str: print(ch) list迭代 123//enumerate 可以获得index值for i, value in enumerate(['A', 'B', 'C']): print(i, value) tuple迭代 12for x, y in [(1, 1), (2, 4), (3, 9)]: print(x, y) set迭代 生成器迭代 生成器 生成器 12345678910111213// List生成式 L = [x * x for x in range(10)] L //[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] // 改为生成器 g = (x * x for x in range(10)) next(g) // 0 next(g) // 1 生成器可以被迭代 12for n in g: print(n) 使用yield 迭代器 可作用于for的称为可迭代对象 Iterable 可使用next()的称为迭代器 Iterator 把list、dict、str等Iterable变成Iterator可以使用iter()函数 装饰器 简单的装饰器 123456789101112131415161718192021222324import functoolsdef log(func):def wrapper(*args, **kw): print 'call', func.__name__ return func(*args, **kw)return wrapperdef logPlus(text): def decorator(func): @functools.wraps(func) // 此处保证函数信息一致 def wrapper(*args, **kw): print text, func.__name__ return func(*args, **kw) return wrapper return decorator@logdef now(): print '2017-11-15'now()// call now// 2017-11-15 带参数的装饰器 1234567891011121314def logPlus(text): def decorator(func): def wrapper(*args, **kw): print text, func.__name__ return func(*args, **kw) return wrapper return decorator@logPlus('time')def now(): print '2017-11-15'now()// time now// 2017-11-15 偏函数用于固定部分参数 12345import functoolsint2 = functools.partial(int, base=2)int2('1000000')//64 类 基本 1234567891011121314// object是值该类继承于object类class Student(object): // 这样可以直接定义类的属性 grade = 6 // 这样可以规定属性的个数，使用元祖定义，仅对当前的类起作用 __slot__ = ('name', 'score') // 这相当于js的construct，self为必传参数 def __init__(self, name, score): // 以两个_开头的是私有变量 self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) @property 12345678910111213class Student(object): // 这样方法相当于属性值返回 @property def score(self): return self._score // 修改score时自动通过该方法判断 @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 多重继承 12345678910class Runnable(object): def run(self): print('Running...')class Flyable(object): def fly(self): print('Flying...')// 在类名的括号中填入需要继承的多个类名class Dog(Mammal, Runnable): pass 元类 这个看起来很厉害是class的上级，具体用到再看看 调试 断言 assert 如果断言处不符，则会报错 启动Python解释器时可以用-O参数来关闭assert logging pdb单步调试 文件读写 文件读操作 1234567891011121314151617181920with open('/path/to/file', 'r') as f:print(f.read())// 反复调用read(size)可以每次读取固定大小值// readlines() 可以按行读取文件，得到listfor line in f.readlines():print(line.strip()) # 把末尾的'\n'删掉// 读取二进制文件 后面使用参数 'rb'f = open('/Users/michael/test.jpg', 'rb')f.read()// 第三个参数可以确定读取的编码f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')f.read()// 如果不能按编码读取， 第四个参数可以加入errors='ignore'，就可以忽略读取时的报错f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') 文件写操作 12with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') 序列化 pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。 pickle.dump()直接把对象序列化后写入一个file-like Object 用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象 12345678910111213141516f = open('dump.txt', 'wb')pickle.dump(d, f)f.close()// 从保存这序列化对象的文件中读取对象f = open('dump.txt', 'rb')d = pickle.load(f)f.close()// JSON的序列化和反序列化、import jsond = dict(name='Bob', age=20, score=88)json.dumps(d)json_str = '&#123;"age": 20, "score": 88, "name": "Bob"&#125;'json.loads(json_str) 常用模块 datetime 123from datetime import datetimeprint datetime.now()// datetime.datetime(2017, 11, 17, 16, 12, 24, 665000) collections namedtuple12345from collection import namedtuplePoint = nametuple('Point', ['x', 'y'])p = Ponit(1, 2)p.x // 1p.y // 2 hashlib摘要算法 md5 sha1]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impress.js源码阅读]]></title>
    <url>%2F2017%2F11%2F10%2Fimpress-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[最近有点忙了呀，又过上宿舍-公司-食堂-宿舍的生活了，之前闲的慌，现在发现早上7点起床到晚上吃完饭回宿舍8点多了，都几乎没有能完全自己支配的时间了，不过还好啦，公司下班到挺准时的~~然后还是想找些其他提升自己的事做做啦，正好前些时候用了impress写了个demo,那么这次就看看impress.js的源码啦 impress.js源码阅读CSS前缀的兼容处理1234567891011121314151617181920212223242526272829303132var pfx = ( function() &#123; var style = document.createElement( "dummy" ).style, prefixes = "Webkit Moz O ms Khtml".split( " " ), // 此处算是个闭包，做记忆 memory = &#123;&#125;; // prop为css属性 return function( prop ) &#123; // 如果memoory对象中为存储该属性时 if ( typeof memory[ prop ] === "undefined" ) &#123; // 首字母大写 var ucProp = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ), // 此处处理为如下： transition webkitTransition MozTransition props = ( prop + " " + prefixes.join( ucProp + " " ) + ucProp ).split( " " ); // 创建该属性对象 memory[ prop ] = null; for ( var i in props ) &#123; // 判断该属性是否存在 if ( style[ props[ i ] ] !== undefined ) &#123; // 给上一个可用前缀的属性名并且break出去 memory[ prop ] = props[ i ]; break; &#125; &#125; &#125; // 返回这个可用的属性 return memory[ prop ]; &#125;; &#125; )(); 处理类数组1234// 将类数组转换为数组也可用于数组的克隆 var arrayify = function( a ) &#123; return [].slice.call( a ); &#125;; 设置css的对象123456789101112131415// 传入DOM元素以及包含CSS属性的对象，并且通过pfx设置浏览器兼容属性// 传入的对象如： &#123;width：'10px';height: '10px'&#125;var css = function( el, props ) &#123; var key, pkey; for ( key in props ) &#123; if ( props.hasOwnProperty( key ) ) &#123; // 做css的兼容处理 pkey = pfx( key ); if ( pkey !== null ) &#123; el.style[ pkey ] = props[ key ]; &#125; &#125; &#125; return el;&#125;; 处理数字1234// 判断是否为数字，若不是数字则执行fallback，若未传入fallback则返回0，如果是数字，则处理为数字 var toNumber = function( numeric, fallback ) &#123; return isNaN( numeric ) ? ( fallback || 0 ) : Number( numeric ); &#125;; 元素选择器12345// 传入上下文和CSS选择器，若未传入上下文则使用document，返回匹配的第一个元素var $ = function( selector, context ) &#123; context = context || document; return context.querySelector( selector );&#125;; 12345// 传入部分同上，返回匹配的所有元素，并且数组化 var $$ = function( selector, context ) &#123; context = context || document; return arrayify( context.querySelectorAll( selector ) ); &#125;; 事件触发器1234567// 事件的触发器// 传入触发元素，事件名var triggerEvent = function( el, eventName, detail ) &#123; var event = document.createEvent( "CustomEvent" ); event.initCustomEvent( eventName, true, true, detail ); el.dispatchEvent( event );&#125;; 根据网址的hash获取dom元素123456var getElementFromHash = function() &#123; // Get id from url # by removing `#` or `#/` from the beginning, // so both "fallback" `#slide-id` and "enhanced" `#/slide-id` will work return byId( window.location.hash.replace( /^#\/?/, "" ) );&#125;; 设备兼容性的判断12345678910111213141516171819202122232425var ua = navigator.userAgent.toLowerCase();var impressSupported = // Browser should support CSS 3D transtorms // 是否包含透视属性 ( pfx( "perspective" ) !== null ) &amp;&amp; // Browser should support `classList` and `dataset` APIs // 是否支持Data属性 ( body.classList ) &amp;&amp; ( body.dataset ) &amp;&amp; // But some mobile devices need to be blacklisted, // because their CSS 3D support or hardware is not // good enough to run impress.js properly, sorry... // 去除对移动设备的支持 ( ua.search( /(iphone)|(ipod)|(android)/ ) === -1 );if ( !impressSupported ) &#123; // We can't be sure that `classList` is supported body.className += " impress-not-supported ";&#125; else &#123; body.classList.remove( "impress-not-supported" ); body.classList.add( "impress-supported" );&#125; 移动端添加meta信息1234567var meta = $( "meta[name='viewport']" ) || document.createElement( "meta" ); meta.content = "width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no"; // 此处用于没有viewport的情况，设置好name并且将该元素放入head中 if ( meta.parentNode !== document.head ) &#123; meta.name = "viewport"; document.head.appendChild( meta ); &#125; 函数防抖1234567891011121314151617181920212223var throttle = function( fn, delay ) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout( timer ); timer = setTimeout( function() &#123; fn.apply( context, args ); &#125;, delay ); &#125;; &#125;; // 这样写可以得到正确的this var throttle = function( fn, delay ) &#123; var timer = null; // 这里使用箭头函数可以获得正确的this，调用的时候应该使用普通的函数定义方式，否则无法绑定正确的this return () =&gt; &#123; var context = this, args = arguments; clearTimeout( timer ); timer = setTimeout( function() &#123; fn.apply( context, args ); &#125;, delay ); &#125;; &#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impress.js的可视化编辑]]></title>
    <url>%2F2017%2F10%2F09%2Fimpress-js%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[这只是源于某一天的突发奇想，如果用blockly封装一下impress.js，会不会很有趣呢！演示地址：http://summerscar.me/impress-blockly/Github托管：https://github.com/summerscar/impress-blockly 利用blockly包装impress.jsimpress.js官方简介对于impress.js的官方描述：It’s a presentation framework based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com. 官方示例http://impress.github.io/impress.js/ 使用1234567&lt;div id="its" class="step" data-x="850" data-y="3000" data-rotate="90" data-scale="5"&gt; &lt;p&gt; It’s a &lt;strong&gt;presentation tool&lt;/strong&gt; &lt;br&gt; inspired by the idea behind &lt;a href="http://prezi.com"&gt;prezi.com&lt;/a&gt; &lt;br&gt; and based on the &lt;strong&gt;power of CSS3 transforms and transitions&lt;/strong&gt; in modern browsers. &lt;/p&gt;&lt;/div&gt; impress的使用很简单在div中设置对应的class以及相关的data信息，impress就会对这些dom元素进行初始化确定位置，但是对于这整个过程还是需要对html有基本的了解,于是考虑如果用blockly套个壳会怎么样呢？ 对impress的加工blocklyblockly:简单地说就是把代码封装到积木块中，然后通过积木块的拼接生成代码并运行。 Demo运行说明演示地址：http://summerscar.me/impress-blockly/ 主操作界面 右侧就是blockly的操作界面，通过拖入积木块，运行后在主界面自能直接看到效果，左下角能够修改背景色，同时提供了导入导出功能 工作区内容的导出 工作区内容的导入 运行时，默认是将这段代码直接保存在localstorage中，载入页面时自动加载本地的数据，有了导入导出可以方便创建多个不同工作区 最后虽然实现还比较简陋，但功能基本都实现了，在简单了解了impress后就能后通过这个二次包装的impress很快捷的创建演示应用另外还有个成熟的impress可视化编辑的产品：http://strut.io/]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Blockly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆挖个坑用vue写个bilibili]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%9B%BD%E5%BA%86%E6%8C%96%E4%B8%AA%E5%9D%91%E7%94%A8vue%E5%86%99%E4%B8%AAbilibili%2F</url>
    <content type="text"><![CDATA[好久不写CSS了，之前的项目到后面全都是写JS，趁着这假期写个哔哩哔哩的WEB端。 vue-bilibili预览： http://bilibili.summerscar.com/ 在github上能找到很多类似的DEMO啦，但还是想自己从头写一个，包括前端+后端 技术找 vue + koa2 + es6 + async + scss 因为暂时先写个单页，没用vuex 项目托管：https://github.com/summerscar/bilibli-vue 记录第一天打算是VUE+KOA2来完成前后端，今天先完成准备工作，首页header简单的布局 bilibili网站有很多的图标，但是这些图标都是来自于一张PNG图片上，引用的方式是使用行内元素固定宽高，background-image引用图片，设置background-position得到对应图标。 header的横幅是直接div的background-image引入，position设为center 横幅上方有个高斯模糊的效果，实现方式是在横幅内添加固定高度div引入图片，css设为filter：blur(3px)得到模糊后的图片，在该层上方再叠加一层白色带透明的div盖在模糊的图片上即可实现。（注意：由于模糊的边缘是类似AE中蒙板羽化，所以是个渐变的效果，为了隐藏渐变可以把height稍增加，然后定位把那部分藏起来） 第二天还是在写这个header… 清除浮动：在父元素设置 12345678&amp;:after&#123; content: '.'; clear: both; width: 0; height: 0; display: block; visibility: hidden; &#125; 鼠标的各种hover效果，使用js事件+vue的ref去设置css即可 还有些类似tip的小弹窗，暂时不清楚小箭头怎么弄的，我这边直接把这小弹窗放到该元素的after伪元素中，设置改元素的 div:hoer:after{}来设置显示和消失 有些图片直接用接口的链接访问不到，使用后台代理获取图片然后返回给前端(注意：request的encode设为null否则默认为utf8，同时返回时设置type = ‘image/png’) 1234567891011const router = require('koa-router')()const request = require('request-promise');// 处理传来图片router.get(/^\/image\/dynamic(?:\/|$)/, async (ctx, next) =&gt; &#123; console.log(imageUrl.imgPrefix + ctx.url.split('/').slice(3).join('/')) let image = await request(&#123;url: imageUrl.imgPrefix + ctx.url.split('/').slice(3).join('/'), encoding: null&#125;) ctx.type = 'image/png' ctx.body = image&#125;) 在动态的菜单中有一个下划线跟随li运动的动画我参考了官方的自己尝试下了: li的after伪元素给个小点，ul后面给个1px高的div，定位到点上面，根据点击的index,设置left值以及设置好transition就能实现动画效果 opacity失效的问题：在设置渐入渐出动画时发现同时设置display为none会导致opacity动画失效，将display改为visibility属性即可 伪元素可以使用attr获取元素内的属性值 如： content:attr(‘data-url’) 第三天 block中文本overflow显示省略号（block需定义宽度） 12345&#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; header中的各种下拉弹窗可以封装为一个基础组件，里面的ul与btn可以通过slot插入，部分css可以预先在基础组件里写好 z-index属性只对有定位的元素起效（除static）！！！ 文字前图标的简单处理：使用padding-left,再设置backround-image至对应处 轮播图处理为基础组件，props接收数据以及相关参数的设置，通过emit将事件数据传递给父组件（组件也可以定义扩展方法，让父组件调用如：调转至某一index的图片） 第四天 一觉醒来，我的天B站不仅换了头图，连主题都变了，还有这种操作的？？？我猜是这个style属性变了，过几天再确认下！！ 今天比较顺利，越写越顺了，发现个问题blackground-color设为线性渐变只写start和end color时，这个属性会间接性的抽风失效，中间加个stop color就又好了，好奇怪 今天的进度 第五天 没错，一觉醒来头图又换回去了，果然是这个style搞的鬼，我昨天补救的代码也生效了，能自动切换颜色了，23333我tm太机智了 现在问题来了，下面的每个类目看起来差不多，但实际上又根据不同类目有区别，暂时想的是用slot插入或者根据不同的传入数据显示不同的组件 background-clip: border-box|padding-box|content-box; 规定背景的绘制区域： v-for与v-if一起使用时v-for的优先级更高，在v-for的外面包一层div写v-if防止渲染报错 overflow：hidden 在定位元素中，被定位元素的overflow是根据定位的父元素属性来的 文字下方的小三角写法回顾一下 12345678910111213141516.active &#123; color: $hoverBlue; border-bottom: 1px solid $hoverBlue; &amp;:after &#123; content: ' '; width: 0; height: 0; position: absolute; left: 50%; bottom: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 3px solid $hoverBlue; transform: translateX(-50%); &#125;&#125; 今天挺顺利，完成了三个类目 仔细研究了下，一共有5中不同的视频展示小窗口，分别是顶部的排行，紧跟着下面的推广，直播窗口，中部的各大类视频窗口，最后的推荐窗口，每种都单独做了一个组件 第六天 在父子数据通信上遇到了些问题 当子组件的emit出多个数据时 12345678910this.$emit('custom', 3, 4);// 父组件中&lt;child @custom='todo(arguments)'&gt;&lt;/child&gt;methods: &#123; todo () &#123; console.log(arguments) &#125;&#125;// 这样可获取传入的多个参数 当父组件额外传入参数时 123456789101112131415161718 this.$emit('custom', 1); // 父组件中 第一种方法 &lt;child @custom='todo($enents, 'other')'&gt;&lt;/child&gt; methods: &#123; todo (index, other) &#123; console.log(index, other) &#125; &#125;// 父组件中 第二种方法（接收传出多个数据时） &lt;child @custom='todo(arguments, 'other')'&gt;&lt;/child&gt; methods: &#123; todo () &#123; console.log(arguments) &#125; &#125; 事件传递多参数时event事件参数 @click=”do($event, ‘click’)” 获取DOM相对于网页的位置 object.getBoundingClientRect(); Boolean({})与Boolean([])为true 卡在了右侧的排行hover的弹窗，因为这里有个类似轮播图的东西，父元素加了overflow，只能在外面增加一个层定位用来显示信息，通过子组件传递信息到父元素获得数据和位置信息来控制这个层的显示 今天进度(循环渲染真的爽，写好了动画一个类目，然后处理好所有数据一个v-for全出来了) 第7天 事件传对象参数时出了点问题 12&lt;li @mouseover="change(&#123;type: 0&#125;)" :class="&#123;active: index === 0&#125;"&gt;全部&lt;/li&gt;&lt;li @mouseover="change(&#123;type: 1&#125;)" :class="&#123;active: index === 1&#125;"&gt;原创&lt;/li&gt; 123456789//这样写没问题 change (data) &#123; this.index = data.type === undefined ? this.index : data.type &#125; //但是如果这样写的话执行第二次时data参数就消失了，全都跳过了第一个判断 change (data) &#123; this.index = data.type || this.index &#125; Element.scrollIntoView()可以传参数完成平滑滚动] alignToTop一个Boolean值： 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions一个boolean或一个带有选项的object：1234&#123; behavior: "auto" | "instant" | "smooth", block: "start" | "end",&#125; 在有背景图并且有透明通道的div上可以设置背景色，但background-color属性要设置在背景图下面 今天出了点事，用的几个第三方接口挂了，然后又去官网抓了官方接口重写了后台 因为后台代理了所有图片，跑在我这台电脑上速度还行，挂到阿里云的一兆水管上，图大多GG，然后试着上个redis会不会好点 第8天 整理一下数据接口，完成了各分类的新动态和新投稿的切换 部署到服务器，顺便临时升了下带宽，图片能够陆续正常加载了 刚刚遇到一个很奇怪问题父组件对象的属性更新了，子组件却不更新数据（官方文档上说是对象属性的增加或删除会检测不到变化，而且我这个变化连watch deep都检测不到，见鬼了，这个组件还有个和这个变量一个类型的，同样改属性值却能刷新DOM，简直见鬼了！！！这个变量是掉进异次元了么），试了好几个办法 this.$forceUpdate()完美成功 虽然官方有个this.$set，但文档上说的是在对象的添加或删除时使用，而且在这里我用了这个重设属性值竟然也无效 使用Object.assign创建新对象并整个赋值，能刷新DOM，但是会导致刷新整个DOM（相当于整个数据从null到恢复数据，DOM整个都在闪啊我的天） 现在还剩右侧电梯的排序,动漫时间线,弹幕和预览功能没写]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中导航栏CSS的维护]]></title>
    <url>%2F2017%2F09%2F29%2FVue%E4%B8%AD%E5%AF%BC%E8%88%AA%E6%A0%8FCSS%E7%9A%84%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[vue中对于导航链接自动会对激活的链接添加route-active的class，但是在第三方ui组件中需要另外的维护方式。 vue中导航样式的维护原生的维护方式在对需要的元素添加后，vue会自动对该元素添加route-active的class，写上对应的css即可 第三方UI组件中UI组件中路由跳转的特点 在UI组件中，路由的跳转都是使用事件触发路由的编程式路由来导航 激活的CSS使用UI组件的自带样式，不建议再写route-active这个class的样式 UI组件中导航样式的激活是基于标签中一条active-name属性（以iview为例）来确定激活的对应目标 使用route.path来维护要确保样式能在各种情况下正确激活需要在路由发生变化是实时获取对应的path 1234567891011121314151617181920212223242526&lt;Menu :active-name="activeKey" @on-select="show" &gt; &lt;Menu-group title="基础管理"&gt; &lt;Menu-item name="/basManage"&gt; &lt;Icon type="document-text"&gt;&lt;/Icon&gt; 机柜信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/baseDevice"&gt; &lt;Icon type="android-list"&gt;&lt;/Icon&gt; 设备信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/baseUser"&gt; &lt;Icon type="android-document"&gt;&lt;/Icon&gt; 用户信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/basePort"&gt; &lt;Icon type="android-document"&gt;&lt;/Icon&gt; 端口信息管理 &lt;/Menu-item&gt; &lt;/Menu-group&gt; &lt;/Menu&gt; 使用一个变量来绑定active-name，之前是在这个单个VUE文件中分别在mounted和menu-item触发时获取path并赋值，但后来发现如果在route-view中使用了keep-alive，mounted这个钩子函数会失效，也就会到时在切换页面时，获取不到正确path. 于是在看在官方的文档后发现$route变量是能够watch的,直接可以在main.js中watch这个route，然后将path维护在Vuex中，然后分发到需要使用的单个VUE文件中 123456789//main.js中mounted () &#123; this.$store.commit('setPath',this.$route.path)&#125;,watch: &#123; $route () &#123; this.$store.commit('setPath',this.$route.path) &#125; &#125; 123456//单个vue组件中 computed: &#123; activeKey () &#123; return this.$store.getters.getPathState &#125; &#125; 这样在每次path变化时都能够的到正确的path，这样也就能激活对应的css了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半个多月终于走完了一条线-美少女万华镜4]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%A7%90%E5%BC%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E7%A6%81%E6%96%AD%E4%B9%8B%E6%81%8B-%E7%BE%8E%E5%B0%91%E5%A5%B3%E4%B8%87%E5%8D%8E%E9%95%9C4%2F</url>
    <content type="text"><![CDATA[距上次接触完全是日文的作品已经快过去半年了（期间忙于准备N1考试和其他事情去了），上次看的是《騎士団長殺し》不过很可惜，最后也没搞懂村上春树想表达什么，感觉我等渣渣还是不适合看这种很隐晦的书( ；o；)、正好7月份的N1也过了，终于可以看些轻松的东西了，也正好赶上这个评价很高的游戏发布,开学后就断断续续玩了半个多月…… 谁的鸡儿都别想放假 【手动狗头】 美少女万华镜4人物介绍 男主： 觋 夕摩 双胞胎 女主： 觋 夕莉 双胞胎 一花： 同学 镜子： 同学 老师 男主母亲 男主父亲又称绿帽侠 男主舅舅即亲生父亲（母亲的弟弟） 剧情 直接讲其中的true end剧情，首先要有个心理准备，男主是一个可以说奥斯卡影帝级别的人物，心机很可怕！！游戏中是倒叙，我这直接顺叙 母亲与舅舅两情相悦，玩禁断之恋怀上孩子，为了家族名誉找来绿帽侠男主父亲来接盘，但是明显母亲并不喜欢这个绿帽侠，然后没办法只能把自己的爱倾注在自己的儿子身上（不喜欢自己女儿），但是自己女儿很喜欢和男主玩，母亲为了把女儿支开，让女儿搬出去做艺人，然后绿帽侠照顾女儿（女儿其实知道这一切，对母亲很反感），在那段时间里母亲就把男主当做他的弟弟一样（不可描述那种），弟弟就对自己的父母以及她的弟弟十分憎恶。直到有一天女儿向母亲坦白了一切并威胁母亲，于是母亲很伤心决定上吊自杀，但是在上吊挣扎时绳子不小心断了，于是儿子上去补了一刀（掐死了，完成了母亲的复仇），然后为了毁尸灭迹把自家房子烧了。工作回来的父亲看到这一切，把一切都归罪于母亲溺爱的儿子（其实这里绿帽侠没错，但是女主一直以为是自己的过错），十分厌恶男主，男主为了逃离这个地方于是装疯卖傻，被父亲送到了精神病院，至此故事到一段落。 儿子在精神病院故意讨好护士们，很快得到了可以出院的许可，儿子便联系了自己的亲生父亲，让他把自己弄出去，但此时儿子是非常痛恨亲生父亲的，把自己的罪过全部交给了绿帽侠，导致母亲还对自己做那种事情，于是就出现了游戏开场的一幕，儿子配合他的秘书把他需要注射的药物给替换了，在他和儿子去祭拜母亲时，病情发作了，GG，男主完成复仇。接下来自己假借亲生父亲的名义，找到女主，顺理成章住到了女主和绿帽侠家里。进入了游戏真正的开场。 男主住到女主家后利用女主上学的时机偷偷跑去女主房间做羞羞的事，后被女主抓了现行，此时女主各种抖S，男主自然也就装作抖M，在日常中玩各种羞耻PLAY（一起买上学的衣服的时候玩优衣库那种的）。某一天女主提议和男主一起去学校，男主也同意，毕竟有能呼风唤雨的姐姐在还怕啥，男主在学校认识了一花和镜子，还有保育处的老师，男主听一花说和这个老师有接触的人会遭遇不幸，同时男主还在一花面前刷了波好感。一天男主和女主社团活动结束后发现手机丢在学校了，就回去拿手机，于是在这过程中惊讶的发现，镜子和老师存在特殊关系。 一天男主身体不舒服，在女主建议下去老师那检查下，然后这剧情就厉害了，男主就算是奥斯卡影帝也没想到老师直接下药夺走了男主的贞操，还录了像，后来还向男主坦白她的真正目标是女主。男主对此事感到悲痛欲绝，甚至想去自杀，但并没有把此时对任何人公开，女主意识到男主的不正常行为后各种安慰，也意识到老师应该是对弟弟做了什么，便假装成男主去校园陷害老师（传绯闻，后遭老师非礼，却发现是女儿身并非男主）。于是老师暂时出局。男主为了保护女主不停女主劝阻要去学校（自己的贞操都没保住，还想着保护女主，小伙子很厉害啊）。然后又是一段很长的日常，女主还在文化祭cos成MIKU和男主玩羞羞的事。这段日常过去后剧情进展就快多了。 一日，一花跑来向男主告白，这里有个分支，当然是选择拒绝（同意的话，剧情会很惊悚男主最后会把女主推下 站台，被车撞死…）拒绝之后剧场正常发展下去，这时候老师又跑来刷存在找来镜子下个套把女主叫出来，同时让镜子去男主家拖住。镜子一各种借口来到男主房里，这里又有分支了，当然是选择拒绝啦（同意的话据说是有一段神奇的发展 你懂得）。在男主说了一通大道理之后，镜子醒悟带男主去找女主。此时女主正和老师对峙，老师威胁女主要把男主的片公开，然后女主并没有惧怕，反而威胁老师公开后受影响的还是老师，男主是我的，不会给你的，于是拔出刀割了自己手腕，老师受惊退场。男主前来救场，安慰女主。后面男女主与镜子决裂，接着又是一段愉快的发展~~。 一天女主有事提前回家，其实之前男主早已打过算盘，男主早晚是要干掉对自己深恶痛绝的绿帽侠的，他在父亲每天的酒中下药，希望某一天父亲对女主做出鬼父的行为后，借女主之手杀掉绿帽侠。于是这天来了，男主当然计划通，一切顺利进行后，男主回来安慰女主，让女主求得心理安慰。接下来当然是一段二人世界的愉快发展~~ 后来男主发现绿帽侠还在苟延残喘，果断又补了一刀（小伙子厉害啊，明白补刀的重要性啊） 但是因为绿帽侠工作上的原因，各种电话打来，女主也疲于应对想去找他们的亲生父亲，但是联系不上（早就被男主做掉啦），这时候男主又机智的站出来了（此时女主与开局高高在上的形象天差地别了），他拿出了早已准备好的机票谎称是亲生父亲留他们的，然后女主如释重负，果断和男主出国过着没羞没臊的生活，并且剩下一对龙凤胎！！！ 没错又是姐弟～～ 结 这个游戏副标题《罪与罚的少女》 ，但整个剧情就是男主自导自演（除了那段被老师强上，男主自己也是郁闷，千算万算没算到还有这种操作），男主的一切罪过（杀了母亲，亲生父亲，绿帽侠），最后的锅全是女主姐姐背。虽然开始女主的形象塑造得很好，最后却成为了炮灰（好惨呀）…在这最后又生下一对姐弟，又是一段轮回？ 这剧情倒是有些像《白夜行》，但是东野圭吾对唐泽雪穗的刻画当然更加深刻，看完真的是能够被震撼到，游戏中剧情并没这么带感（游戏中是倒叙并非上面的顺叙！！），尽管后面男主的翻转很炫酷其实感觉也就那样吧。 画风很棒，音乐也很优雅（这真的没得黑），特效很棒很生动（都快成3D的感觉了，我的天），就是男主的女装大佬形象我略难以接受..反正就当做看一本小说来玩玩，最后还积累了5，6页的生词，我也是棒棒哒~~~ 最后上个隐藏的启动图]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又迷上了一个女神excited！]]></title>
    <url>%2F2017%2F09%2F25%2F%E5%8F%88%E8%BF%B7%E4%B8%8A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A5%B3%E7%A5%9Eexcited%EF%BC%81%2F</url>
    <content type="text"><![CDATA[映画『打ち上げ花火、下から見るか？横から見るか？』主題曲 打上花火循环了一星期了，这首歌真是 聴けば聴くほど楽しむ，也很期待电影上映呀！ 9-25 21：30更新话说今天这事也太邪门了吧，这篇博客是25号上午9点37分创建（还顺便逃了早上的课），10点差不多整理完，然后下午1点多微博上出现了这个视频 ，然后因为原po的这个视频，还上了日本yahoo的新闻 (25号18：39分发布)，当然这还没结束，当我打开网易云音乐打开今日推荐，惊讶的发现最后一首歌竟然就是下面VOICE的初音版 (´ºωº｀)总之感觉今天真tm神奇~~~下面还是回到正题~ 打上花火 官方MV 下面的视频都要过墙了才看得到了 然后很好奇得去youtube搜了搜翻唱，意外的发现了这个拉二胡的小姐姐Ayasa，2333333333 打上花火 Ayasa 然后看到评论说Ayasa还参演过大法的CM( 小姐姐厉害了呀 ヽ〔ﾟДﾟ〕丿ｽｺﾞｲ ),看到这我就不淡定了，作为一个索粉（索狗）很激动的搜索了一番，果然找到了啦，这MV简直 excited！！！ prprprprprpr Voices feat.Ayasa 然而这个还是feat版本，那原版呢？ Voices Voices feat.MIKU 于是又找到了原曲，我的天，这个我看过呀！！！去年某一天就在微博上看过这个MIKU和SONY合作的视频（曾经还又去找过，还没找到），然后今天又找回来了！！！ EXCITING!!! 不多说了，loop start ！ 另外附上另一个女神]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket打造简易聊天室]]></title>
    <url>%2F2017%2F09%2F21%2Fwebsocket%E6%89%93%E9%80%A0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[这两天看了下关于websocket方面的东西，现代浏览器基本都支持websocket,这样可以很方便实现双向的通信。然后简单写了一个聊天室 简单说明下websocket与http，个人理解两者都是在传输层TCP之上的实现方式。HTTP是客户端向服务器发送请求，服务器接收到请求，然后回应客户端，发送数据，但是服务器端不能够主动发送请求让客户端接受信息，这时候，就需要websocket了。简单地说，区别就是服务器端能主动与客户端通信。 websocket简单入门廖雪峰的websocket教程介绍了websocket的基本使用方法 socket.iosocket.io是对websocket的一层封装，准确的说还加入了ajax功能，帮助不支持websocket的浏览器实现接近websocket的功能 聊天室的实现有了socketio，就能够很方便实现，数据的分发，然后这里使用的是koa2作为后台。 socketio事件处理部分123456789101112131415161718192021222324252627282930313233343536373839404142io.attach( app )io.on('connection', (ctx, data) =&gt; &#123; let room = url.parse(ctx.socket.request.headers.referer).pathname.substr(1); logger.info(`a user connected to room: $&#123;room&#125;`) ctx.socket.on('join',(username) =&gt; &#123; console.log(username) ctx.socket.join(room); if (!userObj[ctx.socket.id]) &#123; userObj[ctx.socket.id] = username &#125; if (!roomObj[room]) &#123; roomObj[room] = [] roomObj[room].push(ctx.socket.id) &#125; else &#123; roomObj[room].push(ctx.socket.id) &#125; io.broadcast( 'message', &#123;user:'系统',content:`欢迎 $&#123;username&#125; 进入房间 $&#123;room&#125; 当前在线人数：$&#123;io.connections.size&#125;`&#125; ); io.to(room).emit( 'message', &#123;user:'系统',content:`欢迎 $&#123;username&#125; 进入了该房间 该房间人数$&#123; roomObj[room].length&#125;`&#125;); &#125;);&#125;);io.on('disconnect',(ctx, data) =&gt;&#123; logger.warn(`user: $&#123;userObj[ctx.socket.id]&#125; disconnected`); io.broadcast( 'message', &#123;user:'系统',content: `用户 $&#123;userObj[ctx.socket.id]&#125; 下线了`&#125;); for (let item in roomObj) &#123; if (roomObj[item].indexOf(ctx.socket.id) &gt;= -1) &#123; roomObj[item].splice(item.indexOf(ctx.socket.id), 1) &#125; &#125; delete userObj[ctx.socket.id]&#125;);io.on('message', (ctx, data) =&gt; &#123; let rooms = [] for (let item in ctx.socket.rooms) &#123; rooms.push(item) &#125; logger.info('receive a message ' + data); io.to(rooms[0]).emit( 'message', &#123;user:userObj[ctx.socket.id],content:data&#125;);&#125;); 处理socket的事件，并且维护用户列表以及房间的用户列表 聊天室前端部分1234567891011121314app.use(require('koa-static')(__dirname + '/public'))router.get('/:roomid', async (ctx, next) =&gt; &#123; const readFile = promisify(fs.readFile) try &#123; let ret = await readFile(__dirname+'/public/room.html', 'utf8') ctx.body = ret; &#125; catch (err) &#123; console.log(err) ctx.throw(500, err) &#125;&#125;);app.use(router.routes(), router.allowedMethods()) 前端部分就两个页面 一个是首页，直接使用koa-static实现，房间页面通过路由匹配发送给客户端。 项目托管地 实现效果]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[micro:bit上手]]></title>
    <url>%2F2017%2F09%2F13%2Fmicro-bit%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一个块好厉害的小板子呀，刚到手就在淘宝买了一堆的东西,等快递的两天，看了遍官方block的reference，大概想了一下然后画了张图，最后觉得感觉自己应该想太多了…其实用芯片本身做点东西就够了…9.19更新我的小车车已经能跑起来啦~~~ 一些脑洞小车var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/car.mp4"}}); 本身自带的传感器电子罗盘给个箭头指向北方,然后就成了个指南针 var dplayer1 = new DPlayer({"element":document.getElementById("dplayer1"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/compass.mp4"}}); 不过好像电池对传感器有一定的影响，用usb线就没错乱问题 亮度内置的亮度传感器，好像是亮光照在led上才有反应，而且灵敏度不高 var dplayer2 = new DPlayer({"element":document.getElementById("dplayer2"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/light.mp4"}}); 蓝牙蓝牙这个..额..真心不太懂，试了下block的几个功能，然后google play上下了几个demo app玩了玩 设备远程控制用官方的device类别下的几个block做了个手机的音乐播放控制 var dplayer3 = new DPlayer({"element":document.getElementById("dplayer3"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/remotecontrol.mp4"}}); Gamepad设备这个是google上的一个demo app，可以控制device中的gamepad var dplayer4 = new DPlayer({"element":document.getElementById("dplayer4"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/gamepad.mp4"}}); 哦对，这个留着，我要试着用这个控制我的小车！！！！ 另外，还有个蓝牙的uart，好像类似于串口通信，不太清楚具体怎么用(google play有个对应的uart应用试了下数据传输，好像和串口没啥区别，不过是无线的啦) serial串口用串口可以直接有线通信啦，正好不会用蓝牙，有了这个就厉害啦 我用的win7,需要装个驱动，不过我这边好像网页装了扩展也没见数据，还是下个调试助手算了 读取传感器信息通过node-red读取microbit的传感器信息做个ui界面 var dplayer5 = new DPlayer({"element":document.getElementById("dplayer5"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/serial.mp4"}}); 这里的node-red跑树莓派上的，后面打算 -&gt; 树莓派 + microbit + 小车 = ？ 来创作音乐？其实那天拿到这个，就对block里面那个music很感兴趣，昨天买的一堆东西到了，立刻就试着搞了下这个 var dplayer6 = new DPlayer({"element":document.getElementById("dplayer6"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/music.mp4"}}); microbit接上我的电脑，用Arduino的一个串口助手，里面正好有一个键盘模式（按下key直接发送串口数据，不过只有13个键），然后microbit检测到对应数据发出对应的音就行了 树莓派的noder-red里面也有个键盘输入的节点,搞个树莓派+node-red+microbit,就能输出所有的音了吧..不过这样太ZZ了 Pins这个外接设备那就无限多啦，但我并不是很懂那些传感器啦，等下还要研究下怎么控制步进电机 光敏传感器之前用树莓派只能读取数字信号，这个貌似数字模拟都能读取，然后直接反馈到LED上啦 var dplayer7 = new DPlayer({"element":document.getElementById("dplayer7"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/pinlight.mp4"}}); 最后如果把这些搞下混搭的话…enmmmm….大概都上顶上那张图，然后… 昨天刚搞了辆小车，好不容易装完发现还少个电机驱动板 (T_T) 先放着吃两天灰吧，先想想用这板子能在这车上玩出什么神奇的操作]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node小爬虫]]></title>
    <url>%2F2017%2F09%2F08%2Fnode%E5%B0%8F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[至于为什么突然想写个爬虫…额…只是突然发现了这个老司机网站,看到这么整齐的布局，忍不住想把数据爬下来 一个不可描述的爬虫node.js一般爬虫都是python,但我不会呀，所以还是用node了，还是第一次接触node的爬虫，有点小激动 依赖根据自己已知的+搜索来的确定了基本上是这几个依赖 cheerio 相当于后台的jquery，第一次尝试了下这个模块，简直是写爬虫必备呀，excited! moment 记录下时间用 request 请求网站数据 fs 处理文件 代码部分12345678910111213141516171819202122232425262728293031323334353637const http = require('http')const fs = require('fs')const cheerio = require('cheerio')const request = require('request') const moment = require('moment')const arguments = process.argv.splice(2);const url = 'http://www.cilikankan.net/fengmian/'let textData = '车牌,热度,日期,图片链接,下载链接'getImage(arguments[0] || 1);function getImage (page) &#123; request(`$&#123;url&#125;index_$&#123;page&#125;.html`, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; const $ = cheerio.load(body) const items = $('.item ') for (let i = 0; i &lt; items.length; i++) &#123; let title = items[i].children[1].children[1].children[1].attribs.title let targetSrc = items[i].children[1].attribs.href let src = items[i].children[1].children[1].children[1].attribs.src let date = items[i].children[1].children[3].children[1].children[3].children[0].data let heat = items[i].children[1].children[3].children[1].children[6].children[0].data.substr(3) textData += `\r\n$&#123;title&#125;,$&#123;parseInt(heat)&#125;,$&#123;date&#125;,$&#123;src&#125;,$&#123;targetSrc&#125;` let imgName = `./images/$&#123;heat&#125; $&#123;title&#125; $&#123;page&#125;.jpg` request(src).pipe(fs.createWriteStream(imgName)) &#125; &#125; fs.writeFile(`./开车时间：$&#123;moment().format('MM-DD')&#125; page：$&#123;page&#125;.csv`, textData, (err) =&gt; &#123; if(err) &#123; return console.log(err); &#125; console.log("写入完成。"); &#125;) &#125;)&#125; 执行方法1npm start 'page' 可以尽情飙车了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咕咕机-一台有趣的打印机]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%92%95%E5%92%95%E6%9C%BA-%E4%B8%80%E5%8F%B0%E6%9C%89%E8%B6%A3%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前些天看到了这个咕咕机，看起开很有趣，就搞了台玩玩，昨天刚到，也就是上手简单玩了一天 更新： 前阵子直接在node-red平台上封装了这个API，可以直接安装这个节点使用了，不需要调用后台了,机智如我node-red-contrib-memobirdtext PS：昨天七夕，店家还送了很多虐狗的东西，而且官方宣传这小东西都是 情侣，传纸条 ？？ 是我对这东西理解错了么（手动黑人问号） 开箱 差不多一只手的大小，可连接WIFI也可切换本地模式，连接手机热点，打印是会发出“咕~咕~”的声音~~用的是热敏纸，4卷19rmb，还好吧，才买回来24小时不到，一卷纸快被我打完了 官方APP官方APP就不多说了，总之很方便，一键打印APP里各种内容，还有很多网友分享的，总之很丰富。很多模板也很有用，但这些以后再说啦~ 官方API当然我的感兴趣的重点是官方的打印API啦，发了封邮件40分钟就回了，很顺利拿到了appkey 虽然NPM上也有一些别人写的封装API，但看了看官方的文档，一个就仨接口，干脆自己撸算了,直接写在了koa里做个后台github.memobird-api 咕咕机类123456789101112131415//post请求 getData (url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data) .then((res) =&gt; &#123; if (res.data.showapi_res_code === 1) &#123; console.log('异步请求ok') resolve(res.data) &#125; else &#123; console.log('失败! 原因：', res.data.showapi_res_error ) reject(res.data) &#125; &#125;) &#125;) &#125; 12345678910111213141516171819202122232425262728293031323334//初始化，绑定用户 async init () &#123; this.initRes = await this.getData(url.account, this.config) &#125; //打印文字功能 async printText (content) &#123; console.log('printText开始') let Content = `来自node平台 $&#123;content&#125; $&#123;moment().format('YYYY-MM-DD HH:mm:ss')&#125;` let print = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, memobirdID: this.config.memobirdID, userID: this.initRes.showapi_userid, printcontent: `T:$&#123;iconv.encode(Content, 'gbk').toString('base64')&#125;` &#125; return await this.getData(url.print, print) &#125; //打印图片功能 async printImg (path) &#123; console.log('printImg开始') let Content = `T:$&#123;iconv.encode('来自node平台', 'gbk').toString('base64')&#125;|$&#123;await this.encodeImg(path)&#125;|T:$&#123;iconv.encode(moment().format('YYYY-MM-DD HH:mm:ss'), 'gbk').toString('base64')&#125;` let print = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, memobirdID: this.config.memobirdID, userID: this.initRes.showapi_userid, printcontent: Content &#125; return await this.getData(url.print, print) &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//处理图片encodeImg (path) &#123; return new Promise((resolve, reject) =&gt; &#123; gm(path).resize(384).flip().type('Bilevel').colors(2).toBuffer('bmp', (error, buffer) =&gt; &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(`P:$&#123;buffer.toString('base64')&#125;`); &#125; &#125;); &#125;) &#125; //循环检测是否打印完成 async status (id, time) &#123; let times = 1 let printflag = 0 let status = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, printcontentid: id &#125; do &#123; await this.timeOut(time) let res = await this.getData(url.status, status) printflag = res.printflag console.log(`开始检测 第$&#123;times&#125;次 延时$&#123;time&#125;ms $&#123;printflag === 1 ? '打印完成' : '打印未完成'&#125;`) times++; if(times === 6) break &#125; while (printflag !== 1); return printflag &#125; //延时 timeOut (time = 3000) &#123; return new Promise((resolve, reject) =&gt; &#123; let timer = setTimeout(() =&gt; &#123; resolve('延时完成') &#125;, time) &#125;) &#125; 后台API接口这边简单的功能写好了，然后在router里面写个接口就行了123456789101112131415161718192021222324252627282930//router接口router.post('/printText', async (ctx, next) =&gt; &#123; const memobird = new Memobird(&#123;ak: '',memobirdID: '',useridentifying: ''&#125;) ctx.body = &#123;code:1&#125; memobird.init() .then(() =&gt; memobird.printText(ctx.request.body.content)) .then( res =&gt; memobird.status(res.printcontentid, 3000)) .then(printflag =&gt; &#123; console.log('检测完成',printflag === 1 ? '打印完成' : '打印未完成') &#125;) .catch((err) =&gt; &#123; console.log(err) ctx.body = err &#125;)&#125;)router.post('/printImg', async (ctx, next) =&gt; &#123; const memobird = new Memobird(&#123;ak: '',memobirdID: '',useridentifying: ''&#125;) ctx.body = &#123;code:1&#125; memobird.init() .then( res =&gt; memobird.printImg(ctx.request.body.content)) .then( res =&gt; memobird.status(res.printcontentid, 3000)) .then(printflag =&gt; &#123; console.log('检测完成',printflag === 1 ? '打印完成' : '打印未完成') &#125;) .catch((err) =&gt; &#123; console.log(err) ctx.body = err &#125;)&#125;) 这样后台基本写完了，然后需要调用接口啦 神器node-red之前一个大佬和我说了这个，试着玩了下，总之超牛逼的一个东西，完全的可视化编程，往下看就知道了 建几个定时任务 一言一言API 通过inject，建立定时任务，会定时触发后面的get请求,然后处理好返回的数据，然后发送post请求到我的后台服务器 这里function模块处理返回的数据，然后post请求到我的后台服务器 天气预报和风天气API这个也是一样啦，inject设定两个固定时间的触发，处理好请求地址，获取数据，处理发送给后台的数据 其他任务当然还有很多有趣的模块，email模块尝试了下qq和163总有些小问题，还有teitter，facebook的模块但有堵墙，最最重要的！！！这个个物联网的可视化平台，是用来监测硬件的（很可惜，我手上没这些东西，到时候搞个树莓派玩玩），任何监测信息都可以直接连接这台小打印机，直接打印输出！！！ UI部分node-red还带一个ui界面两条简单的流程图，text输入后触发post请求到后台就行啦 生成的前端页面 效果以下效果都是通过node后台打出来的，自带APP打出来的总体要美观很多啦 后期其他功能现在只能文本，图片分开来打印，过些天我试下多项内容的打印功能]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由相关]]></title>
    <url>%2F2017%2F08%2F23%2FVue%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[最近看了很多很杂的东西，有点乱，大概整理下 路由路由参数获取通过在路由中定义：param的形式 获取路由匹配参数 1this.$route.params.param 路由跳转带参数的地址时，获取参数 1this.$route.query.param 跳转 12//这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。this.$router.go() 命名路由123&lt;router-link :to="&#123;name:'index'&#125;"&gt;&lt;/router-link&gt;//需要参数时&lt;router-link :to="&#123;name:'index'，params:&#123;param:'123'&#125;&#125;"&gt;&lt;/router-link&gt; 命名视图123&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name="title"&gt;&lt;/router-view&gt;&lt;router-view name="img"&gt;&lt;/router-view&gt; 12345678910//路由中定义&#123; path:'/', name:'index', components: &#123; default:Index, title:Title, img:Img &#125;&#125; 路由向组件传参12345678910111213141516const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125; // 对于包含命名视图的路由，你必须分别为每个命名视图添加props选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 传参为方法 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) axios的传参问题axios的get与post传数据的区别 get请求默认为为params，是跟在地址后面的查询字符，在node中从request.query中 1axios.get('url',&#123;params: obj&#125;) post请求默认为dara，是提交的数据，在node中从request.body中 1axios.post('url',obj) axios源码：12345678910111213141516171819202122232425export default &#123; post(url, data) &#123; return axios(&#123; method: 'post', url: config.api + url, data: qs.stringify(data), timeout: config.timeout, headers: &#123; 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125; &#125;).then(checkStatus).then(checkCode) &#125;, get(url, params) &#123; return axios(&#123; method: 'get', url: config.api + url, params, timeout: config.timeout, headers: &#123; 'X-Requested-With': 'XMLHttpRequest' &#125; &#125;).then(checkStatus).then(checkCode) &#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs后台运行]]></title>
    <url>%2F2017%2F08%2F19%2Fnodejs%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在服务器linux环境下让nodejs后台运行 nohup在LINUX中我们可以使用这种简单的方式让node.js在后台运行： 1nohup node your_app.js &amp; pm2运行1pm2 start app.js 查看运行状态1pm2 list 追踪资源运行情况1pm2 monit 查看日志1pm2 logs 重启应用1pm2 restart appId 停止应用1pm2 stop app.js 开启api访问12pm2 web//浏览器访问http://localhost:9615 foreverforever的安装：1npm install forever -g forever的用法：使用forever启动守护进程：1forever start your_app.js 关闭守护进程：1forever stop your_app.js 重启守护进程：：1forever restart your_app.js 如果需要记录输出日志和错误：1forever start -l forever.log -o out.log -e err.log your_app.js 查看正在运行的程序：1forever list]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr东京VPS搭建SSR+BBR]]></title>
    <url>%2F2017%2F08%2F09%2Fvultr%E4%B8%9C%E4%BA%ACVPS%E6%90%AD%E5%BB%BASSR-BBR%2F</url>
    <content type="text"><![CDATA[最近之前买的55总是抽风，大晚上用不了，一怒之下搞了台vultr的VPS试试搭建SSR 注册 注册个vultr账号 http://www.vultr.com/ 注册paypal有张开了网银的银行卡就能顺利注册 充值 购买VPS选择Debian 7（方便后面安装ssr,bbr,锐速等） 其他选项默认 然后点击Deploy now 了解主机相关信息这就是购买的主机了 需要知道这三个信息 IP Address Username Password 使用putty通过SSH连接VPS填上上一步中显示的IP后OPEN连接 输入用户名和密码，有如上显示则连接成功 安装SSR(可直接安装SSR多用户版见下方)1wget http://soft.paozailushang.com/vps/SSR.sh &amp;&amp; chmod +x SSR.sh &amp;&amp; ./SSR.sh 2&gt;&amp;1 | tee ssr.log 复制后在shell终端中右击则会复制，回车即可按步骤输入密码和端口后回车等待完成根据这个配置填写SSR客户端即可正常连接使用 安装谷歌BBR加速 （Debian 8直接安装下方魔改版）1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 使用方法和上步一致，最后会提示是否重启，y重启输入开启1bash bbr.sh start 如果看到有 tsunami 就表示开启成功！1sysctl net.ipv4.tcp_available_congestion_control SSR配置 http://www.zhouxuanyu.com/381.html 修改ssr配置 vi /etc/shadowsocks.json 一般情况下只需要修改以下五项即可：12345"server_port":8388, //端口"password":"password", //密码"protocol":"origin", //协议插件"obfs":"http_simple", //混淆插件"method":"aes-256-cfb", //加密方式 多端口配置如果要多个用户一起使用的话，请写入以下配置：1234567891011121314151617181920&#123; "server":"0.0.0.0", "server_ipv6": "[::]", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "80":"password1", "443":"password2" &#125;, "timeout":300, "method":"aes-256-cfb", "protocol": "auth_sha1_compatible", "protocol_param": "", "obfs": "http_simple_compatible", "obfs_param": "", "redirect": "", "dns_ipv6": false, "fast_open": false, "workers": 1&#125; 按照格式修改端口和密码：1234"port_password":&#123; "80":"password1", //端口和密码1 "443":"password2" //端口和密码2 &#125; 如果要为每个端口配置不同的混淆协议，请写入以下配置：1234567891011121314151617181920&#123; "server":"0.0.0.0", "server_ipv6":"::", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8388":&#123;"protocol":"auth_simple", "password":"abcde", "obfs":"http_simple", "obfs_param":""&#125;, "8389":&#123;"protocol":"origin", "password":"abcde"&#125; &#125;, "timeout":300, "method":"aes-256-cfb", "protocol": "auth_sha1_compatible", "protocol_param": "", "obfs": "http_simple_compatible", "obfs_param": "", "redirect": "", "dns_ipv6": false, "fast_open": false, "workers": 1&#125; 协议文档 http://www.zhouxuanyu.com/384.html 多用户脚本好像相关东西都从github上删了，过段时间再查查 https://www.zhujiboke.com/2017/03/278.html1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh 魔改版BBR （Debian 8 和Ubuntu16 +） https://www.zhujiboke.com/2017/07/589.html1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 重启完成后，运行1bash bbr.sh start 即可启动魔改版BBR。查看魔改BBR状态运行命令1sysctl net.ipv4.tcp_available_congestion_control 如果看到有 tsunami 就表示开启成功！]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue音乐WebApp开发知识点整理]]></title>
    <url>%2F2017%2F08%2F07%2FVue%E9%9F%B3%E4%B9%90WebApp%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理中… https://github.com/summerscar/vue-music data与props 属性会赋予getter与setter，数据变化时会被观测并更新 其他地方创建的属性值不会被检测 watch/computed的属性值需要在props或data中定义 歌手的类的使用歌手信息通过一个类来实现歌手对象的建立 歌曲类的工场方法歌曲对象的创建通过一个工厂函数传入对象，返回一个歌曲对象来创建 数据到DOM变化的间隔约20ms从数据更新到DOM刷新约1/60秒，设置约20ms对DOM进行操作 点击延迟插件 fastclick消除移动端点击的300ms延迟 betterscroll 插件主要用于移动端滚动，需要以后实际使用 数组迭代方法中（foreach）ruturn无效 用for代替foreach迭代方法中使用ruturn并不能跳出迭代，仍会遍历所有的元素，需要使用for循环 CSS 定位 left top right bottom css使用定位 fixed 或 absolute，left top right bottom设为0 可以 铺满屏幕 若元素存在widtn或height,可以使用margin: auto 进行居中 vuex 在组件中的映射mutaion的映射import {mapMutations} from ‘vuex’ methods中定义12345...mapMutations(&#123; fuName: 'commitName' &#125;)//即可调用this.fuName进行mutation提交 getters的映射 import {mapGetters} from ‘vuex’ 12345computed: &#123; ...mapGetters([ 'getters中方法名' ]) &#125; actions action的定义形式 12345 actions: &#123; increment (&#123; commit &#125;, param) &#123; commit('mutationName', param) &#125;&#125; 在组件中的映射123...mapActions(&#123; add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment') &#125;) watch1234//watch可获得的参数value(newVal, oldVal)&#123;&#125; 数组间的简单拷贝（引用类型）let _arr = arr.slice() Vue的Mixins混合 https://cn.vuejs.org/v2/guide/mixins.html#基础 混合方式同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用12345678910111213var mixin = &#123; created: function () &#123; console.log('混合对象的钩子被调用') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('组件钩子被调用') &#125;&#125;)// -&gt; "混合对象的钩子被调用"// -&gt; "组件钩子被调用" 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。123456789101112131415161718192021222324var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // -&gt; "foo"vm.bar() // -&gt; "bar"vm.conflicting() // -&gt; "from self" 搜索节流用一个延迟函数代理方法的执行。原理：执行前检查是否存在定时器，有则清空并重新设置 export function debounce(func, delay) { let timer return function (...args) { if (timer) { clearTimeout(timer) } timer = setTimeout(() =&gt; { func.apply(this, args) }, delay) } } 防止子组件的点击冒泡在组件中直接设置 ```@click.stop` 后面为空即可 state中数据的初始化state中的数据初始化可以在通过函数进行赋值 v-show对两组数据变化是的操作监测两组数组的变化时，可以设置computed一个数组为concat两个数组]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zepto源码阅读]]></title>
    <url>%2F2017%2F07%2F26%2Fzepto%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[翻完红宝书，第6,7章看完还是似懂非懂，也不想跟着视频写什么高大上的项目，最后想想还是找个简单的JS库看看源码吧。 zepto版本 v1.2.0 代码折叠后的基本结构1234567891011121314151617181920212223242526272829303132333435//最外层为自执行函数(function(global, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) //这边是AMD的模块？ 不懂，没用过AMD define(function() &#123; return factory(global) &#125;) else factory(global) //为最外层的自执行函数传入this和factory参数&#125;(this, function(window) &#123; var Zepto = (function() &#123; //..... zepto.Z.prototype = Z.prototype = $.fn return $ &#125;)() window.Zepto = Zepto //将Zepto赋值给全局Zepto属性 window.$ === undefined &amp;&amp; (window.$ = Zepto) //若window.$未被定义，将zepto复制给$ //这边的自执行函数传入Zepto将这个变量作为局部变量，提高效率，缩短使用的作用域链 ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) return Zepto &#125;)) 运行原理通过自运行函数，将Zepto（$）暴露给全局变量Zepto($),此时Zeptp（$）为函数，同时该变量下挂载了许多属性方法，通过 $.funName 来调用，当向Zepto（$）传入参数后，执行该函数生成对象,同时通过zepto.Z.prototype =Z.prototype = $.fn为生成的对象挂载上DOM的操作方法，部分方法返回值为this（即当前对象），可用于链式操作。 三元运算符“&amp;&amp;”和“||”源码中使用了很多三元运算符以及赋值问题 操作符|| 只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。 只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。 操作符&amp;&amp; 只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值 只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值 应用 var Yahoo = Yahoo || {}; //赋初值 callback&amp;&amp;callback() //若存在callback则运行callback 执行过程123$ = function(selector, context)&#123; return zepto.init(selector, context)&#125; 12345678910111213141516171819202122232425262728293031323334353637 zepto.init = function(selector, context) &#123; var dom //如果传入值空，则返回空对象 if (!selector) return zepto.Z() //当selector为字符串时 else if (typeof selector == 'string') &#123; selector = selector.trim() //判断是否为'&lt;'开头的html标签 if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // 否则context不为空时，调用 $(context).find(selector) else if (context !== undefined) return $(context).find(selector) // 否则则为CSS选择器 else dom = zepto.qsa(document, selector) &#125; //如果传入为function else if (isFunction(selector)) return $(document).ready(selector) //如果为zepto对象 else if (zepto.isZ(selector)) return selector else &#123; //如果传入值为数组是，则除去空数组 if (isArray(selector)) dom = compact(selector) //如果为对象，则作为DOM数组的成员 else if (isObject(selector)) dom = [selector], selector = null // 这个是什么意思呢，html传进来不应该在string那边判断么 else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // 调用zepto.Z创建对象 return zepto.Z(dom, selector)&#125; 123zepto.Z = function(dom, selector) &#123; return new Z(dom, selector)&#125; 123456function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || ''&#125; //将$.fn的对象集合赋值给zepto.Z与Z的原型1zepto.Z.prototype = Z.prototype = $.fn zepto.qsa css选择器12345678910111213141516 zepto.qsa = function(element, selector)&#123; var found, maybeID = selector[0] == '#', //判断是否有ID选择器 maybeClass = !maybeID &amp;&amp; selector[0] == '.', //判断是否为Class选择器 nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = simpleSelectorRE.test(nameOnly) //是否为单选择器 return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? //判断document.getElementByID能否使用 ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // 为单选择器，非id选择器，存在getElementsByClassName maybeClass ? element.getElementsByClassName(nameOnly) : // 为class选择器 element.getElementsByTagName(selector) : // 否则调用getElementsByTagName element.querySelectorAll(selector) // 否则调用原生querySelectorAll )&#125; 内置方法isArray先判断是否有 Array.isArray 方法 否则调用 object instanceof Array12isArray = Array.isArray ||function(object)&#123; return object instanceof Array &#125; 类型确定方法1234567891011121314 $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) &#123; class2type[ "[object " + name + "]" ] = name.toLowerCase() &#125;) function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || "object"&#125;/* 生成 &#123; '[object boolean]': 'boolean', '[object number]': 'number', '[object string]': 'string', ... &#125; */ 类型判断123456789101112131415161718192021function isFunction(value) &#123; return type(value) == "function" &#125;function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125;function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125;function isObject(obj) &#123; return type(obj) == "object" &#125;function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype&#125; //判断是否为纯对象 原型与Object的原型一致function likeArray(obj) &#123;var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length, //对象不为null，存在length属性 则赋值length type = $.type(obj)return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; ( 'array' == type || length === 0 || // 如果为 array 类型或者length 的值为 0，返回true (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) // 或者 length 为数字，并且 length的值大于零，并且 length - 1 为 obj 的 key )&#125; 其他方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 //除去数组中为空的元素 function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; //连接数组 function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; camelize = function(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : '' &#125;) &#125; function dasherize(str) &#123; return str.replace(/::/g, '/') .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') .replace(/([a-z\d])([A-Z])/g, '$1_$2') .replace(/_/g, '-') .toLowerCase() &#125; //数组去重 除去当前index与第一次出现该项相同的数组项 uniq = function(array)&#123; return filter.call(array, function(item, idx)&#123; return array.indexOf(item) == idx &#125;) &#125; function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)')) &#125; function maybeAddPx(name, value) &#123; return (typeof value == "number" &amp;&amp; !cssNumber[dasherize(name)]) ? value + "px" : value &#125; //在对象中缓存元素节点并默认显示 function defaultDisplay(nodeName) &#123; var element, display if (!elementDisplay[nodeName]) &#123; element = document.createElement(nodeName) document.body.appendChild(element) display = getComputedStyle(element, '').getPropertyValue("display") element.parentNode.removeChild(element) display == "none" &amp;&amp; (display = "block") elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; function children(element) &#123; return 'children' in element ? slice.call(element.children) : $.map(element.childNodes, function(node)&#123; if (node.nodeType == 1) return node &#125;) &#125; //生成DOM zepto.fragment = function(html, name, properties) &#123; var dom, nodes, container // 如果为单个html标签 if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)) if (!dom) &#123; //这边不懂这些正则 if (html.replace) html = html.replace(tagExpanderRE, "&lt;$1&gt;&lt;/$2&gt;") if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1 if (!(name in containers)) name = '*' container = containers[name] container.innerHTML = '' + html dom = $.each(slice.call(container.childNodes), function()&#123; container.removeChild(this) &#125;) &#125; if (isPlainObject(properties)) &#123; nodes = $(dom) $.each(properties, function(key, value) &#123; if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value) else nodes.attr(key, value) &#125;) &#125; return dom&#125; //这俩看不懂 function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; $.extend = function(target)&#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; $的工具方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 $.type = type $.isFunction = isFunction $.isWindow = isWindow $.isArray = isArray $.isPlainObject = isPlainObject //判断是否为空对象 $.isEmptyObject = function(obj) &#123; var name for (name in obj) return false return true &#125;//判断是否为数字，并且在范围内 $.isNumeric = function(val) &#123; var num = Number(val), type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125;//i为起始范围 $.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i) &#125;//调用内部驼峰转换功能 $.camelCase = camelize //去除空字符串 $.trim = function(str) &#123; return str == null ? "" : String.prototype.trim.call(str) &#125; $.map = function(elements, callback)&#123; var value, values = [], i, key //如果为数组 if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else //如果为对象 for (key in elements) &#123; value = callback(elements[key], key) //为空则跳过 if (value != null) values.push(value) &#125; return flatten(values) &#125; $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) //根据返回值停止遍历 if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; //调用内部filter方法 $.grep = function(elements, callback)&#123; return filter.call(elements, callback) &#125; //根据判断JSON对象方法的存在确定 if (window.JSON) $.parseJSON = JSON.parse // 生成对象映射数组 $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) &#123; class2type[ "[object " + name + "]" ] = name.toLowerCase() &#125;) $.fn的实例DOM方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481forEach: emptyArray.forEach,reduce: emptyArray.reduce,push: emptyArray.push,sort: emptyArray.sort,splice: emptyArray.splice,indexOf: emptyArray.indexOf,concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; //将伪数组对象转为数组或连接多个数组项 return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;,// 调用工具方法$.mapmap: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;))&#125;,slice: function()&#123; return $(slice.apply(this, arguments))&#125;,ready: function(callback)&#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn't yet created the body element if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($) else document.addEventListener('DOMContentLoaded', function()&#123; callback($) &#125;, false) return this&#125;,//若传入参数为空，则转换为数组，若非空则返回对应idx值，若为负数则加上length值（与原生方法一致）get: function(idx)&#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;,//调用get方法toArray: function()&#123; return this.get() &#125;,//返回length属性size: function()&#123; return this.length&#125;,//先判断是否有父节点，有则删除该节点remove: function()&#123; return this.each(function()&#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;)&#125;,//判断返回值是否为falseeach: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;,filter: function(selector)&#123; if (isFunction(selector)) return this.not(this.not(selector)) return $(filter.call(this, function(element)&#123; return zepto.matches(element, selector) &#125;))&#125;,//添加元素至集合中add: function(selector,context)&#123; //去除重复元素 return $(uniq(this.concat($(selector,context))))&#125;,//判断第一个元素是否满足选择器is: function(selector)&#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector)&#125;,not: function(selector)&#123; var nodes=[] //如果传入参数为方法 if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx)&#123; //传入每个对象 if (!selector.call(this,idx)) nodes.push(this) &#125;) else &#123; var excludes = typeof selector == 'string' ? this.filter(selector) : (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector) this.forEach(function(el)&#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes)&#125;,has: function(selector)&#123; return this.filter(function()&#123; return isObject(selector) ? //若传入参数为DOM对象 $.contains(this, selector) : //若传入参数为css选择器 $(this).find(selector).size() &#125;)&#125;,eq: function(idx)&#123; //若传入为-1 则为最后一个元素，否则为idx,idx+1 return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)&#125;,first: function()&#123; //判断是否为对象，并返回第一个元素 var el = this[0] return el &amp;&amp; !isObject(el) ? el : $(el)&#125;,last: function()&#123; //判断是否为对象，并返回最后一个元素 var el = this[this.length - 1] return el &amp;&amp; !isObject(el) ? el : $(el)&#125;,find: function(selector)&#123; var result, $this = this if (!selector) result = $() else if (typeof selector == 'object') result = $(selector).filter(function()&#123; //若为dom对象通过some过滤出结果 var node = this return emptyArray.some.call($this, function(parent)&#123; return $.contains(parent, node) &#125;) &#125;) //如果对象数量为1，则直接从该DOM对象中寻找 else if (this.length == 1) result = $(zepto.qsa(this[0], selector)) else result = this.map(function()&#123; return zepto.qsa(this, selector) &#125;) return result&#125;,closest: function(selector, context)&#123; var nodes = [], collection = typeof selector == 'object' &amp;&amp; $(selector) this.each(function(_, node)&#123; while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;) return $(nodes)&#125;,parents: function(selector)&#123; var ancestors = [], nodes = this while (nodes.length &gt; 0) //返回元素的所有父元素直到document nodes = $.map(nodes, function(node)&#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node) return node &#125; &#125;) return filtered(ancestors, selector)&#125;,parent: function(selector)&#123; return filtered(uniq(this.pluck('parentNode')), selector)&#125;,children: function(selector)&#123; return filtered(this.map(function()&#123; return children(this) &#125;), selector)&#125;,contents: function() &#123; // 获得每个匹配元素集合元素的子元素，包括文字和注释节点 return this.map(function() &#123; return this.contentDocument || slice.call(this.childNodes) &#125;)&#125;,siblings: function(selector)&#123; //返回除去当前元素的同级元素，若selector存在则过滤 return filtered(this.map(function(i, el)&#123; return filter.call(children(el.parentNode), function(child)&#123; return child!==el &#125;) &#125;), selector)&#125;,empty: function()&#123; //清空元素的innerHTML return this.each(function()&#123; this.innerHTML = '' &#125;)&#125;,// `pluck` is borrowed from Prototype.jspluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;)&#125;,show: function()&#123; return this.each(function()&#123; //若display属性值为none，则去除该属性值 this.style.display == "none" &amp;&amp; (this.style.display = '') //获取该元素最终的CSS属性，使用getPropertyValue方法不必可以驼峰书写形式（不支持驼峰写法 if (getComputedStyle(this, '').getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName) &#125;)&#125;,replaceWith: function(newContent)&#123; //在该元素前插入元素并删除该元素 return this.before(newContent).remove()&#125;,wrap: function(structure)&#123; var func = isFunction(structure) if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1 return this.each(function(index)&#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;)&#125;,wrapAll: function(structure)&#123; if (this[0]) &#123; $(this[0]).before(structure = $(structure)) var children // drill down to the inmost element while ((children = structure.children()).length) structure = children.first() $(structure).append(this) &#125; return this&#125;,wrapInner: function(structure)&#123; var func = isFunction(structure) return this.each(function(index)&#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;)&#125;,unwrap: function()&#123; this.parent().each(function()&#123; $(this).replaceWith($(this).children()) &#125;) return this&#125;,clone: function()&#123; return this.map(function()&#123; return this.cloneNode(true) &#125;)&#125;,hide: function()&#123; return this.css("display", "none")&#125;,toggle: function(setting)&#123; return this.each(function()&#123; var el = $(this) ;(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide() &#125;)&#125;,prev: function(selector)&#123; return $(this.pluck('previousElementSibling')).filter(selector || '*') &#125;,next: function(selector)&#123; return $(this.pluck('nextElementSibling')).filter(selector || '*') &#125;,html: function(html)&#123; //若有参数修改innerhtml的值 return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : //若没参数则直接返回innerHTML值 (0 in this ? this[0].innerHTML : null)&#125;,//文本内容修改，获取text: function(text)&#123; return 0 in arguments ? this.each(function(idx)&#123; var newText = funcArg(this, text, idx, this.textContent) this.textContent = newText == null ? '' : ''+newText &#125;) : (0 in this ? this.pluck('textContent').join("") : null)&#125;,attr: function(name, value)&#123; var result //若无第二个参数 return (typeof name == 'string' &amp;&amp; !(1 in arguments)) ? //返回第一个DOM的属性值 (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : 若有参数，则set属性的值 this.each(function(idx)&#123; if (this.nodeType !== 1) return if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;)&#125;,removeAttr: function(name)&#123; return this.each(function()&#123; this.nodeType === 1 &amp;&amp; name.split(' ').forEach(function(attribute)&#123; setAttribute(this, attribute) //这个this是怎么传的？ &#125;, this)&#125;)&#125;,//这个是怎么用的 不懂prop: function(name, value)&#123; name = propMap[name] || name return (1 in arguments) ? this.each(function(idx)&#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : (this[0] &amp;&amp; this[0][name])&#125;,//删除DOM节点中的一条属性removeProp: function(name)&#123; name = propMap[name] || name return this.each(function()&#123; delete this[name] &#125;)&#125;,data: function(name, value)&#123; //设置自定义属性data- ,若没有传入属性的值则仅设置属性，返回序列化的data的属性值 var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase() var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName) return data !== null ? deserializeValue(data) : undefined&#125;,val: function(value)&#123; // 有参数，设置值 if (0 in arguments) &#123; if (value == null) value = "" return this.each(function(idx)&#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; // 如果元素是 &lt;select multiple&gt; 多选列表返回数组 return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find('option').filter(function()&#123; return this.selected &#125;).pluck('value') : this[0].value) &#125;&#125;,offset: function(coordinates)&#123; //如果参数存在，则设置对应的属性 if (coordinates) return this.each(function(index)&#123; var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125; //如果属性为static则改为relaticv并赋值 if ($this.css('position') == 'static') props['position'] = 'relative' $this.css(props) &#125;) if (!this.length) return null if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125; var obj = this[0].getBoundingClientRect() return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125;&#125;,css: function(property, value)&#123; if (arguments.length &lt; 2) &#123; //获取第一个元素 var element = this[0] //如果属性为字符串，则修改css的值 if (typeof property == 'string') &#123; if (!element) return return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property) //如果属性为数组，则返回对应的属性值 &#125; else if (isArray(property)) &#123; if (!element) return var props = &#123;&#125; var computedStyle = getComputedStyle(element, '') $.each(property, function(_, prop)&#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;) return props &#125; &#125; var css = '' // 其他情况：有两个参数、property是对象 if (type(property) == 'string') &#123; // property 是字符串，设置单个样式 if (!value &amp;&amp; value !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(property)) &#125;) else css = dasherize(property) + ":" + maybeAddPx(property, value) &#125; else &#123; for (key in property) //property 是对象，若属性值为空或未定义，则删除属性 if (!property[key] &amp;&amp; property[key] !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(key)) &#125;) else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';' &#125; //通过cssText修改CSS return this.each(function()&#123; this.style.cssText += ';' + css &#125;)&#125;,index: function(element)&#123; //有参数则返回该dom的index，否则返回该dom在兄弟元素中的index return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])&#125;,hasClass: function(name)&#123; //判断是否有某一css属性 if (!name) return false return emptyArray.some.call(this, function(el)&#123; return this.test(className(el)) &#125;, classRE(name))&#125;,addClass: function(name)&#123; if (!name) return this return this.each(function(idx)&#123; //判断是否存在className属性 if (!('className' in this)) return classList = [] //保留原来的class var cls = className(this), newName = funcArg(this, name, idx, cls) //数组中存入不存在的class newName.split(/\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) //传入className classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;)&#125;,removeClass: function(name)&#123; return this.each(function(idx)&#123; //判断是否存在className属性 if (!('className' in this)) return if (name === undefined) return className(this, '') classList = className(this) funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass)&#123; //将匹配的cssName替换为空 classList = classList.replace(classRE(klass), " ") &#125;) //赋值cssName className(this, classList.trim()) &#125;)&#125;,toggleClass: function(name, when)&#123; if (!name) return this return this.each(function(idx)&#123; var $this = $(this), names = funcArg(this, name, idx, className(this)) names.split(/\s+/g).forEach(function(klass)&#123; // 如果有 when 参数，则只通过when参数判断，true则只执行addClass，false则只执行removeClass // 如果没有 when 参数，则判断元素有没有该class，有则移除，没有则添加 (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;)&#125;,scrollTop: function(value)&#123; if (!this.length) return var hasScrollTop = 'scrollTop' in this[0] //如果无参数，直接返回属性值 if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset return this.each(hasScrollTop ? function()&#123; this.scrollTop = value &#125; : function()&#123; this.scrollTo(this.scrollX, value) &#125;)&#125;,scrollLeft: function(value)&#123; //同上 if (!this.length) return var hasScrollLeft = 'scrollLeft' in this[0] if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset return this.each(hasScrollLeft ? function()&#123; this.scrollLeft = value &#125; : function()&#123; this.scrollTo(value, this.scrollY) &#125;)&#125;,position: function() &#123; if (!this.length) return var elem = this[0], // 找到第一个定位过的祖先元素 “relative”, “absolute” or “fixed” offsetParent = this.offsetParent(), // 获取当前偏移 offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset() // 去掉当前元素的 margin 宽度 // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( $(elem).css('margin-top') ) || 0 offset.left -= parseFloat( $(elem).css('margin-left') ) || 0 // 增加父元素的 border 宽度 parentOffset.top += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0 parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0 // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125;&#125;,offsetParent: function() &#123; return this.map(function()&#123; var parent = this.offsetParent || document.body // 如果获取的parent不是null、不是body或html、而且position==static，继续查找，直到为根元素 while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css("position") == "static") parent = parent.offsetParent return parent &#125;)&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记·失乐园]]></title>
    <url>%2F2017%2F07%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%B1%E4%B9%90%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[最近天气爆炸，天天35°+前些天暂时忙完老师那边的项目，看了些乱七八糟的教程，完全冷静不下来，又打开了尘封快半年的kindle… 就在忙项目那几天，看了两本东野圭吾的小说，毕竟推理小说，拿起kindle就放不下来了，分分钟就看完了，但感觉看的时候自己确完全不带脑子，就想着看结局而去看的…现在回想起来，嗯..真的好没意思啊,不过东野圭吾最近也在也些非纯推理的小说，明明之前就是因为他的纯推理小说才入的坑，现在反而无感了。要是本本都像《嫌疑人X的献身》那样的那简直素晴らしい、但很明显这不可能啦 挑了本之前很早就想看的《失乐园》，应该还有《复乐园》、《欲乐园》但kindle商店里好像没有哎 主要内容男主久木在一次集会中经同事的介绍认识了从事书法工作的女主凛子，几乎可以说是一见钟情，很快两人就发展为了男女关系。而两人却都有各自家庭，为了能个秘密约会，两个通过各种借口经常夜不归宿，最后导致双方家庭破裂，同时男主女主终于能够在伦理道德的压力下生活在一起。但很快他们意识到此刻，是他们快乐的顶峰，面对无法预测的未来，两人最终毅然选择了死亡。 感想感觉整本书3/4都在做爱，见面就做爱，这种做爱，各种花式做爱，还玩起了SM…看到一半甚至疑惑，现实中真会有人这样么？违背社会伦理道德，仅仅用真爱的借口来满足自己。可以说是自私么？确实最后凛子留给世人的表情依旧是快乐的，久木对死前的生活明显也是满足的，于是在这快乐的巅峰，选择了死亡，甚至最后一段时间就是为了能制定一个完美的自杀计划。这大概就是爱的一种最极端表现？ 摘录 “人的一生无论看上去多么波澜壮阔，在到达终点回首往事时，却显得格外平庸。当然，哪种活法都会有遗憾，不过，至少不应该在临死的时候，才想到“糟糕”、“应该早点做”等悔不当初的话。” 对于原本性的快感比较弱的男人们，往往比较关注由于性行为所引起的各种各样的反映更甚于行为本身。因为这是深爱着的女人激情燃烧时的姿态，声音和表情。这些姿态，声音和表情就像万花筒一样不断的变化着，朝着最终目标迈进。认知并实实在在感觉到这一切，男人才能的到身心两方面的满足。 和妻子的关系现在虽说冷若冰霜，然而，一年半之前是很正常的夫妻，再往前推，是十分恩爱的一对儿，若追溯到新婚时期，则是自由恋爱结合的情侣。——你看，每个人都是这样对不对，不管从前多么相爱，到最后仍会考虑分离、全心意为另一个人的欢乐而努力。]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识]]></title>
    <url>%2F2017%2F07%2F23%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[最近又把红宝书翻了一遍，顺便整理下基础的东西前端大坑，现在还是再看看最基础的吧 JavaScript基础整理类型基本类型* number * string * boolean * null * undefined 引用类型* object * array * function(函数对象) 基本包装类型&amp;特殊引用类型（p119 不建议显式创建基本包装类型） * Boolean * Number * String str.tostring() str.substring() 过程* 创建实例 * 在该实例上调用制定方法 * 销毁这个实例 查找字符串中所有字符12345678var str = 'hello world'var posArr = new Array()var pos = str.indexOf("o")while(pos &gt; -1) &#123; posArr.push(pos) pos = str.indexOf("0",pos+1)&#125;console.log(posArr) //[4,7] 基本类型检查测 typeof用于检测基本类型 12345678typeof undefined //undefinedtypeof '123' //stringtypeof 123 //numbertypeof true //booleantypeof &#123;&#125; //objecttypeof [] //objecttypeof null //objecttypeof console.log //function 引用类型检测 Object.prototype.toString.call(arr) //[object Array] arr instanceof Array //true 类型转换 字符串拼接时 let msg = 100 + 10 //110 let msg = 100 + ‘10’ //10010 if语句判断时 ==/===null == undefinednull !== undefined 内置函数 object array boolean number string function data regexp error 数组迭代方法 forEach every some sort //a-b (从小到大) b-a（从大到小） map filter 类数组对象转化为数组Array.prototype.slice.call(arguments,0) 对象API12345for(let key in obj)&#123; if (obj.hasOwnProperty(key)) &#123; //判断是否非原型中属性 console.log(key, obj[key]) &#125;&#125; object主要属性和方法 constructor //保存着创建当前对象的函数（即构造函数） hasOwnProperty(prototype) //判断属性是否在当前实例中 isPrototypeOf(object) //检查传入的对象是否当前对象的原型 垃圾收集 标记清除 引用计数 对象，原型,原型链,继承执行new的过程使用new关键字调用函数（new ClassA(…)）的具体步骤： 创建空对象； var obj = {}; 设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象； obj.proto = ClassA.prototype; 使用新对象调用函数，函数中的this被指向新实例对象： ClassA.call(obj); //{}.构造函数(); 将初始化完毕的新对象地址，保存到等号左边的变量中 创建对象的构造函数模式与原型模式 构造函数模式缺陷：每个方法都在实例上重新创建了 原型模式缺陷：属性与方法被共享，导致引用类型无法保证独立原型与构造函数组合创建对象12345678910111213141516171819function Ele (id) &#123; thi.ele = document.getElementById(id)&#125;Ele.prototype.html = function (val) &#123; let ele = this.ele if (val) &#123; ele.innerHTML = val return this //用于链式操作 &#125; else &#123; return ele.innerHTML &#125;&#125;Ele.prototype.on = function (type, fn) &#123; let ele = this.ele ele.addEventListener(type, fn) return this&#125;var div = new Ele('div')div.html('XXX').on('click',() =&gt; &#123;console.log('')&#125;) 常用操作instanceofinstanceof 用于判断对象和函数 (即引用类型)instanceof是检测对象的原型链是否指向构造函数的prototype对象 proto指向其构造函数的prototype (指向上一层的原型) hasOwnProtpertyobj.hasOwnProtperty(property) 检测是否为自身属性（不包含来自原型的属性） in操作符property in obj //判断property是否能在对象中访问到 constructorof实例被创建时同时创建prototype对象，对象会自动获得constructor属性（P155）subObj.constructorof == supersubObj.constructorof == Object 继承确定原型与实例关系 实例 instanceof 构造函数 构造函数.prototype.isPrototypeOf(实例) (P165)判断构造函数的原型是否在实例的原型链中 原型链继承的例子123456789101112function Animal () &#123; this.eat = function () &#123; console.log ('animal eat') &#125;&#125;function Dog () &#123; this.sleep = function () &#123; console.log('dog sleep') &#125;&#125;Dog.prototype = new Animal () //原型链继承let keji = new Dog() 存在的问题 1. 引用类型被共享 2. 无法传递参数（若传递参数，则其他实例也会受影响） 借用构造函数123456789function SuperType (name) &#123; this.name = name this.color = ['red','blue','black']&#125;function SubType (name) &#123; //继承Super SuperType.call(this, name)&#125;let instance = new SubType('Nic') 存在问题 1. 方法在构造函数中，无法复用 2. 超类中原型中定义的方法，子类无法使用 组合继承123456789101112131415161718function SuperType (name) &#123; this.name = name this.color = ['red','blue','black']&#125;SuperType.prototype.sayname = function () &#123; alert(this,name)&#125;function SubType (name, age) &#123; //继承Super属性 SuperType.call(this, name)&#125;SubType.prototype = new SuperType()SubType.prototype.constructor = SubtyppeSubType.prototype.sayage = function () &#123; alert(this.age)&#125;let instance = new SubType('Nic','20') 函数callee&amp;callerarguments.callee //指向arguments的对象函数本身,可用于递归arguments.callee.calller&amp;fun.caller //指向该函数引用（alert(fun.caller)） this根据函数执行来确定call(obj,param1,param2)apply(obj,arguments)箭头函数 this的指向问题 apply&amp;call appply(this.arguments) call(this,param1,param2) 闭包的应用1234567891011121314function isFirstLoad () &#123; var _list = [] //私有变量 return function (id)&#123; if (_list.indexOf(id) &gt;= 0)&#123; return false &#125; else &#123; _list.push(id) return true &#125;&#125;var firstLoad = is FirstLoad()firstLoad(10) //true firstLoad(10) //falsefirstLoad(20) //true 10个li点击的应用1234567891011//错误方法 var i,a for (i = 0;i &lt; 10;i++) &#123; a=document.createElement('a') a.innerHTML = i + '&lt;br&gt;' a.addEventListener('click', function (e) &#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125; 123456789101112131415//正确方法（不传入变量i也可以） var i for (i = 0;i &lt; 10;i++) &#123; (function (i)&#123; var a a=document.createElement('a') a.innerHTML = i + '&lt;br&gt;' a.addEventListener('click', function (e) &#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125;)(i) &#125; 闭包中this指向（P182）123456789var obj = &#123; name: 'summerscar', sayName: function () &#123; return function () &#123; return(this) &#125; &#125;&#125;console.log(obj.sayName()()) //window 块级作用域（私有作用域）1234(function()&#123; //此处为块级作用域&#125;)()//相当于建立一个自执行的函数作为一段代码中语句 相当于这种写法1234let fn = function() &#123; //块级作用域&#125;fn(); 然而这样写会出错123function()&#123;&#125;() //出错 P185 function作为关键字，会被认定为函数声明，因而不能使用（），而函数表达式可以使用（），为函数加上（fun(){}）即可 私有属性（P186）私有变量特点：利用构造函数 每个实例拥有自己的属性和方法123456789101112function MyObject() &#123; //私有变量及方法 var privateVar = 10 function privateFun() &#123; return false &#125; //特权方法 this.publicMethod = function() &#123; privateVar++ return privateFun() &#125;&#125; 静态私有变量特点：利用块级作用域，定义属性，使用函数表达式创建构造函数，方法定义在原型中，每个实例间可以共享方法和属性123456789101112131415(function()&#123; var privateVar = 10 function privateFun () &#123; return false &#125; //构造函数 MyObject = function () &#123; &#125; //特权方法 MyObject。prototype.publicMethod = funtion () &#123; privateVar ++ return privateFun () &#125;&#125;)() 以下两种还不太懂 模块模式123456789101112131415var sigleton = function () &#123; var privateVar = 10 function privateFun () &#123; return false &#125; //返回对象 return &#123; publicProperty: true, publicMethod: funtion () &#123; privateVar ++ return privateFun () &#125; &#125;&#125; 增强的模块模式123456789101112131415var sigleton = function () &#123; var privateVar = 10 function privateFun () &#123; return false &#125; //创建对象 var object object.publicProperty: true, object.publicMethod: funtion () &#123; privateVar ++ return privateFun () &#125; return object&#125; DOM dom数据结构为树形结构 DOM类型 document类型 nodeTyoe: 9 Element类型 nodeType: 1 元素标签判断: elem.tagName.toLowerCase() == ‘div’ get/set/removeAttribute()自定义属性值 Attribute类型 nodeType: 2 Text类型 nodeType: 3 normalize() 合并两个或两个以上的文本节点 splitText(pos)根据pos位置分割文本节点 表格操作的特使方法&gt;P282 DOM对象节点获取 getElementById… querySelector querySelectorAll matchesSelector() el.matchesSelector(“el的CSS选择”) 判断调用元素是否与选择符匹配 自定义属性data12345let div = get.elementById("myDiv")//获取data-appid的值var apppid = div.dataset.appid//设置data-appid的值div.data.appid = "233" scrollIntoView() (P298)//让元素可见（即出现在视口中） div.scrollIntoView() Attribute&amp;propertyAttribute //标签中属性property //对象属性 DOM2与DOM3的变化访问样式 有连词符的需转换为驼峰式写法 float为JS的保留字，需写为cssFloat cssText 读取模式：访问style特性中的CSS代码 写入模式：重写整个style特性的值，以前指定的样式将丢失 BOMwindownavigatornavigator.userAgent.indexOf(‘Chrome’) screenlocation assign //下者调用该方法 href //完整链接&amp;改变网站地址 replace //跳转但不产生记录 protocol //http: host // xxx/ pathname // /xxx search // ?查询字符 hash // #链接 reload //刷新 若reload(true),则刷新缓存 history back forword go(num) 事件冒泡&amp;捕获DOM2级事件规定的事件流 1.事件捕获阶段2.处于目标阶段3.时间冒泡阶段 事件对象e.preventDefault //阻止默认事件e.stopPropatation //阻止事件冒泡 blur与focus的焦点事件不会冒泡 HTML5事件(P388) contentmenu //右击上下文菜单 beforeunload //浏览器卸载页面之前 DOMContentLoaded //DOM树形成后触发 hashchange //url后#后面字符发生变化时 Canvas合成 globalAlpha globalCompositionOperation HTML5脚本编程 video与audio的属性与方法 （P487） Ajax12345678910var xhr = new XMLHttpRequest()xhr.open("GET", "URL", false)xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if(xhr.status == 200)&#123; console.log(xhr.responseText) &#125; &#125;&#125;xhr.send(null) readyState 0 未初始化 1 启动 已调用open() 2 发送 已调用send（） 3 接收 已接收到部分数据 4 完成 http返回码 status 2xx 成功 3xx 重定向（会自动跳转） 4xx 客户端请求错误 5xx 服务端错误 跨域条件3个条件 1.协议 2.域名 3.端口 CORS jsonp Jsonp实现原理1234window.callback = function (data) &#123; console.log(data)&#125;&lt;script src="api.js"&gt;&lt;/script&gt; //返回 callback(&#123;x: 100&#125;) 即调用callback函数 存储浏览器性能相关浏览器渲染页面过程 根据HTML结构生成DOM tree 根据CSS生成CSSOM 将DOM和CSSM整合形成RenderTree 根据 RenderTree 开始渲染和展示 遇到 script标签时，会执行并阻塞渲染 (所以script放在body最后，不会阻塞Dom加载) load &amp; DOMContentLoaded 事件 load 页面全部资源加载完成 DOM 渲染完即执行，此时图片，视频可能未加载完成 加载资源加载优化 静态资源合并（减少、合并静态资源的加载js,css img base64） 静态资源缓存 使用CDN ssr服务器渲染，数据页面在服务器端完成 渲染优化 JS放后面 懒加载 减少DOM查询 （缓存在变量中） 减少DOM操作（尽量合并操作，使用innerHTML操作） 时间节流（事件的延迟执行，如查询时的输入下拉框） 今早执行操作 DOMContentLoaded 安全 XSS 跨站脚本攻击(Cross Site Scripting) 发送数据中包含script代码（替换关键字如/&lt;） CSRF（Cross-site request forgery跨站请求伪造）伪造正确的链接（电子邮件中隐含的虚假链接，增加验证流程）本文简单的介绍Self-XSS(自跨站脚本攻击)、CSRF(跨站请求伪造攻击)和恶意服务器这三种社会工程学的辅助攻击手段, 希望能够给予自认为身处于安全环境中的网民以自知的同时, 学会不惮以最坏的恶意来推测他人. Self-XSSXSS(跨站脚本攻击)是一种攻击者在目标网站中嵌入恶意客户端脚本以达到其不可告人目的的攻击行为. 现在大多数的网站都对XSS有所防范, 攻击者已经很难在现代网站上找到可以提交恶意脚本的XSS漏洞. 在XSS前加上Self, 就是Self-XSS(自跨站脚本攻击), 与Self这个词的意思一样, 这是一种需要受害者自己配合才能成功的XSS攻击行为, 这也是它被我归类为一种社会工程学攻击的原因. 受害者出于某种原因, 在目标网站上运行了某段由攻击者提供的恶意脚本, 就使得Self-XSS攻击成立. 一些人看到这里可能会嗤之以鼻, 认为自己不会犯下这么低级的错误, 然而事实却是, Self-XSS可以从各种各样的渠道被实现, 尤其是很多没有代码审查能力的”自称极客”所使用的那些工具, 是的, 我说的就是Bookmarklet、Greasemonkey和其他在浏览器上安装的各种Extension, 它们都有可能被用于Self-XSS攻击, 成功的攻击范例数不胜数. 在Google+打开浏览器控制台, 会发现Google直接打印出了不要在此页面运行脚本的警告, 大多数的现代浏览器的地址栏, 也会在用户粘贴以”javascript:”开头的URL时, 自动去除”javascript:”内容, 可见Self-XSS的危险性. CSRFCSRF(Cross-Site Request Forgery)是一种欺骗式的攻击手段, 攻击者会构造一个带有恶意的目标网站的URL, 并引诱受害者点击链接或以其他方式迫使浏览器发出请求来达到攻击者的目的. 是否可以实现CSRF攻击, 与目标网站是否存在可供实现CSRF攻击的漏洞有关. 我们试想这样的一种情况, 目标网站有一个用于删除用户的URL地址, 当然, 只有拥有管理员Cookie的用户才可以通过请求这个URL来删除用户, 攻击者得知这个URL之后, 构造了一个带有欺骗性的链接, 引诱了拥有管理员Cookie的用户的点击, 使得目标用户被成功删除. 在非现代浏览器或同源策略存在漏洞的IE浏览器上, 可能会产生另一种利用带有Cookie的跨站请求实现的CSRF攻击, 不过只要用户使用大部分先进的现代浏览器, 便很难遭遇这种攻击. 另外, 网站开发者如果能严格遵守RESTful的URL规范和CORS协议, 不构建能通过GET请求对数据库进行增减操作的URL, 也能起到对CSRF攻击一定的防范效果. 恶意服务器恶意服务器指那些被带有恶意的网站管理员控制的服务器, 是一个宽泛的概念, 恶意服务器有多种用法, 包括但不限于以下几种: 记录用户输入的错误密码事实上, 有很多网站都可能是恶意服务器, 作为用户, 你不知道他们是否会将你在登录时的错误密码记录下来, 对于同时使用很多种密码的人而言, 这是一个巨大的威胁, 一旦你忘记自己在该网站上的密码, 你就会开始尝试自己常用的几种密码, 而在你使用正确的密码登录服务器之前, 你的错误密码已经被网站后台记录下来, 这在之后可能将被用于其他网站数据库的撞库测试. 要想避免这种攻击, 只能让网站本身不传输明文密码, 例如在前端的登录环节里加上一道单向加密, 这样你的明文密码才不会被传到服务器上, 当然, 后端也不能因为前端进行了加密, 就放弃双端加密的基本原则, 否则将得不偿失. 暴露目标用户的真实IP地址这是一种典型的钓鱼手段, 在用户直接接入互联网的情况下, 如果打开了攻击者提供的网站, 那么用户的真实IP地址就很有可能被暴露给了攻击者, 攻击者就可以以此为基础实行其他的攻击. 不过在中国逐渐局域网化的今天, 这种攻击方式的成功率已经变得越来越低了. 行为记录用户在网站上的行为, 实际上有可能被一一记录下来, 从这些记录里, 攻击者可以轻易的推算你的作息时间等信息, 网站规模越大, 可能掌握的信息也就越多, 可推测的情报也就越丰富. 一些现代浏览器加入了”防止追踪”的功能, 也是基于同样的考量. 恶意服务器的可怕之处在于你几乎无法知道你访问的是否是一个恶意服务器, 任何一个大网站都有可能是恶意服务器, 但你又不得不去使用它们提供的服务, 你时刻都有可能处于监视之中, 却无法自知.]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的常用功能]]></title>
    <url>%2F2017%2F07%2F12%2FES6%2F</url>
    <content type="text"><![CDATA[最近简单浏览了下ES2015的东西，好多看不太懂，看懂了也不清楚怎么去用暂时把一些也许用得到的整理一下 let,const let 仅块级作用域有效 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 class, extends, super与TypeScript一致123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello 模板字符串12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 数值number.issafeinterger //math.trunc //取小数 整数部分math.sign //数字正负 解构个人觉得可用于Ajax部分数据的获取1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125; 数组转换伪数组 如getElementsByClass1234567891011var divs = Array.from(document.querySelectorAll('div'))divs.forEach((value, index) =&gt; &#123;&#125;)Array.from(arr) Array.from([1,2,3],function(item)&#123;return item*2&#125;) 类似map功能[1,2,undefiend].fill(7);[1,2,3].fill(7,1,3) 填充7 从1位置到3[1,2,3,4,5,6].find(function(item)&#123;return item&gt;3&#125;) //返回4[1,2,3,4,5,6].findIndex(function(item)&#123;return item&gt;3&#125;) //返回下标3[1,2,undefiend].includes(1) 函数default, restdefault参数赋默认值1234function animal(type = 'cat')&#123; console.log(type)&#125;animal() rest1234function animals(...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //["cat", "dog", "fish"] 对象1object.assign(&#123;&#125;,&#123;&#125;); //对象拼接 模块化export1234567891011121314151617181920212223242526272829303132333435//1.变量导出export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;//变量对象导出var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;//函数导出export function multiply(x, y) &#123; return x * y;&#125;;//导出时重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;;//export default仅导出一个export default const str = 'hello world'import str from 'demo1' //导入的时候没有花括号 import123456789import &#123;firstName, lastName, year&#125; from './profile';//导入后重命名import &#123; lastName as surname &#125; from './profile';//全部导入并命名import * as circle from './circle'; symbola1=symbol() a2=symbol() a1!=a2]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门学习]]></title>
    <url>%2F2017%2F07%2F05%2Fvuex%2F</url>
    <content type="text"><![CDATA[自学习Vue也有一段时间了，感觉还没需要用到Vuex的必要，找了一些入门教程学习了下暂时先了解下主要的用法 gettersgetB：function（state）{ return state.b } computed中 return $store.getters.getB statestate:{b:0} computed return $store.state.XX mutatiomsfunA:function(state,a){ state.b+=a; } 在methods中调用 add:function(){this.$store.commit(&apos;funA&apos;,a);} actions在action中为异步操作（将ajax放入）或者为 多个mutation的封装（同时操作多个mutation） increase:function(context,a){ context.commit(&apos;funA&apos;,a) } 在methods中 add:function(){this.$store.dispatch(&apos;increase&apos;,a);}]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门学习]]></title>
    <url>%2F2017%2F06%2F26%2Fnode-js%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近想写个记事本的webApp，打算上node.js，mongodbnode还不太会用，先学下基本的路由，数据返回，调用mongo这些入门级别的试试看吧 解决NodeJS+Express模块的跨域访问控制问题：Access-Control-Allow-Origin123456789101112131415161718var express = require('express');var app = express();//设置跨域访问app.all('*', function(req, res, next) &#123; res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By",' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); next();&#125;);app.get('/auth/:id/:password', function(req, res) &#123; res.send(&#123;id:req.params.id, name: req.params.password&#125;);&#125;);app.listen(3000);console.log('Listening on port 3000...'); 7.19更新最近忙完老师的项目了，然后把之前的坑补完记事本前台基本差不多完成了有空再写个后台的管理平台]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端meta设置]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFmeta%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近写移动端网站，还有默认全屏运行的设置资料整理下移动端的常用meta的设置以及webApp的设置1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"/&gt; 1、WebApp全屏模式：1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui"&gt; 注意：viewport 后面加上 minimal-ui 在safri 体现效果1&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; 2、隐藏状态栏/设置状态栏颜色：1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /&gt; 3、safri 添加到主屏界面的显示标题：1&lt;meta name="apple-mobile-web-app-title" content="应用标题"&gt; 4、忽略自动识别数字为电话号码：1&lt;meta content="telephone=no" name="format-detection" /&gt; 5、忽略自动识别邮箱账号：1&lt;meta content="email=no" name="format-detection" /&gt; 6、常用浏览器全屏设置：12345678910111213141516171819202122232425262728&lt;!-- uc强制竖屏 --&gt;&lt;meta name="screen-orientation" content="portrait"&gt;&lt;!-- UC强制全屏 --&gt; &lt;meta name="full-screen" content="yes"&gt;&lt;!-- UC应用模式 --&gt; &lt;meta name="browsermode" content="application"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name="x5-orientation" content="portrait"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name="x5-fullscreen" content="true"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name="x5-page-mode" content="app"&gt; &lt;!-- 是针对一些老的不识别viewport的浏览器，列如黑莓 --&gt;&lt;meta name="HandheldFriendly" content="true"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name="MobileOptimized" content="320"&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource中的GET与POST请求]]></title>
    <url>%2F2017%2F06%2F25%2Fvue-resource%E4%B8%AD%E7%9A%84GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[vue-resource 使用比 jQuery 更加简洁的方式实现了异步请求功能，还提供了比如 interceptors 这样处理请求过程中行为的功能。下面介绍下vue-resource中常用的GET与POST请求使用与封装方法。 Get请求1234567891011121314151617function getRequest(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; Vue.http.get( url, &#123; params: params &#125;, &#123;emulateJSON: true&#125; ) .then((res) =&gt; &#123; resolve(res); &#125;) .catch((res) =&gt; &#123; reject(res); &#125;); &#125;);&#125; Post请求1234567891011121314151617function postRequest(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; Vue.http.post( url, &#123; params &#125;, &#123;emulateJSON: true&#125; ) .then((res) =&gt; &#123; resolve(res.body); &#125;) .catch((res) =&gt; &#123; reject(res.body); &#125;); &#125;);&#125; 使用12345678910var params = new Object(); //创建params对象var params.id = id; //传递参数var url = url; //url地址postRequest(url, params).then((message) =&gt; &#123; //这里处理成功回调&#125;).catch((message) =&gt; &#123; //这里处理失败回调&#125;);]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB配置]]></title>
    <url>%2F2017%2F06%2F24%2FmongoDB%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[7.19更新 记事本前台部分差不多写完了，找时间撸个后台管理吧 想写个记事本的webApp顺便尝试下mongodb数据库的使用当然还是从最简单的配置入手啦 初始化 根目录建立数据库文件夹D:\Program Files\MongoDB\Server\3.0\db 建立log文件夹D:\Program Files\MongoDB\Server\3.0\log 执行cmd设置数据库文件夹mongod –dbpath “D:\Program Files\MongoDB\Server\3.0\db” 安装至服务 根目录新建mongod.cfg 12345systemLog: destination: file path: D:\Program Files\MongoDB\Server\3.0\log\mongod.logstorage: dbPath: D:\Program Files\MongoDB\Server\3.0\db cmd执行 12mongod --config "D:\Program Files\MongoDB\Server\3.0\mongod.cfg" --install 启动服务 在“命令指示符”窗口输入： net start MongoDB mongoskin操作http://www.hacksparrow.com/mongoskin-tutorial-with-examples.htmlhttp://www.jb51.net/article/55752.htm 数据库：同关系数据库一样。 集合： 关系数据库中的表。 文档： 类比关系数据库的记录，实则是JSON对象。 数据库设计：建议考虑NoSQL设计，抛弃关系数据的设计思想；其实NoSQL数据库设计博大精深，需要不断地在项目中实践。 用户体系：每一个数据库都有自己的管理员，可以: 1use dbname; db.addUser('root_1' , 'test'); 6.建议更改对外端口 7.启动服务（这是win下，linux下稍作修改）： 1mongod --dbpath "XX\MongoDB\data\db" --logpath "XX\MongoDB\log\mongo.log" --logappend -auth --port 7868 搭建mongodb开发基础设施npm install mongoskin 安装mongoskin 这里不介绍Node.js安装、package等机制。 创建配置文件 config.json{ &quot;dbname&quot;:&quot;TEST&quot;, &quot;port&quot;: &quot;7868&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;test&quot; } 创建util相关类mongo.js ：导出一个DB对象var mongoskin = require(&apos;mongoskin&apos;), config = require(&apos;./../config.json&apos;); /* * @des：导出数据库连接模块 * */ module.exports = (function(){ var host = config.host, port = config.port, dbName = config.dbname, userName = config.username, password = config.password, str = &apos;mongodb://&apos; + userName + &apos;:&apos; + password + &apos;@&apos; + host +&apos;:&apos; + port+ &apos;/&apos; + dbName; var option = { native_parser: true }; return mongoskin.db(str, option); })(); 构建CRUD的基础类：为了减少重复CURD代码，只需要传入相关的JSON对象即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var db = require('./mongo.js'), status = require('./status'), mongoskin = require('mongoskin');var CRUD = function(collection)&#123; this.collection = collection; db.bind(this.collection);&#125;;CRUD.prototype = &#123; /* * @des: 创建一条记录 * @model: 插入的记录，JSON格式的model * @callback：回调，返回插入成功的记录或者失败信息 * * */ create: function(model, callback)&#123; db[this.collection].save(model, function(err, item)&#123; if(err) &#123; return callback(status.fail); &#125; item.status = status.success.status; item.message = status.success.message; return callback(item); &#125;); &#125;, /* * @des：读取一条记录 * @query：查询条件，Mongo查询的JSON字面量 * @callback：回调，返回符合要求的记录或者失败信息 * * */ read: function(query, callback)&#123; db[this.collection].find(query).toArray(function(err, items)&#123; if(err)&#123; return callback(status.fail); &#125; var obj = &#123; status: status.success.status, message: status.success.message, items: items &#125;; return callback(obj); &#125;); &#125;, /* * @des：更新一条记录 * @query：查询条件，Mongo查询的JSON字面量，此处为_id * @updateModel：需要更新的JSON格式的模型 * @callback：返回成功或者失败信息 * * */ update: function(query, updateModel, callback)&#123; var set = &#123;set: updateModel&#125;; db[this.collection].update(query, set, function(err)&#123; if(err)&#123; return callback(status.fail); &#125;else&#123; return callback(status.success); &#125; &#125;); &#125;, /* * @des：删除一条记录 * @query：查询条件，Mongo查询的JSON字面量 * @callback：返回失败或者成功的信息 * * */ deleteData: function(query, callback)&#123; db[this.collection].remove(query, function(err)&#123; if(err)&#123; return callback(status.fail); &#125; return callback(status.success); &#125;); &#125;&#125;;module.exports = CRUD; 构建status.json，因为需要一些状态表示成功和失败，后期可以拓展为验证码错误、短信验证错误、用户名错误等12345678910111213141516171819202122232425module.exports = &#123; /* * 成功状态 * * */ success: &#123; status: 1, message: 'OK' &#125;, /* * 失败状态 * * */ fail: &#123; status: 0, message: 'FAIL' &#125;, /* * 两次输入的密码不一致 * */ repeatPassword: &#123; status: 0, message: '两次输入的密码不一致' &#125; &#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2017%2F06%2F23%2FPromise%2F</url>
    <content type="text"><![CDATA[据说ES6的Promise很厉害，先大概了解下基本用法 基本用法1234567891011function runAsync()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 axios(...) .then((res) =&gt; &#123;resolve(res&#125;)) .catch((err) =&gt; &#123;reject(err)&#125;) &#125;); &#125;runAsync().then((res) =&gt; &#123;&#125;).catch((err) =&gt; &#123;&#125;) 链式操作1234567891011//链式操作runAsync() .then((res) =&gt; &#123; &#125;) .then(() =&gt;&#123; return runAsync() &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); race的用法若其中有一个完成则执行then12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 参考：http://www.cnblogs.com/lvdabao/p/es6-promise-1.html]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js的变量与属性]]></title>
    <url>%2F2017%2F06%2F18%2FJs%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[js的全局环境中通过var a 定义的变量能够通过window.a访问，同时不使用var 即直接定义b 可以理解为建立一个全局变量，实际上可以理解为window的b属性。下面就是变量与属性的区分。变量声明是必须通过 var 语句来完成的，未通过var 语句声明的全局变量都是都是window对象的属性。这样就很容易的理解变量和对象属性的关系了。 delete操作符是用来删除对象属性的。通过var声明的变量和通过function声明的函数拥有DontDelete特性，是不能被删除。未通过var声明的全局变量（全局对象的属性）可以删除]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript技巧整理]]></title>
    <url>%2F2017%2F06%2F08%2FJS%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[查找元素123$ = function(ele) &#123; return document.querySelector(ele);&#125; JS DATE时间格式化123456789101112131415161718192021// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)// 例子：// (new Date()).Format("yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423// (new Date()).Format("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125; 兼容的事件方法12345678910111213141516171819202122232425262728293031323334353637383940function addEvent(ele, event, hanlder) &#123; if (ele.addEventListener) &#123; ele.addEventListener(event, hanlder, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent('on' + event, hanlder); &#125; else &#123; ele['on' + event] = hanlder; &#125;&#125;``` ``` //utils.jsvar EventHandler = &#123; addEventHandler: function(ele, event, hanlder) &#123; if (ele.addEventListener) &#123; ele.addEventListener(event, hanlder, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent("on"+event, hanlder); &#125; else &#123; ele["on" + event] = hanlder; &#125; &#125;, getCharCode: function (event)&#123; if (typeof event.charCode == "number") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, getTarget: function (event) &#123; return event.target || event.srcElement; &#125;&#125; 获取字符长度1234567891011121314//英文字符长度为1，中文字符长度为2var GetLength = function(str)&#123; var realLength = 0; for (var i = 0; i &lt; str.length; i++) &#123; charCode = str.charCodeAt(i); if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 128) realLength += 1; else realLength += 2; &#125; return realLength;&#125;; 获取index值1[].indexOf.call(lis, target) foreach123456var divs = document.querySelectorAll('div');[].forEach.call(divs, function(div) &#123; // do whatever div.style.color = "red";&#125;); 冒泡时判断元素1target.nodeName.toLowerCase() ==='li' 监听点击li（监听时this会丢失）1234567var ul =document.querySelector('ul');var lis =document.querySelectorAll('ul li');ul.addEventListener('click',function (e) &#123;var target =e.target;if(target.nodeName.toLowerCase() ==='li') &#123;console.log([].indexOf.call(lis, target));&#125;&#125;,false); 链式调用return this //返回当前对象即可链式调用 继承1234567891011function extend(subClass, superClass) &#123; var F = function () &#123; &#125;; F.prototype = superClass.prototype; //子类的prototype指向F的_proto_ ， _proto_又指向父类的prototype subClass.prototype = new F(); //在子类上存储一个指向父类的prototype的属性，便于子类的构造方法中与父类的名称解耦 使用subClass.superClass.constructor.call代替superClass.call subClass.superClass = superClass.prototype; &#125; 基本拖动函数123456789101112131415161718192021window.onload = function ()&#123; // 获取元素和初始值 var oBox = document.getElementById('box'), disX = 0, disY = 0; // 容器鼠标按下事件 oBox.onmousedown = function (e)&#123; var e = e || window.event; disX = e.clientX - this.offsetLeft; disY = e.clientY - this.offsetTop; document.onmousemove = function (e)&#123; var e = e || window.event; oBox.style.left = (e.clientX - disX) + 'px'; oBox.style.top = (e.clientY - disY) + 'px'; &#125;; document.onmouseup = function ()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;;&#125;; 定义二维数组1234567891011//创建二维数组 var arrcj=new Array(); //定义一维数组 for(var i=0;i&lt;td.length/3;i++) &#123; arrcj[i]=new Array(); //将每一个子元素又定义为数组 for(n=0;n&lt;3;n++) &#123; arrcj[i][n]=1; //此时aa[i][n]可以看作是一个二级数组 &#125; &#125; 数组去重对象法（资源占用低）1234567891011Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125; 临时数组法1234567891011Array.prototype.method1 = function()&#123; var arr[]; //定义一个临时数组 for(var i = 0; i &lt; this.length; i++)&#123; //判断当前数组下标为i的元素是否已经保存到临时数组 //如果已保存，则跳过，否则将此元素保存到临时数组中 if(arr.indexOf(this[i]) == -1)&#123; arr.push(this[i]); &#125; &#125; return arr; &#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又到了期末评教的季节]]></title>
    <url>%2F2017%2F06%2F06%2F%E5%8F%88%E5%88%B0%E4%BA%86%E6%9C%9F%E6%9C%AB%E8%AF%84%E6%95%99%E7%9A%84%E5%AD%A3%E8%8A%82%2F</url>
    <content type="text"><![CDATA[网上ctrl+c/v过来的 简单修改了下可以在教务系统上用了 我这chrome,IE 11都没问题，其他Webkit内核浏览器应该也没问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var iframe = document.getElementById('iframeautoheight');var innerDoc = iframe.contentDocument || iframe.contentWindow.document;var selects = innerDoc.getElementsByTagName('select');var scorelist = [];for (var k = 0; k &lt; selects.length; k++) &#123; if (selects[k].id.indexOf("DataGrid1__") &gt; -1) &#123; scorelist.push(selects[k]); &#125;&#125;var rid = Math.ceil(Math.random()*scorelist.length)-1;for (var i = 0; i &lt; scorelist.length; i++) &#123; var ops = scorelist[i].options; for (var j = 0; j &lt; ops.length; j++) &#123; var tempValue = ops[j].value; if (i == rid) &#123; if (tempValue == 'B同意') &#123; /* 随机值（防止评分相同） 可选值 "A强烈同意" | "B同意" | "C一般" | "D不同意" */ ops[j].selected = true; &#125; &#125; else &#123; if (tempValue == 'A强烈同意') &#123; /* 主评价 可选值 "A强烈同意" | "B同意" | "C一般" | "D不同意" */ ops[j].selected = true; &#125; &#125; &#125;&#125;var btn_save = innerDoc.getElementById('Button1');btn_save.click(); 方法1在评教页面 浏览器 F12 Console 一栏下方框框里 复制粘贴 回车即可，重复 ‘课程.length’ 次 方法2浏览器新建书签，网址填入1javascript:(function()&#123; 上方代码 &#125;)(); 在评教页面点击书签即可]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实习面试整理]]></title>
    <url>%2F2017%2F05%2F29%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[最近因为找实习，查了些面试方面的东西，做下准备吧 CSS hack分类 条件注释法 &lt;!--[if IE]&gt; &lt;![endif]--&gt; 类内属性前缀法 *,+,-,_ 选择器前缀法@media screen\9{……}（只对IE6、7生效）@media \0screen{……}（只对IE8生效）@media \0screen\,screen\9{……}（对IE6,7,8生效）@media screen\0{……}（只对IE8、9、10生效）@media screen and (min-width:0\0){……}（只对IE9，10有效）@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){……} 跨域 jsonp 服务器端 继承/原型继承12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 原型链继承123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到简单，易于实现缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中无法实现多继承来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）创建子类实例时，无法向父类构造函数传参 构造继承1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数可以实现多继承（call多个父类对象）缺点： 实例并不是父类的实例，只是子类的实例只能继承父类的实例属性和方法，不能继承原型属性/方法无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 混合继承123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例不存在引用属性共享问题可传参函数可复用缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 点击li1234567var ul =document.querySelector('ul');var lis =document.querySelectorAll('ul li');ul.addEventListener('click',function (e) &#123;var target =e.target;if(target.nodeName.toLowerCase() ==='li') &#123;console.log([].indexOf.call(lis, target));&#125;&#125;,false); 使用link和@import有什么区别* link属于XHTML标签，除了加载css外，还能定义RSS，定义rel连接属性等作用；而@import是css提供的，只能用于加载css * link会同时被加载，而@inport引用的css会等到页面被加载完再加载； 简述一下对HTML语义化的理解 用正确的标签做正确的事。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式css情况下也以一种文档格式显示，并且容易阅读；搜索引擎的爬虫也依赖于HTML标记来确定上下文各个关键字的权重，利于SEO；使阅读源代码的人更容易将网站分块，便于阅读维护理解。 JS基本数据类型？Undefined、Null、Boolean、Number、String 数组去除重复数据1234567891011Array.prototype.method1 = function()&#123; var arr[]; //定义一个临时数组 for(var i = 0; i &lt; this.length; i++)&#123; //判断当前数组下标为i的元素是否已经保存到临时数组 //如果已保存，则跳过，否则将此元素保存到临时数组中 if(arr.indexOf(this[i]) == -1)&#123; arr.push(this[i]); &#125; &#125; return arr; &#125; callee与callercaller是返回一个对函数的引用，该函数调用了当前函数；callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 闭包问题123456789function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = function()&#123; return i; //由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5 &#125; //这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i， &#125; //当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5 return arr;&#125; 方案1123456789function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = (function(num)&#123; //自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数) return num; //这里的num写什么都可以 &#125;)(i); //这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i &#125; return arr;&#125; 方案2123456789101112function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = (function(num)&#123; //num在这里 //原理和上面一种方法一样的，所以可以实现闭包 return function()&#123; //在这个闭包里面再写一个匿名函数 return num; &#125;; &#125;)(i) &#125; return arr;&#125; 方案3123456789function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = function(num)&#123; return num; &#125;(i); &#125; return arr;&#125; JSaddEventListener最后一个参数规定事件是冒泡还是捕获。false是冒泡，true是捕获 冒泡类型blur focus change不可冒泡 判断类型 typeof返回一个表达式的数据类型的字符串，返回结果为js基本的数据类型，包括number,boolean,string,object,undefined,function.语法为typeof(data) 或 typeof data instanceof则为判断一个对象是否为某一数据类型，或一个变量是否为一个对象的实例;返回boolean类型语法为 o instanceof A alert(Object.prototype.toString.call([]) === ‘[object String]’) ——-&gt; true;类数组对象转化为数组Array.prototype.slice.call()；array方法join slice splice reverse sort foreach every等String方法concat charAt slice substr substring 等replace方法1.RegExp对象或者是字符串2.字符串或者函数 然后替换可以用正则进行全局替换apply/call区别函数声明和函数字面量的区别 CSS文本截取：text-overflow：ellipsis 算法（mark）优先队列堆快速排序 GET和POST的区别html状态码一些常见的状态代码为：200 - 服务器成功返回网页404 - 请求的网页不存在503 - 服务器暂时不可用1xx（临时响应）用于表示临时响应并需要请求者执行操作才能继续的状态代码。2xx（成功）用于表示服务器已成功处理了请求的状态代码。3xx（已重定向）要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。4xx（请求错误）这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。5xx（服务器错误）这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 事件侦听函数的区别IE使用:[Object].attachEvent(“name_of_event_handler”, fnHandler); //绑定函数[Object].detachEvent(“name_of_event_handler”, fnHandler); //移除绑定 DOM使用：[Object].addEventListener(“name_of_event”, fnHandler, bCapture); //绑定函数[Object].removeEventListener(“name_of_event”, fnHandler, bCapture); //移除绑定 HTML51、结构标签（1）section：独立内容区块，可以用h1~h6组成大纲，表示文档结构，也可以有章节、页眉、页脚或页眉的其他部分；（2）article：特殊独立区块，表示这篇页眉中的核心内容；（3）aside：标签内容之外与标签内容相关的辅助信息；（4）header：某个区块的头部信息/标题；（5）hgroup：头部信息/标题的补充内容；（6）footer：底部信息；（7）nav：导航条部分信息（8）figure：独立的单元，例如某个有图片与内容的新闻块。2、表单标签（1）email：必须输入邮件；（2）url：必须输入url地址；（3）number：必须输入数值；（4）range：必须输入一定范围内的数值；（5）Date Pickers：日期选择器；3、媒体标签（1）video：视频（2）audio：音频（3）embed：嵌入内容（包括各种媒体）4、其他功能标签（1）mark：标注（像荧光笔做笔记）（2）progress：进度条；（3）time：数据标签，给搜索引擎使用；发布日期（4）ruby和rt：对某一个字进行注释；（5）wbr：软换行，页面宽度到需要换行时换行；（6）canvas：使用JS代码做内容进行图像绘制；（7）command：按钮；（8）deteils ：展开菜单；（9）dateilst：文本域下拉提示；（10）keygen:加密； 垃圾回收引用计数，标记清除 ES6let,const,箭头函数，字符串模板，模块化，class Content-Type1.text/html2.text/plain3.text/css4.text/javascript5.application/x-www-form-urlencoded6.multipart/form-data7.application/json8.application/xmlapplication/x-www-form-urlencoded 表单发包方式，普通的表单提交，或者js发包multipart/form-data 用在发送文件的POST包。 块级格式化上下文浏览器渲染过程1.解析HTML文件，创建DOM树2.解析CSS3.将CSS与DOM合并，构建渲染树（renderingtree）4.布局和绘制，重绘（repaint）和重排（reflow） 前端性能优化请减少HTTP请求请减少对DOM的操作 使用JSON格式来进行数据交换 高效使用HTML标签和CSS样式 使用CDN加速（内容分发网络） 将CSS和JS放到外部文件中引用，CSS放头，JS放尾 精简CSS和JS文件 压缩图片和使用图片Sprite技术 CSS选择器http://www.w3school.com.cn/cssref/css_selectors.asp 浏览器缓存机制时间Etag304 创建对象 构造函数 12345678910function createPerson(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name);&#125;;&#125; var tanya =new createPerson("tanya","30","female"); tanya.sayName(); 原型模式 1234567891011function createPerson()&#123;&#125; createPerson.prototype.name = "tanya"; createPerson.prototype.age = "30"; createPerson.prototype.job = "female"; createPerson.prototype.sayName = function()&#123; alert(this.name);&#125;; var tanya =new createPerson(); tanya.sayName(); 垂直居中 table line-height padding absolute 算法十大经典算法快速排序基本数据结构和算法的前端实现基本数据结构和算法的前端实现 BFChttp://www.jianshu.com/p/66632298e355 深拷贝深拷贝]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式初始化]]></title>
    <url>%2F2017%2F05%2F21%2FCSS%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以前都是简单粗暴padding,margin=0,后来发现有一套专门的用来初始化CSS的东西，在此收集下 CSS样式初始化/移动端适配淘宝的CSS初始化123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; 移动端meta设置1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"/&gt; webkit中input的样式初始化12input,button,select,textarea&#123;outline:none&#125;textarea&#123;resize:none&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中this指向问题]]></title>
    <url>%2F2017%2F05%2F10%2Fbind-this%2F</url>
    <content type="text"><![CDATA[在使用settimeout和settimeinterval时使用this会导致this指向全局对象而出错，查询了一些资料 this的四种机制 函数中调用 默认绑定全局变量window，因为函数在全局作用域中被调用 12345var name="xl";function person()&#123; console.log(this.name);&#125;person(); //输出 xl 对象中的方法 obj.fn this指向当前对象 12345678var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl 构造函数中的this绑定 执行new时，构造函数中的this就被绑定到当前的新建实例中 12345678910function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl//上面代码没有进行new操作，相当于window对象调用Person("xl")方法，那么this指向window对象，并进行赋值操作window.name="xl".var personB=new Person("xl");console.log(personB.name);// 输出 xl 显式绑定 利用apply,call,bind的方法绑定this指向 ES6中的常用解决方法利用ES6中箭头函数1（）=&gt;&#123;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js钩子函数]]></title>
    <url>%2F2017%2F05%2F05%2FVue-js%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0Mounted%2F</url>
    <content type="text"><![CDATA[生命周期 Mountedmounted并不能保证能被选中#el中的dom元素已经生成，需设置settimeout进行获取dom操作。官方解决方案https://cn.vuejs.org/v2/guide/migration.html12345mounted: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; 路由切换后会触发destroy]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Curl获取教务系统数据]]></title>
    <url>%2F2017%2F04%2F18%2Fcurl%E8%8E%B7%E5%8F%96%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[5.30更新查询课程表需添加字段 $loginParams[&#39;TextBox1&#39;] = $password;查询成绩..还没搞定..不想搞了..反正这学期也差不多了妈的 一学期教务系统改好几次，有病啊 前言 获取验证码时需保存cookie，提交验证码时要一同提交 提交验证码时还需要获取网页内的_viewstate的值（据观察这个值是每天变化一次的） post所需要提交的字段 课程表 $loginParams[‘__VIEWSTATE’] = $getview[0]; $loginParams[‘txtUserName’] = $user; $loginParams[‘TextBox2’] = $password; $loginParams[‘txtSecretCode’] = $code; $loginParams[‘RadioButtonList1’] = ‘学生’; $loginParams[‘Button1’] = ‘’; $loginParams[‘lbLanguage’] = ‘’; $loginParams[‘hidPdrs’] = ‘’; $loginParams[‘hidsc’] = ‘’; 成绩 $logParams[‘__VIEWSTATE’] = $res[0]; $logParams[‘ddlXN’] =$xuenian; $logParams[‘ddlXQ’] =$xueqi; $logParams[‘Button1’] = “按学期查询”; $logParams[‘txtQSCJ’]=”0”; $logParams[‘txtZZCJ’]=”100”; 调用函数部分变量初始化123456$act='';$xuenian="";$xueqi="";$user = '';//用户名$password = '';//密码define('SCRIPT_ROOT',dirname(__FILE__).'/'); curl封装函数123456789101112131415161718192021222324252627282930function curl_request($url,$post='',$cookie='', $returnCookie=0)&#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)'); curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($curl, CURLOPT_AUTOREFERER, 1); curl_setopt($curl, CURLOPT_REFERER, "http://XXX"); if($post) &#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($post)); &#125; if($cookie) &#123; curl_setopt($curl, CURLOPT_COOKIE, $cookie); &#125; curl_setopt($curl, CURLOPT_HEADER, $returnCookie); curl_setopt($curl, CURLOPT_TIMEOUT, 10); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $data = curl_exec($curl); curl_close($curl); if($returnCookie)&#123; list($header, $body) = explode("\r\n\r\n", $data, 2); preg_match_all("/Set\-Cookie:([^;]*);/", $header, $matches); $info['cookie'] = substr($matches[1][0], 1); $info['content'] = $body; return $info; &#125;else&#123; return $data; &#125;&#125; 获取_viewstate函数12345678910function getView()&#123; $url = 'http://jwxt.jit.edu.cn/default2.aspx'; $result =curl_request($url); $pattern = '/&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" \/&gt;/is'; preg_match_all($pattern, $result, $matches); $res[0] = $matches[1][0]; // print_r($res); return $res;&#125; 获取验证码1showAuthcode('http://jwxt.jit.edu.cn/CheckCode.aspx'); 获取验证码图片12345678910111213141516function showAuthcode( $authcode_url )&#123; $cookieFile = SCRIPT_ROOT.'cookie.tmp'; $ch = curl_init($authcode_url); curl_setopt($ch,CURLOPT_COOKIEJAR, $cookieFile); // 把返回来的cookie信息保存在文件中 curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_REFERER, ''); curl_setopt($ch, CURLOPT_USERAGENT, 'Baiduspider'); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $content =curl_exec($ch); header('Content-type: image/jpeg'); print_r( $content); //var_dump($cookieFile); curl_close($ch);&#125; 读取课程表调用函数1234567891011121314151617181920212223 $getview=getView(); //执行获取viewstate// print_r($getview[0]); $user=trim($_REQUEST['username']); $password=trim($_REQUEST['password']); $code = trim($_REQUEST['code']); // $loginParams为curl模拟登录时post的参数 $loginParams['__VIEWSTATE'] = $getview[0]; $loginParams['txtUserName'] = $user; $loginParams['TextBox2'] = $password; $loginParams['txtSecretCode'] = $code; $loginParams['RadioButtonList1'] = '学生'; $loginParams['Button1'] = ''; $loginParams['lbLanguage'] = ''; $loginParams['hidPdrs'] = ''; $loginParams['hidsc'] = '';// $cookieFile 为加载验证码时保存的cookie文件名 $cookieFile = SCRIPT_ROOT.'cookie.tmp'; // $targetUrl curl 提交的目标地址 $targetUrl = 'http://jwxt.jit.edu.cn/default2.aspx'; // 参数重置 $content = curlLogin($targetUrl, $cookieFile, $loginParams); echo $content; break; 获取课程表函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function curlLogin($url, $cookieFile, $loginParams)&#123; global $user; global $password; $ch = curl_init($url); curl_setopt($ch,CURLOPT_COOKIEFILE, $cookieFile); //同时发送Cookie curl_setopt($ch,CURLOPT_RETURNTRANSFER, 1);//设定返回的数据是否自动显示 curl_setopt($ch, CURLOPT_HEADER, 0);//设定是否显示头信 息 curl_setopt($ch, CURLOPT_NOBODY, false);//设定是否输出页面 内容 curl_setopt($ch,CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch,CURLOPT_POSTFIELDS, $loginParams); //提交查询信息 curl_exec($ch);//返回结果 curl_close($ch); //关闭 $curl2=curl_init(); curl_setopt ($curl2,CURLOPT_REFERER,'http://jwxt.jit.edu.cn/xs_main.aspx?xh='.$user); curl_setopt($curl2, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl2, CURLOPT_HEADER, false); curl_setopt($curl2, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl2, CURLOPT_TIMEOUT, 20); curl_setopt($curl2, CURLOPT_AUTOREFERER, true); curl_setopt($curl2, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl2, CURLOPT_URL, 'http://jwxt.jit.edu.cn/xskbcx.aspx?xh='.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl2),'utf-8', array('Unicode','ASCII','GB2312','GBK','UTF-8')); //print_r($en_contents); preg_match_all('/&lt;span id="Label[^&gt;]*&gt;(.*)&lt;\/span&gt;/isU',$en_contents,$out); $student = explode('：', $out[1][6]); $studentInfo[0] = $student[1]; $student = explode('：', $out[1][5]); $studentInfo[1] = $student[1]; $student = explode('：', $out[1][2]); $studentInfo[2] = substr(trim($student[1]), 0,4);// var_dump($studentInfo); preg_match_all('/&lt;table id="Table1"[\w\W]*?&gt;([\w\W]*?)&lt;\/table&gt;/',$en_contents,$out); $table = $out[0][0];//检查 if($table=='')&#123; echo "&lt;script&gt;alert('是不是输错了啦QAQ');&lt;/script&gt;"; return; &#125; preg_match_all('/&lt;td [\w\W]*?&gt;([\w\W]*?)&lt;\/td&gt;/',$table,$out); $td = $out[1]; // print_r($table); $length = count($td); //获得课程列表 for ($i=0; $i &lt; $length; $i++) &#123; $td[$i] = str_replace("&lt;br&gt;", "", $td[$i]); $reg = "/&#123;(.*)&#125;/"; if (!preg_match_all($reg, $td[$i], $matches)) &#123; unset($td[$i]); &#125; &#125; $data = array_values($td); //将课程列表数组重新索引 $tdLength = count($td); //将课表转换成数组形式 for($i=0;$i&lt;count($data);$i++) &#123; $data[$i] = str_replace('（' , '(' , $data[$i]); $data[$i] = str_replace('）' , ')' , $data[$i]); preg_match_all('/(?!\d+$)[0-9A-z]&#123;4&#125;/', $data[$i], $classroom); if (count($classroom[0]) == 2) &#123; // var_dump($data[$i]); $match = preg_split("/&#123;$classroom[0][0]&#125;/", $data[$i],2); $match1=preg_split("/\)/", $match[1],2); $data[$i] = str_replace($match1[1] , '' , $data[$i]); array_push($data,$match1[1]); &#125; &#125; // var_dump($data);//var_dump($data); $teacher=''; for($i=0;$i&lt;count($data);$i++)&#123; $str =$data[$i]; preg_match_all('/(.*?)周(.*?)第/',$str,$subject); preg_match_all('/周(.*?)第/',$str,$day); preg_match_all('/第(.*?),(.*?)节/',$str,$time); preg_match_all('/\&#123;第(.*?)-(.*?)周\&#125;/',$str,$week); preg_match_all('/(?!\d+$)[0-9A-z]&#123;4&#125;/',$str,$classroom); $kcb[$i][0]=$subject[1][0]; $kcb[$i][1]=$day[1][0]; $kcb[$i][2]=$time[1][0]; $kcb[$i][3]=$time[2][0]; $kcb[$i][4]=$week[1][0]; $kcb[$i][5]=$week[2][0]; $kcb[$i][6]=$teacher; $kcb[$i][7]=$classroom[0][0]; &#125; $json_string = json_encode($kcb);// 写入文件file_put_contents('kcb.json', $json_string); // echo "&lt;pre&gt;"; //var_dump($kcb); curl_close($curl2); $url = "showkcb.php"; header("Location: $url");&#125; 读取成绩调用函数1234567891011121314151617181920212223242526$getview=getView(); // print_r($getview[0]); $user=trim($_REQUEST['username']); $password=trim($_REQUEST['password']); $code = trim($_REQUEST['code']); $xuenian=trim($_REQUEST['xuenian']); $xueqi=trim($_REQUEST['xueqi']); // $loginParams为curl模拟登录时post的参数 $loginParams['__VIEWSTATE'] = $getview[0]; $loginParams['txtUserName'] = $user; $loginParams['TextBox2'] = $password; $loginParams['txtSecretCode'] = $code; $loginParams['RadioButtonList1'] = '学生'; $loginParams['Button1'] = ''; $loginParams['lbLanguage'] = ''; $loginParams['hidPdrs'] = ''; $loginParams['hidsc'] = ''; // $cookieFile 为加载验证码时保存的cookie文件名 $cookieFile = SCRIPT_ROOT.'cookie.tmp'; // $targetUrl curl 提交的目标地址 $targetUrl = 'http://jwxt.jit.edu.cn/default2.aspx'; // 参数重置 $content = curlLogin1($targetUrl, $cookieFile, $loginParams); echo '学年'.$xuenian."学期".$xueqi; break; 查询成绩函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function curlLogin1($url, $cookieFile, $loginParams)&#123; global $xuenian; global $xueqi; global $user; global $password; // $user = $user;//用户名 $ch = curl_init($url); curl_setopt($ch,CURLOPT_COOKIEFILE, $cookieFile); //同时发送Cookie curl_setopt($ch,CURLOPT_RETURNTRANSFER, 1);//设定返回的数据是否自动显示 curl_setopt($ch, CURLOPT_HEADER, 0);//设定是否显示头信 息 curl_setopt($ch, CURLOPT_NOBODY, false);//设定是否输出页面 内容 curl_setopt($ch,CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch,CURLOPT_POSTFIELDS, $loginParams); //提交查询信息 curl_exec($ch);//返回结果 curl_close($ch); //关闭 $curl2=curl_init(); curl_setopt ($curl2,CURLOPT_REFERER,'http://jwxt.jit.edu.cn/xs_main.aspx?xh='.$user); curl_setopt($curl2, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl2, CURLOPT_HEADER, false); curl_setopt($curl2, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl2, CURLOPT_TIMEOUT, 20); curl_setopt($curl2, CURLOPT_AUTOREFERER, true); curl_setopt($curl2, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl2, CURLOPT_URL, 'http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh='.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl2),'utf-8', array('Unicode','ASCII','GB2312','GBK','UTF-8')); curl_close($curl2); //print_r($en_contents); $pattern = '/&lt;input type="hidden" name="__VIEWSTATE" value="(.*?)" \/&gt;/is'; preg_match_all($pattern, $en_contents, $matches); $res[0] = $matches[1][0]; // print_r($res); $logParams['__EVENTTARGET'] = ""; $logParams['__EVENTARGUMENT'] = ""; $logParams['__VIEWSTATE'] = $res[0]; $logParams['ddlxn'] =$xuenian; $logParams['ddlxq'] =$xueqi; $logParams['btnCx'] = " 查 询 "; $curl3=curl_init(); curl_setopt ($curl3,CURLOPT_REFERER,'http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh='.$user); curl_setopt($curl3, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl3, CURLOPT_HEADER, false); curl_setopt($curl3, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl3, CURLOPT_TIMEOUT, 20); curl_setopt($curl3, CURLOPT_AUTOREFERER, true); curl_setopt($curl3, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl3,CURLOPT_POSTFIELDS, $logParams); //提交查询信息 curl_setopt($curl3, CURLOPT_URL, 'http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh='.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl3),'utf-8', array('Unicode','ASCII','GB2312','GBK','UTF-8')); curl_close($curl3); preg_match_all('/&lt;table class="datelist"[\w\W]*?&gt;([\w\W]*?)&lt;\/table&gt;/',$en_contents,$xscj); $xscj1=$xscj[0][0];//检查 if($xscj1=='')&#123; echo "&lt;script&gt;alert('是不是输错了啦QAQ');&lt;/script&gt;"; return; &#125; preg_match_all('/&lt;tr[\w\W]*?&gt;([\w\W]*?)&lt;\/tr&gt;/',$xscj1,$xscj2); $json_string = json_encode($xscj2[0]);// 写入文件file_put_contents('cj.json', $json_string); //print_r($xscj1); $url = "showcj.php"; header( "Location: $url" );&#125; HTML表单部分123456789101112131415161718192021222324252627282930&lt;form role="form"&gt; &lt;input type="hidden" name="act" value="" id="hidden"&gt; &lt;span&gt;输入学号：&lt;/span&gt;&lt;input class ="form-control" type="text" name="username" /&gt;&lt;br&gt; &lt;span&gt;输入密码：&lt;/span&gt;&lt;input class ="form-control" type="password" name="password" /&gt;&lt;br&gt; &lt;iframe class="pull-right" src="?act=authcode" style='width: 100px; height:30px; overflow: hidden; display:block;' frameborder=0 &gt;&lt;/iframe&gt;&lt;br&gt; &lt;span&gt;输入验证码：&lt;/span&gt;&lt;input class ="form-control" type="text" name="code" /&gt;&lt;br&gt;&lt;br&gt; &lt;div style="margin:0 auto;width:100px"&gt; &lt;input class ="form-control btn btn-primary" id="sub1" type="submit" name="submit" value="查询课表"&gt;&lt;br&gt;&lt;br&gt; &lt;input class ="form-control btn btn-primary" type=button onclick="javascript:window.location.href='show1.php';" value="首页/刷新"&gt; &lt;/div&gt; &lt;/form&gt;&lt;script src="css/domain.js"&gt;&lt;/script&gt;&lt;script&gt; var hidden=document.getElementById("hidden"); var sub1=document.getElementById("sub1"); var sub2=document.getElementById("sub2"); sub1.onclick=function () &#123; hidden.value="login";&#125;; sub2.onclick=function () &#123; hidden.value="cxcj";&#125;; // hidden.value="cxcj"; // alert(hidden.value);&lt;/script&gt; 效果]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame基本用法]]></title>
    <url>%2F2017%2F04%2F15%2FrequestAnimationFrame%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[兼容性处理123456requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;; 基本使用123456789101112131415function animate() &#123; // Do whatever requestAnimationFrame(animate); // Do something animate &#125; //go-&gt; requestAnimationFrame(animate); requestAnimationFrame(function () &#123; // Do whatever requestAnimationFrame(animate); // Do something animate &#125;) 设定结束1234567891011var globalID; function animate() &#123; // Do whatever globalID=requestAnimationFrame(animate); // Do something animate &#125; //when ot start globalID=requestAnimationFrame(animate); //when to stop cancelAnimationFrame(globalID);]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas在移动端的缩放模糊问题]]></title>
    <url>%2F2017%2F04%2F10%2FCanvas%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%BC%A9%E6%94%BE%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于移动端的缩放问题Canvas的css宽与高会被缩放而Canvas画板本身不变，导致图形出现模糊获得缩放倍率123456789var canvas = document.getElementById("canvas"), context= canvas.getContext("2d"); // 屏幕的设备像素比 var devicePixelRatio = window.devicePixelRatio || 1; // 浏览器在渲染canvas之前存储画布信息的像素比 var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;// canvas的实际渲染倍率 var ratio = devicePixelRatio / backingStoreRatio; 设定height与width的值12canvas.width = canvas.width * ratio;canvas.height = canvas.height * ratio; https://sanwen8.cn/p/42bobOb.html]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端自适应CSS媒体查询]]></title>
    <url>%2F2017%2F04%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CSS自适应媒体查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@media only screen and (max-width: 1080px), only screen and (max-device-width:1080px) &#123; html,body &#123; font-size:16.875px; &#125; &#125; @media only screen and (max-width: 960px), only screen and (max-device-width:960px) &#123; html,body &#123; font-size:15px; &#125; &#125; @media only screen and (max-width: 800px), only screen and (max-device-width:800px) &#123; html,body &#123; font-size:12.5px; &#125; &#125; @media only screen and (max-width: 720px), only screen and (max-device-width:720px) &#123; html,body &#123; font-size:11.25px; &#125; &#125; @media only screen and (max-width: 640px), only screen and (max-device-width:640px) &#123; html,body &#123; font-size:10px; &#125; &#125; @media only screen and (max-width: 600px), only screen and (max-device-width:600px) &#123; html,body &#123; font-size:9.375px; &#125; &#125; @media only screen and (max-width: 540px), only screen and (max-device-width:540px) &#123; html,body &#123; font-size:8.4375px; &#125; &#125; @media only screen and (max-width: 480px), only screen and (max-device-width:480px) &#123; html,body &#123; font-size:7.5px; &#125; &#125; @media only screen and (max-width: 414px), only screen and (max-device-width:414px) &#123; html,body &#123; font-size:6.46875px; &#125; &#125; @media only screen and (max-width: 400px), only screen and (max-device-width:400px) &#123; html,body &#123; font-size:6.25px; &#125; &#125; @media only screen and (max-width: 375px), only screen and (max-device-width:375px) &#123; html,body &#123; font-size:5.859375px; &#125; &#125; @media only screen and (max-width: 360px), only screen and (max-device-width:360px) &#123; html,body &#123; font-size:5.625px; &#125; &#125; @media only screen and (max-width: 320px), only screen and (max-device-width:320px) &#123; html,body &#123; font-size:5px; &#125; &#125; @media only screen and (max-width: 240px), only screen and (max-device-width:240px) &#123; html,body &#123; font-size:3.75px; &#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS拖动函数]]></title>
    <url>%2F2017%2F03%2F20%2FJS%E6%8B%96%E5%8A%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JS的基本拖动函数123456789101112131415161718192021222324252627282930//HTML 结构：&lt;div id="box"&gt;&lt;/div&gt;//csc 样式：#box&#123;position: absolute;width: 200px;height: 200px;background: red;&#125;//jswindow.onload = function ()&#123; // 获取元素和初始值 var oBox = document.getElementById('box'), disX = 0, disY = 0; // 容器鼠标按下事件 oBox.onmousedown = function (e)&#123; var e = e || window.event; disX = e.clientX - this.offsetLeft; disY = e.clientY - this.offsetTop; document.onmousemove = function (e)&#123; var e = e || window.event; oBox.style.left = (e.clientX - disX) + 'px'; oBox.style.top = (e.clientY - disY) + 'px'; &#125;; document.onmouseup = function ()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;;&#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo deploy出错的问题]]></title>
    <url>%2F2017%2F03%2F11%2Fhexo-deploy%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布时出现 Deployer not found: git在终端执行命令：npm install hexo-deployer-git --save然后继续执行hexo deploye指令进行部署。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F10%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[这是搭建Hexo博客的第一天]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
</search>
