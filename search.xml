<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Turbowarp compiler]]></title>
    <url>%2F2021%2F12%2F12%2FTurbowarp-compiler%2F</url>
    <content type="text"><![CDATA[Turbowarp JIT 即时编译解析 Blocks AST -&gt; Blocks 中间码 -&gt; js闭包函数 https://www.notion.so/Turbowarp-compiler-509814e96eea4717bd00566142a0b470]]></content>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[comlink 原理]]></title>
    <url>%2F2021%2F12%2F10%2Fcomlink-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Comlink通过提供一个RPC实现，将这种基于消息的API变成了对开发者更友好的东西。一个线程的值可以在另一个线程中使用（反之亦然），就像本地值一样。 ScratchAddons 项目使用这个库，用于在chrome extension中同步 contentScript 与 pagescript 的数据。 https://www.notion.so/Comlink-d15ec2f02cf948a3b3cd2c02cca9d78e]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scratch-vm dispatch分析]]></title>
    <url>%2F2021%2F12%2F10%2Fscratch-vm-dispatch%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[dispatch 是什么 需要从scratch的插件的设计方案说起 官方设计了4类插件，Core以及Team分别是scratch默认的动作、外观等积木和扩展库中音乐、画笔等积木，offical 也许是指的写有合作者tag的插件（但是这些插件并非如列表中所描述的在sandbox中运行）。 我们要关注的是最后这一类 Unoffical, 这类仅提供了对sandbox 的支持。 https://www.notion.so/scratch-vm-dispatch-508cf50b5a1e4998b8604442446dd359]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Openwrt 折腾 Docker / Home-assistant / Coder-server]]></title>
    <url>%2F2021%2F08%2F12%2FOpenwrt%2F</url>
    <content type="text"><![CDATA[前些天升了一下软路由固件，更新了不少新功能，刚好有空折腾一下 Openwrt。 软路由配置: CPU： Intel(R) Celeron(R) CPU N2940 @ 1.83GHz : 4 Core 4 Thread SSD: 32G RAM: 2G 固件恩山论坛OPENWRT专版 扩容磁盘 用于 Docker 在op里点击 系统——磁盘管理——修改 之后进入这个界面。填入扩容的大小 格式化的时候，先确认要扩容的大小是否正确，正确的话就点击格式化，分区类型选择ext4，最后点击格式化 然后去挂载点页面，在系统——挂载点，将页面拉到底部位置，就能看到挂载点的设置 选择好uuid后，勾选启用此挂载点，在挂载点里面选择成作为Docker使用，然后点保存并应用。 重启软路由 挂载 NAS 目录 NFS 管理配置 2.NAS 文件夹设置 3.进入Openwrt /mnt/nfs/nas 即可访问 NAS 对应文件夹 Home assistant 接入 Openwrt 安装 luci-mod-rpc禁用 check_signature， 刷新软件列表，搜索并安装 修改 /opt/homeassistant/configuration.yaml(先安装HA， 见Dockr-之-HomeAssistant) device_tracker: - platform: luci host: ROUTER_IP_ADDRESS username: YOUR_ADMIN_USERNAME password: YOUR_ADMIN_PASSWORD https://www.home-assistant.io/integrations/luci/ 配置-服务-重启 Dockr 之 HomeAssistant参考官方文档： https://www.home-assistant.io/installation/linux#platform-installation 进入 /opt 新建目录 homeassistant 启动 Docker 之后进入容器 选择解析CLI docker run -d \--name homeassistant \--privileged \--restart=unless-stopped \-v /opt/homeassistant:/config \--network=host \ghcr.io/home-assistant/home-assistant:stable 网络选为 host 暴露所有端口 创建并启动 访问 [routerip]:8123 Dockr 之 Nodered参考官方文档： https://github.com/node-red/node-red-docker 进入 /opt 新建目录 node-red 启动 Docker 之后进入容器 选择解析CLI docker run \-p 1880:1880 -v /opt/node-red:/data \-u root \--name nodered nodered/node-red 网络选为 host 暴露所有端口 创建并启动 访问 [routerip]:1880 Dockr 之 Code Server web版vscode 实测 npm install 还能勉强使用， start 一个小项目路由器直接崩了 进入 /opt 新建目录结构 code-server- .conf- projects 启动 Docker 之后进入容器 选择解析CLI docker run -d --name code-server \-p 8080:8080 \-v &quot;/opt/code-server/.config:/home/coder/.config&quot; \-v &quot;/opt/code-server/projects:/home/coder/project&quot; \-u &quot;coder&quot; \-e &quot;DOCKER_USER=coder&quot; \codercom/code-server:latest 网络选为 host 暴露所有端口 创建并启动 访问 [routerip]:8080]]></content>
  </entry>
  <entry>
    <title><![CDATA[Scratch 插件编写完全指南]]></title>
    <url>%2F2021%2F07%2F01%2F%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[编写 Scratch 插件中一些不为人知的技巧 首先是一份官方的样例做一个简单的注释版本，更详细的见官方文档 LLK/scratch-vm const ArgumentType = require('../../extension-support/argument-type');const BlockType = require('../../extension-support/block-type');const TargetType = require('../../extension-support/target-type');// 用于国际化const formatMessage = require('format-message');class SomeBlocks &#123; constructor (runtime) &#123; // 可获取到 vm 的 runtime, 取得对舞台的控制 this.runtime = runtime; &#125; // 插件描述信息 getInfo () &#123; return &#123; // 插件唯一 id id: 'someBlocks', // 插件主副颜色 （block颜色以及可嵌入block部分的颜色） color1: '#FF8C1A', color2: '#DB6E00'， // 插件在gui加载后，菜单中显示的名称 GUI插件列表页名称在GUI中设置） name: formatMessage(&#123; id: 'extensionName', defaultMessage: 'Some Blocks', description: 'The name of the "Some Blocks" extension' &#125;), // 插件 block 显示的icon blockIconURI: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAAAAACyOJm3AAAAFklEQVQYV2P4DwMMEMgAI/+DEUIMBgAEWB7i7uidhAAAAABJRU5ErkJggg==', // 插件在GUI菜单中显示的icon menuIconURI: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAAAAACyOJm3AAAAFklEQVQYV2P4DwMMEMgAI/+DEUIMBgAEWB7i7uidhAAAAABJRU5ErkJggg==', // 这个文档属性好像还未启用 docsURI: 'https://....', // block 的定义 blocks: [ &#123; // 相当于 block 的 id，确定后尽量不要更改，否则导致旧项目无法加载对应block opcode: 'myReporter', // becomes 'someBlocks.myReporter' // 4种常用的积木类型 布尔/命令/帽子（事件）/返回值 BOOLEAN COMMAND HAT REPORTER blockType: BlockType.REPORTER, // 用于 BlockType.CONDITIONAL 不常用略过 branchCount: 0, // 中断运行 不常用略过 terminal: true, // 阻塞 不常用略过 blockAllThreads: false, // block 显示内容 包含 LETTER_NUM / TEXT 参数 text: formatMessage(&#123; id: 'myReporter', defaultMessage: 'letter [LETTER_NUM] of [TEXT]', description: 'Label on the "myReporter" block' &#125;), // 参数 类型/默认值 定义 arguments: &#123; LETTER_NUM: &#123; // 参数类型 // https://github.com/LLK/scratch-vm/blob/develop/src/extension-support/argument-type.js type: ArgumentType.NUMBER, // 默认值 default: 1 &#125;, TEXT: &#123; type: ArgumentType.STRING, default: formatMessage(&#123; id: 'myReporter.TEXT_default', defaultMessage: 'text', description: 'Default for "TEXT" argument of "someBlocks.myReporter"' &#125;) &#125; &#125;, // 同 opcode func: 'myReporter', // 可选 仅在 人物/舞台 显示 filter: [TargetType.SPRITE] &#125;, &#123; // Another block... &#125; ], // 插件的下拉菜单定义 menus: &#123; // 静态菜单 menuA: [ &#123; // selector item 的 value value: 'itemId1', // selector item 显示的文本 text: formatMessage(&#123; id: 'menuA_item1', defaultMessage: 'Item One', description: 'Label for item 1 of menu A in "Some Blocks" extension' &#125;) &#125;, // value / text 一致 'itemId2' ], // 动态 菜单， 用户点击菜单会实时调用 getItemsForMenuB 生成， 返回值结构同上 menuB: 'getItemsForMenuB', menuC: &#123; // 下拉菜单是否接受 reporter 作为输入 acceptReporters: true, // 接受上面两种形式菜单 items: [/*...*/] || 'getItemsForMenuC' &#125; &#125;, &#125;; &#125;; // 动态菜单 getItemsForMenuC (editingTargetId) &#123; // 动态菜单会接收到当前人物 TargetId return ['optional1', 'optional2'] &#125; // 点击 myReporter block 后调用的函数 // reporter 为带有返回值的函数 myReporter (args) &#123; console.log(args.TEXT, args.LETTER_NUM) // 其他业务 return 'success' &#125;;&#125; HAT 帽子积木 两种触发方式默认会无限循环 opcode 所指定的函数当返回值第一次为 true 时, 执行下面所连接 block // HAT block opcode: whenGetlet flag = falsewhenGet () &#123; // 如果 flag 持续为 true, 触发后需要改为 false if (flag) &#123; setTimeout(() =&gt; &#123; flag = false &#125;, 16) &#125; return flag&#125; 手动触发 HAThttps://github.com/LLK/scratch-vm/blob/develop/src/extension-support/extension-metadata.js HAT block 有一个配置项 isEdgeActivated 默认为 true， 设为 false 将不会后需要用户手动触发 // ... blocks 定义// opcode 对应函数func () &#123; // xxx // 如果满足 HAT 的触发条件 if (flag) &#123; this.runtime.startHats('extensionid_hatopcode', &#123; PARAM: 'txet' &#125;); &#125;&#125;// HAT block 对应函数 将不会执行hatopcode () &#123; return true;&#125; 积木块中插入图片 &#123; opcode: 'whenDetected', text: 'image [IMG]', blockType: BlockType.HAT, arguments: &#123; IMG: &#123; type: ArgumentType.IMAGE, dataURI: IntelinoImages.SnapIconWhite, alt: 'white' &#125; &#125; &#125;, COMMAND 积木的返回值 // COMMAND block functiondosth () &#123; // 点击积木块，下方会弹出提示 return '执行成功' // 同样也可用于 promise return Promise.reolve('执行成功')&#125; COMMAND 积木的同步等待执行// COMMAND block functiondosth () &#123; // 积木块会高亮一秒后执行后续积木 return Promise(resolve =&gt; setTimeout(resolve, 1000))&#125; 内置插件翻译const formatMessage = require('format-message');const extensionTranslations = &#123; 'zh-cn': &#123; 'messsageid': '翻译' &#125;&#125;class Ext &#123; constructor() &#123; this.setupTranslations() &#125; // 在插件初始化时调用， 合并翻译数据 setupTranslations () &#123; const localeSetup = formatMessage.setup(); if (localeSetup &amp;&amp; localeSetup.translations[localeSetup.locale]) &#123; Object.assign( localeSetup.translations[localeSetup.locale], // eslint-disable-next-line no-use-before-define extensionTranslations[localeSetup.locale] ); &#125; &#125;&#125; 积木调用函数的第二的参数第一个是 args, 传入的参数，第二个是 utils 一些工具方法 常用的有 target， 用于控制当前的人物 https://github.com/LLK/scratch-vm/blob/develop/src/engine/block-utility.js 插件中使用 video 信息（摄像头数据）常用于编写tensorflow插件 // 启用摄像头后可以获取video数据this.runtime.ioDevices.video.enableVideo().then(() =&gt; &#123; this.video = this.runtime.ioDevices.video.provider.video; // 获取当前帧 const frame = this.runtime.ioDevices.video.getFrame(&#123; format: Video.FORMAT_IMAGE_DATA, dimensions: Scratch3Pose.DIMENSIONS &#125;);&#125;); 可引入的工具函数// 转换 常用类型const Cast = require('../../util/cast');// 控制触发频率const RateLimiter = require('../../util/rateLimiter.js');const SendRateMax = 10;this._rateLimiter = new RateLimiter(SendRateMax);if (!this._rateLimiter.okayToSend()) return Promise.resolve(); 向舞台绘制图像叠层displayCtx2stage () &#123; const &#123;renderer&#125; = this.runtime; if (!renderer) return; if (!this._skinId &amp;&amp; !this._drawable) &#123; this._skinId = renderer.createBitmapSkin(new ImageData(480,360), 1); this._drawable = renderer.createDrawable('video'); renderer.updateDrawableProperties(this._drawable, &#123; skinId: this._skinId, // 设置该层透明度 ghost: 20 &#125;); &#125; if (!this._drawableCreate) &#123; renderer.updateDrawableProperties(this._drawable, &#123; visible: true &#125;); this._drawableCreate = true; &#125; // 准备好需绘制的数据 const imageData = myCanvas.getImageData(0, 0, 480, 360); renderer.updateBitmapSkin(this._skinId, imageData, 1); this.runtime.requestRedraw(); &#125; // 隐藏所绘制数据 stopDisplayCtx2stage () &#123; if (this._skinId !== undefined) &#123; this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(480， 360), 1); this.runtime.renderer.updateDrawableProperties(this._drawable, &#123;visible: false&#125;); &#125; this._renderPreviewFrame = null; &#125; Reporter 积木块 disableMonitorReporter 积木块有个 disableMonitor 配置，可以关闭前方的 checkbox 复用外围设备连接 UI（microbit 连接形式）classs Ext &#123; constructor (runtime) &#123; this._runtime = runtime; // 需要提前注册需要设备连接功能 this._runtime.registerPeripheralExtension('extid', this); &#125; // 点击扫描后 调用 scan () &#123; this._runtime.emit( this._runtime.constructor.PERIPHERAL_LIST_UPDATE, [&#123; name: 'deviceName', peripheralId: 'deviceID', rssi: -0 // 信号强度 &#125;] ) &#125; // 点击设备列表后调用 connect (id) &#123; // ... // 连接逻辑 // 连接成功 this.connected = true this._runtime.emit( this._runtime.constructor.PERIPHERAL_CONNECTED ); &#125; disconnect () &#123; // ... // 断开连接的逻辑 // 断开连接 this.connected = false this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED); &#125; reset () &#123; // 大概是断连业务 &#125; isConnected () &#123; return this.connected // 存储一个连接状态 &#125; getInfo () &#123; return &#123; //... // 显示插件菜单右上角的状态按钮 showStatusButton: true, blocks: [] &#125; &#125;&#125; 为角色增加形象addCostumeToTarget (args, util) &#123; const base64 = args.base64; const _storage = this.runtime.storage; const _runtime = this.runtime; const target = util.target; const BitmapAdapter = SvgRenderer.BitmapAdapter; const bitmapAdapter = new BitmapAdapter(); return bitmapAdapter .importBitmap(base64, 'image/png') .then(dataBuffer =&gt; &#123; const name = 'webcam 1'; const type = _storage.AssetType.ImageBitmap; const dataFormat = _storage.DataFormat.JPG; const asset = _storage.createAsset( type, dataFormat, dataBuffer, null, true ); const assetId = asset.assetId; const md5 = `$&#123;assetId&#125;.$&#123;dataFormat&#125;`; const costume = &#123;name, dataFormat, asset, md5, assetId&#125;; return loadCostume(md5, costume, _runtime); &#125;) .then(costume =&gt; &#123; target.addCostume(costume); // target.setCostume(target.getCostumes().length - 1); &#125;) .catch(e =&gt; &#123; console.log('importBitmap to costume'); console.log(e); return 'importBitmap to costume error'; &#125;); &#125;// 设为 index 作为形象setCostumeToTarget (args, util) &#123; const target = util.target; target.setCostume(args.index);&#125;// 删除形象deleteTargetCostume (args, util) &#123; const target = util.target; target.deleteCostume(args.index);&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[while (true) !== 阻塞]]></title>
    <url>%2F2021%2F04%2F07%2Fwhile-true-%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[while (true) &#123; // code&#125; 我还真没写过这样的代码，在看 ScratchAddons 源码的时候看到好些 addon 在 function 开头都有这样的代码。那这样不就死循环了么？ 场景addon 需要等待页面所需的 dom 加载完成后再执行，于是有了这样的代码。如果是我那应该就是用 observer 或 settimeout 去处理。 while (true)在 scratchAddon 这个框架下，官方插件都是使用框架 api 配合 while (true) 来确认元素的加载。 原理也很简单， 就是 async await 。 Demo: const getSomeThing = (() =&gt; &#123; let loadedFlag = false return () =&gt; &#123; return new Promise((resolve) =&gt; &#123; if (!loadedFlag) &#123; loadedFlag = true resolve('found') &#125; // 如果已经resolve过，则不再resolve &#125;) &#125;&#125;)();(async () =&gt; &#123; while (true) &#123; let someThing = await getSomeThing() console.log(someThing) &#125;&#125;)() 在 await 成功过一次之后，不再 resolve/reject，保持 Promise 的挂起状态，就可以绕过 while (true) 这个死循环了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Switch动画]]></title>
    <url>%2F2021%2F03%2F18%2FSwitch%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[昨天整了一下FLIP动画，今天用 React 实现一个 Vue 中常用的 v-if/v-else 动画 核心： 父组件识别并控制子组件的渲染时机，并赋予对应的 class/style，使得Dom切换动画无缝连接 CodeSandBox]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLIP动画]]></title>
    <url>%2F2021%2F03%2F17%2FFLIP%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[自从开始写React，就没怎么碰过动画的问题了 一是因为Vue内置了动画功能，只需要简单配置就能使用二是产品水平有限，连基本功能都设计不好也别提提高用户体验了 花了点时间跟着这篇博客走了一遍 核心： 重新排序(Last)后将元素置为未排序（First）时的位置（Invert），渲染下一帧时清除 style 使其归位（Play） CodeSandBox]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter项目在Github Actions中使用唯一签名打包 / Electron 打包]]></title>
    <url>%2F2020%2F11%2F06%2Fflutter-%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8-github-actions%2F</url>
    <content type="text"><![CDATA[最近学了下flutter相关的内容，在项目打包的时候发现一个问题，在不同的电脑以及github actions打包出来的apk,在安装到手机时，都会提示（使用adb命令安装可以看到log）package 签名不一致的问题，导致需要先卸载才能安装。 原因项目打包会使用到签名，不同的电脑、环境都会默认使用不同的debug签名导致每次打包出来的akp都不能直接升级安装。 使用环境 环境： MacOS keytool path: /Applications/Android\ Studio.app/Contents/jre/jdk/Contents/Home/jre/bin/keytool 官方文档参考：https://flutterchina.club/android-release/ 通过keytool创建一个签名，并且在项目配置中使用这个固定的签名，防止更换环境时签名的变化。 使用到的 keytool 工具目录写在上方了， Windows系统应该也在Androidstudio目录内。 缺陷创建的签名存在一个 password 的内容，这个配置文件在项目下是被gitignore的，如果更换电脑、环境打包这个文件又需要重新创建，所以干脆将这个打包流程在github actions中完成，实现自动发布。 与Github Actions集成参考： https://dev.to/cddelta/signing-flutter-android-apps-for-release-in-github-actions-2892 这篇文章在官方的文档基础上进行了兼容Github Actions打包的配置，按照文中所述，不出意外，不会出问题，我这边只是做一下复读机。 先不废话上项目实践 release.yml 自动打包多个abi的apk,并且输出web版本然后发布到release以及gh-page name: "pre-release"on: workflow_dispatch: inputs: description: description: 'Manual triggers' push: branches: [ main ]jobs: release-to-gitHub: name: release runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - uses: actions/setup-java@v1 with: java-version: '12.x' - run: echo $SIGNING_KEY | base64 -d &gt; android/app/key.jks env: SIGNING_KEY: $&#123;&#123; secrets.SIGNING_KEY &#125;&#125; - uses: subosito/flutter-action@v1 with: channel: beta - run: flutter config --enable-web - run: flutter pub get - run: flutter build apk --split-per-abi env: KEY_STORE_PASSWORD: $&#123;&#123; secrets.KEY_STORE_PASSWORD &#125;&#125; KEY_PASSWORD: $&#123;&#123; secrets.KEY_PASSWORD &#125;&#125; ALIAS: $&#123;&#123; secrets.ALIAS &#125;&#125; KEY_PATH: key.jks - run: flutter build web - run: zip -r web.zip ./build/web - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./build/web - uses: benjlevesque/short-sha@v1.1 id: short-sha with: length: 6 - run: echo $SHA env: SHA: $&#123;&#123; steps.short-sha.outputs.sha &#125;&#125; - uses: "marvinpinto/action-automatic-releases@latest" with: repo_token: "$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;" automatic_release_tag: "latest" prerelease: true title: "latest-develop" files: | build/app/outputs/flutter-apk/*.apk web.zip 由于存在 password 这块的配置，所以将这块相关的内容都通过Github actions的secrets形式配置为环境变量。 需要配置的就是 SIGNING_KEY KEY_STORE_PASSWORD KEY_PASSWORD ALIAS 后面三个就是官方文档中的storePassword、keyPassword、keyAlias， 一一对应配置好就行。 SIGNING_KEY 需要通过 openssl base64 -A -in &lt;location of the key store file, such as /Users/&lt;user name&gt;/key.jks&gt; 进行Base64化， 然后将数据填入 SIGNING_KEY , 这里注意base64结尾一般位数不够会补 「=」，如果复制的内容是以 「%」结尾,那就多余了，这应该是终端下文本内容结束的标示 更新 /android/app/gradle.build def keystoreProperties = new Properties()def keystorePropertiesFile = rootProject.file(&apos;key.properties&apos;)if (keystorePropertiesFile.exists()) &#123; keystoreProperties.load(new FileInputStream(keystorePropertiesFile))&#125; else &#123; keystoreProperties.setProperty(&apos;storePassword&apos;, System.getenv(&apos;KEY_STORE_PASSWORD&apos;)); keystoreProperties.setProperty(&apos;keyPassword&apos;, System.getenv(&apos;KEY_PASSWORD&apos;)); keystoreProperties.setProperty(&apos;keyAlias&apos;, System.getenv(&apos;ALIAS&apos;)); keystoreProperties.setProperty(&apos;storeFile&apos;, System.getenv(&apos;KEY_PATH&apos;));&#125; 如果这个签名的 password 忘记了这里有个验证密码的方法 keytool -list -keystore &lt;path/to/key.jks&gt; -storepass &lt;pwd&gt; 如果密码正确，会输出如下内容 密钥库类型: jks密钥库提供方: SUN您的密钥库包含 1 个条目key, 2020-9-11, PrivateKeyEntry,证书指纹 (SHA1): **********************Warning:JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore /Users/shenyu/key.jks -destkeystore /Users/shenyu/key.jks -deststoretype pkcs12" 迁移到行业标准格式 PKCS12。 如果你彻底忘了，那就重复一下官方文档的操作步骤喽。 Electron-builder其实之前还做过electron多平台的打包。方法也是类似。需要将 apple 证书输出base64文本存在网盘，将该地址作为环境变量。但是当时屁事太多，没能记录下来，一些细节问题也都忘了。这个坑先留着，下次出问题了我再记录一下。 需要签名的两个target是 win 的 appx 以及 mac 的 mas 自动发布electron-builder –publish always publish:- provider: github repo: projectname owner: user/org CI内增加 GH_TOKEN 环境变量，用于发布 release 参考: https://www.electron.build/code-signing.html#travis-appveyor-and-other-ci-servers https://github.com/LLK/scratch-desktop/blob/develop/scripts/electron-builder-wrapper.js https://github.com/TurboWarp/desktop/blob/master/package.json#L47]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个关于字符的玄学问题]]></title>
    <url>%2F2020%2F05%2F04%2F%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%9A%84%E7%8E%84%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[之前做了一个练习日文听力的网站 因为一些原因做了一下视频数据的迁移。 然后出现了一个玄学问题 明明是同一个url，但是视频却不一定能显示。 // return false why???? 手动黑人问号'ヤフーで「のりこえよう」と検索→医療従事者に寄付' ==='ヤフーで「のりこえよう」と検索→医療従事者に寄付' 你没看错，上面这两段文字显示是一样的，但扔到js里run 返回的是false 很明显，这里面的字符实际上是不同的，使用网上的字符对比工具 可以发现 「で」被高亮了。 然后使用中文转Unicode工具对比发现 第一个是 「\u3067」 而第二个是 「\u3066\u3099」。 这是什么原因呢 我查了下全角半角相关的问题 https://www.yoheim.net/blog.php?q=20191101 有点像是这个问题，但是这个是片假名的处理，而我这边是平假名。这个问题我搞了半天没搞懂，实在不懂这两者的差别是由于什么。 One hours later…… 在对比了几个不同的标题后发现了一个规律 这些4字节表现形式都是以 「\u3099」结尾的，然后就Google一下，很幸运，首页一片英文结果中出现了一个看起来相关的中文结果提到了这个关键字。 在 Unicode 中，同一个字符可能有多种不同的编码，比如日语中的浊音符号 \u3099（介绍），部分假名与这个字符组合可以生成假名的浊化形式，比如 タ(\u30bf) 加上 \u3099 就可以组成 ダ(\u30bf\u3099)。除了 4 字节的表示形式，ダ 还有一种 2 字节的表示形式 \u30c0。这两种模式，前者叫做 NFD，后者叫做 NFC。不仅仅是日语，其他带有浊音或者重音等发音变体形式的语言字符也存在这个问题。 大概是清楚了问题所在了，查找了一下js相关的转换方法。很令人惊讶，这是一个js的内置函数 str = str.normalize('NFD'); //标准转NFD非标准 也就是上面的 「\u3067」-&gt; 「\u3066\u3099」 就这样一行就解决了问题 有趣的是这个提issus的这个项目还是个乃木坂46相关的项目 小声说一句 西野七濑真可爱！ 好了，到此这个奇怪的问题也解决了。 要说原因的话，这个issus的作者也提到了 macOS 的 APFS 会将字符按照 NFD 模式显示，但是实际上存储时还是按照我原先下载文件时就设定好的 NFC 模式。然后在生成 pic.json 的时候，歌曲名是 shell 自动生成，再复制进 pic.json 的，因为 shell 显示的就是 NFD 模式，pic.json 自然而然地就也是 NFD 模式，Python 就无法将它与 NFC 模式的歌名匹配上了，cover 就会获取错误。 应该是这个OSS的本地客户端调用shell处理导致的，尚不清楚是不是仅限于MacOS。 然后呢 以后不要在饭前搞事情了 本来6点半打算去吃饭的，一顿操作，然后呢 现在晚上9点半了。算了 也算涨了点冷知识。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 大小写敏感问题]]></title>
    <url>%2F2020%2F03%2F10%2Fgit-%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[遇到一个非常智障的问题 git 默认小写不敏感！！！ 那么会发生什么恐怖的事情呢！！！ 二逼的遭遇创建文件夹时使用的驼峰写法，由于使用 docusaurus 框架，根据文件夹自动生成路由。 而后来改成了小写，但是没有git diff, git 仓库中仍然为驼峰写法。导致 ci 打包的路径也出了问题，但是本地开发时写的跳转地址都是 小写 的地址。于是 ci 打包发布后，部分跳转地址 404 。 我一度以为 我本地 build 和 ci 的 build 有什么区别导致的。研究了整整一下午，还研究了下 docker 中的 nginx 和 本地的 nginx， 甚至怀疑nginx 也出了问题。为什么我本地啥事没有，线上就爆炸！！！ 刚刚 晚上 突然发现是文件夹名称大小的原因。 解决首先当然是打开大小写敏感 git config core.ignorecase false 然后把文件/夹名改一下，然后git push 但是 git 线上仓库中出现了大小写两份的文件夹！！！！！！ 本地只有一份 咋办！！ 然后呢还有一步操作 git rm --cached src/dirName1 -rgit rm --cached src/dirName2 -r 这时候就有 git diff 了 然后 git add . 提交 大功告成 希望以后不要再这么二逼了！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[语法整理]]></title>
    <url>%2F2020%2F03%2F01%2F%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理最近看书不太记得的语法 语法整理《日语基础写作》 河野保博 助词的使用「で」と「を」の間違い 人・ものが通る場所 ＋ 「を」 おお通りを歩く 公園の中を走る 飛行機が空を飛ぶ 人・ものが離れる場所 ＋「を」 １０時にうちを出る 船が港を離れる 来年大学を卒業する 訪ねる 訪れる 訪問する 村の歴史をよく知っている老人を訪ねる 友人のお見舞いで病院を訪れる 先生の研究室を訪問する 「を」と「に」の間違い 表达对对方的意见/想法 「に」 部長に賛成する その先生は女子学生にやさしい 情感迅速变化的原因 「に」 先生の言葉に安心する まずいご飯にがっかりする 长久持续性的情感 日本の生活を楽しむ 娘の帰りを心配する 细微差别 恋に落ちる 彼女に恋する 彼女を愛する 「を」と「が」の間違い 感觉的对象 / 情感 / 评价 + が 私は頭が痛い 娘は目が痒いらしい 彼女は料理が上手だ ドイツ人はビールが好きだ 表示希望可能的对象 が・を 息子は携帯電話「が・を」欲しいようだ 私は水「が・を」飲みたい 漢字「が・を」読める人が増えるだろう 复合助词「によって」 用于表原因、受身动作主体 自身によって多くの家が倒壊した （原因） 寺は太子によって建てられた （受身） 「にとれば・によると」 表达所得情报 天気予報による。。。 「は」と「が」の間違いが 表示背景（未知情报） は 表示主题（已知情报） 昔々、なになにがなになに。なになにはなになに。 （先交代背景，后引出主题） が 连接（すぐ後ろの）之后的述語 は 连接（遠く）之后的述語 日本は 日本人 が 思っているほど 狭い 国ではない は 表示对比 兄は背が高い、弟は背が低い 短语使用的区分「そう」の使うかた１ 伝聞 普通形 ＋ そうだ 天気予報によると、明日は雪になるそうだ ２ 様態 ます形・い・な ＋ そうだ 間も無く雪になりそうだ 彼女はとてもうれしそうだ 元気そうだ 「なくて」と「ないで」なくて 原因・理由を表わす 旅行に行きなくて困った ないで 前のことをしない状態で後ろのことをするとき 窓を閉めないで寝る 文末表现１ 「と思う」と「と思っている」 ⑴ と思う 表达自己的思考 ⑵ と思っている ① 强调与以前不同的「现在」 以前はなになにと思っている、今はなになにと思っている ② 强调从以前延续至今 日本に来てからパソコンが買いたいとずっと思っている ③ 他人的想法 みんなは彼が犯人だと思っている ２ 「と思う」「と思われる」 「と思える」 ⑴ と思う 主观性强 ⑵ と思われる 客观性强 说服力最强（如被认为犯法） ⑶ と思える 叙述个人想法，语气显弱 ⑷ という・と言っている 非本人所说 / と言える 本人所说 指示词 こ・そ・あ１ 「あ」 文章中一般不出现 ２ 「こ」 ⑴ 指示后面的内容 友人にこんな話が聞いた。（話し言葉） ⑵ 「今」・「ここ」・「わたし」と関係あるとき この時間 この国 この経験 ⑶ 指示后文（远）内容/总结上文内容 このように こうして ２ 「そ」 ⑴ 指示 指示词的 一部分 「トルコ進行曲」という曲を書いた作曲家がいる。その作曲家はモーツアルト。 （指示前句主题中的部分内容） ⑵ 接续词 それから そして ⑶ 同主语时，对前文内容的附加 对用于意外的情况 妹は子供の頃恥ずかしがり屋で、人前に出ると真っ赤になって下に向いていた。その妹は今女優になっている。 ⑷ 指示不明确的内容 わたしは今一番やりたいことがあって、それは自転車で日本全国を回ることです。 敬语《日本语》 金田一春彦 てやる・てあげる・て差し上げる てくれる・てくださる てもらう・ていただく 与益者 自己/他人 他人 主语之外 受益者 他人 自己 主语 敬语 一般 いかが どう さよう そう いたす する 参る 行き・来る 申す いう 存ずる 思う・知る ござる ある]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录工作时遇到的一些问题。 https://www.notion.so/Notes-bf3f3571674a4b71a6ad48663f6ac17a 创建自定义事件 https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events var event = new Event('build');// Listen for the event.elem.addEventListener('build', function (e) &#123; ... &#125;, false);// Dispatch the event.elem.dispatchEvent(event); 判断字符串起始String.prototype.startsWith()String.prototype.endsWith()// 均可传入第二个参数表示起始位置 简单的任务队列this.queue = Promise.resolve(true);addQueue(job) &#123; this.queue = this.queue.then(job) .catch((e) =&gt; &#123; console.error(e); &#125;); return this.queue;&#125;// 将Promise任务添加至队列，确保上个任务完成后执行该任务 package.json 私有包处理"project": "git+ssh://git@github.com/&lt;username&gt;/&lt;proejct&gt;#&lt;branch/commit&gt;", 安装mecabbrew install mecab//安装字典$ tar zxfv mecab-ipadic-2.7.0-XXXX.tar.gz$ cd mecab-ipadic-2.7.0-XXXX$ ./configure --with-charset=utf8$ make$ sudo make install flex 子元素无法设置为 position stickyflex 默认 子元素为 strech 设置该子元素 align-self: flex-start; useEffect / useLayoutEffect 区别https://juejin.im/post/5de38c76e51d455f9b335eff 文本一行时 居中对齐， 多行时左对齐&lt;div&gt; // 父元素设置 text-align center &lt;p&gt;text&lt;/p&gt; // display inline-block ; text-align left&lt;/div&gt; React、Vue 事件 异步方法使用事件 （合成事件）// https://zh-hans.reactjs.org/docs/events.htmlonClick=(e) =&gt; &#123; let event = e // 需要赋值 promise().then(res =&gt; console.log(e))&#125; 对象扩展 条件赋值&#123; foo: &apos;a&apos;, ...(true ? &#123;boo: &apos;b&apos;&#125; : null)&#125; React 报无限 looponClick=&#123;fun()&#125; React Hook 翻页const [current, setCurrent] = useState(1)useEffect(() =&gt; &#123; cb &amp;&amp; cb(current)&#125;, [current])onClick=&#123;() =&gt; setCurrent(prev =&gt; ++prev)&#125; React Hook 倒计时useEffect 形成闭包，使用 Ref 存储上次time 或使用 time 作为监听值 触发timeout 成为 interval 来使用 字符问题转为 Unicode, 可能带有换行 或者特殊字符 ，使用 normalize 转换 ? / ?? 的使用a?.b?.c = &apos;xxx&apos; React Hook 异步引用 state根本原因 Hook 是向函数中传入函数，形成闭包。 所记录的的函数创建时的引用值，而无法获取更新后（内存地址变化）的值，导致运行异常。 使用 useRef 获得一个，引用类型的变量记录值的变化即可。 之前遇到的一个问题： // stateA stateBconst initCallBack = useCallback(() =&gt; &#123; // do sth&#125;, [stateA, stateB])// pageAuseEffect(() =&gt; &#123; api().then(initCallBack)&#125; [initCallBack])// pageBuseEffect(() =&gt; &#123; api().then(initCallBack)&#125; [initCallBack]) 有2个页面有会在载入时进行init， 后调用 initCallback 会根据 state 状态跳出，防止重复 init。 但是打log可以发现还是重复init了。 原因还是在于异步调用，虽然 dep 是注册了 initcallback 的变化，但是在执行异步方法中所使用的并不是更新后的 callback，从而使用了错误的 init 状态，导致多次 init。 解决办法是在记录 init state 的同时，使用ref或普通变量去记录且用于判断init状态即可。 drag apidom 元素在 drag end 时，默认会有一个元素恢复原位的一个动画。 // https://stackoverflow.com/questions/32206010/disable-animation-for-drag-and-drop-chrome-safaridom.onDragOver = (e) =&gt; e.preventDefault() drag api 兼容桌面端与移动端不兼容，js只有桌面端（鼠标输入）形式的 drag api. 移动端可使用 https://github.com/timruffles/mobile-drag-drop 做兼容 在既有鼠标输入又有触摸输入的设备（可触屏的win10），无法使用触摸拖拽 自定义 font 顺序加载使用自定义字体时,如果使用的是外部资源，会出现文字由默认字体到目标字体闪烁变化的问题 // https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face@font-face &#123; src: url(data:application/octet-stream;base64,xxxx)&#125; 字体文件转为 base64 保证加载顺序 或者 &lt;link rel="preload" href="https://fonts.woff2" as="font" crossorigin="anonymous"/&gt; IOS 视频不显示封面IOS设备默认不显示 video 封面有一个有意思的方法 // https://muffinman.io/blog/hack-for-ios-safari-to-display-html-video-thumbnail/&lt;video&gt; &lt;source src="path-to-video.mp4#t=0.001" type="video/mp4" /&gt;&lt;/video&gt; IOS 文件下载IOS中文件下载,js创建的a标签需要append到body中，不然是下载不了的！！ safari 浏览器 url hash 设置有节流限制出现在使用某个md标题插件，记录当前的位置，过多触发 set url hash, 导致该功能被限制在 30s/次 webpack 打包时记录版本信息// webpack configconst GitRevisionPlugin = require('git-revision-webpack-plugin')const gitRevisionPlugin = new GitRevisionPlugin()const LoadCommitDate = gitprocess .execSync('git log -1 --date=format:"%Y/%m/%d %H:%M:%S" --format="%ad"') .toString()// 也可以用 dayjs 二次处理// 后来也想 直接用 new Date() 记录CI打包的时间不过想想意义不太大。export default &#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env.VERSION': JSON.stringify(gitRevisionPlugin.version()), 'process.env.COMMITDATE': JSON.stringify(LoadCommitDate) &#125;) ]&#125; 复合组件// https://github.com/penouc/blog/issues/7// 调用React的顶层api React.Children 获取child, 处理 Child props。&lt;Stepper.Steps&gt; &lt;Stepper.Step num=&#123;1&#125; text=&#123;"Stage 1"&#125;/&gt; &lt;Stepper.Step num=&#123;2&#125; text=&#123;"Stage 2"&#125;/&gt; &lt;Stepper.Step num=&#123;3&#125; text=&#123;"Stage 3"&#125;/&gt; &lt;Stepper.Step num=&#123;4&#125; text=&#123;"Stage 4"&#125;/&gt;&lt;/Stepper.Steps&gt; 组件数据 部分解耦// 传入children为函数即可， children 渲染，部分依赖父组件，部分依赖该组件内部数据const CustomComponent = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &#123;this.children(data)&#125; &lt;/div&gt;)&#125;&lt;CustomComponent&gt; &#123;(internalProps) =&gt; &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;&lt;/CustomComponent&gt; before / after 伪元素input 没有伪元素！！！ PWA 更新// https://create-react-app.dev/docs/making-a-progressive-web-app/ This means that users will end up seeing older content until they close (reloading is not enough) their existing, open tabs. See this blog post for more details about this behavior. 在资源更新的事件触发后，需要关闭tab，再重新打开才能确保资源成功更新 一种有意思设置默认参数形式当时也不知道怎么想的， 写个这个挺高效的传参方式 const getEvents = (&#123;page_num&#125;=&#123;&#125;) =&gt; instance.get(`/messages`, &#123; params: &#123;page_size: 10, page_num: 1, ...params&#125;&#125;) Typescript 联合类型断言data.forEach(item =&gt; &#123; if (item.topic.startsWith('things/')) &#123; item = item as TYPEA &#125; else if (item.topic.startsWith('scenes/')) &#123; item = item as TYPEB &#125; &#125;) react function children适合我这样的懒人 // array children 需要一个 key 哦 &lt;div className="content"&gt; &#123;(() =&gt; &#123; lists.length &gt; 5 &amp;&amp; (lists[4] = &lt;i key="icon-more" className="iconfont icon-more"/&gt;) return &lt;&gt;&#123;lists.slice(0, 5)&#125;&lt;/&gt; &#125;)()&#125;&lt;/div&gt; webthing 设备卡片 UI 模板的设计第一版考虑到数据与模板尽量解耦 useBaseThing 可以单独使用，用于注册事件等不需要 UI 参与的业务， const useBaseThing = (thingDesc) =&gt; &#123; // propertes state // model ref // action callback // model event update state return &#123; propertes, model, action &#125;&#125;const ThingTemplate = (&#123;propertes, model, action, children&#125;) =&gt; &#123; return ( &lt;div&gt; thing xxxxxx &lt;div&gt;&#123;propertes&#125;&lt;/div&gt; &lt;button onclick=&#123;action&#125;&gt;action&lt;/button&gt; &#123;children&#125; &lt;/div&gt; )&#125;// 一个基本的 thing UIconst data = useBaseThing(thingDesc)return (&lt;ThingTemplate &#123;...data&#125;&gt; &lt;div&gt;自定义icon等&lt;/div&gt;&lt;/ThingTemplate&gt;) 第二版第一版虽然完全分离， 但是有个问题，要使用模板就必然要先 useBaseThing 获取数据 所以考虑重构，将模板创建整合进 useBaseThing 同时一个 thing UI 中，需要自定义的部分需要包含更多的内容，如二级对话框、图标、触发按钮等，还要考虑到后期的扩展性，仅留下一个 ThingTemplate children 作为自定义元素就远远不够了。 const useBaseThing = (&#123; thingDesc, templateConfig: &#123; CustomTemplateA, CustomTemplateB, CustomTemplateC &#125;&#125;) =&gt; &#123; // propertes state // model ref // action callback // model event update state return &#123; propertes, model, action, baseThing: &lt;ThingTemplate customTemplateA=&#123;&lt;CustomTemplateA propertes=&#123;propertes&#125;/&gt;&#125; customTemplateB=&#123;&lt;CustomTemplateB propertes=&#123;propertes&#125;/&gt;&#125; customTemplateC=&#123;&lt;CustomTemplateC propertes=&#123;propertes&#125;/&gt;&#125; /&gt; &#125;&#125;const ThingTemplate = (&#123; propertes, model, action, customTemplateA, customTemplateB, customTemplateC&#125;) =&gt; &#123; return ( &lt;div&gt; thing xxxxxx &lt;div&gt;&#123;propertes&#125;&lt;/div&gt; &lt;button onclick=&#123;action&#125;&gt;action&lt;/button&gt; &#123;customTemplateA&#125; &#123;customTemplateB&#125; &#123;customTemplateC&#125; &lt;/div&gt; )&#125;// 创建一个基本的 thing UI// 这里最好配合 typescript 增加类型提示const CustomTemplateA = (data) =&gt; &lt;&gt;&lt;/&gt;const CustomTemplateB = (data) =&gt; &lt;&gt;&lt;/&gt;const CustomTemplateC = (data) =&gt; &lt;&gt;&lt;/&gt;const &#123;baseThing&#125; = useBaseThing(&#123;thingDesc, templateConfig: &#123; CustomTemplateA, CustomTemplateB, CustomTemplateC &#125;&#125;)return baseThing // thing JSX.Element// 创建一个无 UI thingconst &#123;modal&#125; = useBaseThing(&#123;thingDesc&#125;)modal.on('event', () =&gt; &#123;&#125;) thing UI 也通过 useBaseThing 创建，可以根据 templateConfig，设置 UI 是否创建 第三版目前实际开发下来第二版在扩展性上基本没有什么问题，但感觉还是有一些繁琐了 要说有问题，就是 ThingTemplate 是在 useBaseThing 内部创建，内部的插槽模板是写在外部，传入 useBaseThing， 写起来有一点违和 但是这些 Component 都是依赖 useBaseThing 内部的 state 数据，又没有办法，只能在这个上下文创建。 也许应该还有更加高效的组合方式 input 输入法问题https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart https://juejin.cn/post/6844903950634713096 text input onchange 事件获取的 value，会包含输入法输入的内容 使用 onCompositionStart 记录当前是否为输入法状态，控制onchange执行 react v17https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing 组件卸载时 useEffect 的 return 会异步执行，也就是在完全卸载后执行，dom元素事件监听的卸载需要在useLayoutEffect处理 总结就是 useEffect -&gt; 加载 -&gt; useLayoutEffect -&gt; useLayoutEffect -&gt; 卸载 -&gt; useEffect Electron index.html 加载本地（static）静态 js旧版本可以这么用 &lt;script src="./static/xxx.js"&gt;&lt;/script&gt; 后来为了适配CI升了下版本，过不了打包流程，只能使用一个歪门邪道处理 &lt;script id="syncload"&gt; function loadScriptAsync(url) &#123; var head = document.getElementsByTagName("head")[0]; var s = document.createElement("script"); s.src = url; let referenceNode = document.querySelector('script#syncload') referenceNode.parentNode.insertBefore(s, referenceNode.nextSibling); &#125; loadScriptAsync('./static/xxx.js')&lt;/script&gt; 屏幕 / Canvs录制https://developer.mozilla.org/zh-CN/docs/Web/API/MediaRecorder https://developer.mozilla.org/zh-CN/docs/Web/API/Screen_Capture_API/Using_Screen_Capture 元素滚动检测 APIIntersectionObserver createDocumentFragment可以理解为 React 中的 Fragment, 一个无父节点的元素 https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 Webpack 记录版本 pluginhttps://github.com/LLK/scratch-www/blob/develop/webpack.config.js#L31 网页水印https://www.zhangxinxu.com/wordpress/2020/10/text-as-css-background-image/ 使用文本 svg 作为元素背景 可以实现类似 before/after 伪元素的效果 网页自动检测黑暗模式 使用 CSS 媒体查询可以解决 @media (prefers-color-scheme: dark) &#123; .day.dark-scheme &#123; background: #333; color: white; &#125; .night.dark-scheme &#123; background: black; color: #ddd; &#125; html &#123; filter: invert(1) hue-rotate(.5turn); &#125;&#125;@media (prefers-color-scheme: light) &#123; .day.light-scheme &#123; background: white; color: #555; &#125; .night.light-scheme &#123; background: #eee; color: black; &#125;&#125; https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme https://www.zhangxinxu.com/wordpress/2020/11/css-mix-blend-mode-filter-dark-theme/ 使用 JSwindow.matchMedia(“(prefers-color-scheme: dark)”).matches; Module not found: Error: Can’t resolve ‘fs’处理一些包 在Web中使用的出错webpack config:```JSON&#123; node: &#123; fs: &apos;empty&apos; &#125;&#125;// Webpack &gt;= 5module.exports = &#123; ... resolve: &#123; fallback: &#123; &quot;fs&quot;: false &#125;, &#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
</search>
