<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[while (true) !== 阻塞]]></title>
    <url>%2F2021%2F04%2F07%2Fwhile-true-%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[while (true) &#123; // code&#125; 我还真没写过这样的代码，在看 ScratchAddons 源码的时候看到好些 addon 在 function 开头都有这样的代码。那这样不就死循环了么？ 场景addon 需要等待页面所需的 dom 加载完成后再执行，于是有了这样的代码。如果是我那应该就是用 observer 或 settimeout 去处理。 while (true)在 scratchAddon 这个框架下，官方插件都是使用框架 api 配合 while (true) 来确认元素的加载。 原理也很简单， 就是 async await 。 Demo: const getSomeThing = (() =&gt; &#123; let loadedFlag = false return () =&gt; &#123; return new Promise((resolve) =&gt; &#123; if (!loadedFlag) &#123; loadedFlag = true resolve('found') &#125; // 如果已经resolve过，则不再resolve &#125;) &#125;&#125;)();(async () =&gt; &#123; while (true) &#123; let someThing = await getSomeThing() console.log(someThing) &#125;&#125;)() 在 await 成功过一次之后，不再 resolve/reject，保持 Promise 的挂起状态，就可以绕过 while (true) 这个死循环了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Switch动画]]></title>
    <url>%2F2021%2F03%2F18%2FSwitch%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[昨天整了一下FLIP动画，今天用 React 实现一个 Vue 中常用的 v-if/v-else 动画 核心： 父组件识别并控制子组件的渲染时机，并赋予对应的 class/style，使得Dom切换动画无缝连接 CodeSandBox]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLIP动画]]></title>
    <url>%2F2021%2F03%2F17%2FFLIP%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[自从开始写React，就没怎么碰过动画的问题了 一是因为Vue内置了动画功能，只需要简单配置就能使用二是产品水平有限，连基本功能都设计不好也别提提高用户体验了 花了点时间跟着这篇博客走了一遍 核心： 重新排序(Last)后将元素置为未排序（First）时的位置（Invert），渲染下一帧时清除 style 使其归位（Play） CodeSandBox]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[太甜了太甜了]]></title>
    <url>%2F2021%2F03%2F15%2F%E5%A4%AA%E7%94%9C%E4%BA%86%E5%A4%AA%E7%94%9C%E4%BA%86%2F</url>
    <content type="text"><![CDATA[ikura真是太可爱了 也太优秀了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter项目在Github Actions中使用唯一签名打包 / Electron 打包]]></title>
    <url>%2F2020%2F11%2F06%2Fflutter-%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8-github-actions%2F</url>
    <content type="text"><![CDATA[最近学了下flutter相关的内容，在项目打包的时候发现一个问题，在不同的电脑以及github actions打包出来的apk,在安装到手机时，都会提示（使用adb命令安装可以看到log）package 签名不一致的问题，导致需要先卸载才能安装。 原因项目打包会使用到签名，不同的电脑、环境都会默认使用不同的debug签名导致每次打包出来的akp都不能直接升级安装。 使用环境 环境： MacOS keytool path: /Applications/Android\ Studio.app/Contents/jre/jdk/Contents/Home/jre/bin/keytool 官方文档参考：https://flutterchina.club/android-release/ 通过keytool创建一个签名，并且在项目配置中使用这个固定的签名，防止更换环境时签名的变化。 使用到的 keytool 工具目录写在上方了， Windows系统应该也在Androidstudio目录内。 缺陷创建的签名存在一个 password 的内容，这个配置文件在项目下是被gitignore的，如果更换电脑、环境打包这个文件又需要重新创建，所以干脆将这个打包流程在github actions中完成，实现自动发布。 与Github Actions集成参考： https://dev.to/cddelta/signing-flutter-android-apps-for-release-in-github-actions-2892 这篇文章在官方的文档基础上进行了兼容Github Actions打包的配置，按照文中所述，不出意外，不会出问题，我这边只是做一下复读机。 先不废话上项目实践 release.yml 自动打包多个abi的apk,并且输出web版本然后发布到release以及gh-page name: "pre-release"on: workflow_dispatch: inputs: description: description: 'Manual triggers' push: branches: [ main ]jobs: release-to-gitHub: name: release runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - uses: actions/setup-java@v1 with: java-version: '12.x' - run: echo $SIGNING_KEY | base64 -d &gt; android/app/key.jks env: SIGNING_KEY: $&#123;&#123; secrets.SIGNING_KEY &#125;&#125; - uses: subosito/flutter-action@v1 with: channel: beta - run: flutter config --enable-web - run: flutter pub get - run: flutter build apk --split-per-abi env: KEY_STORE_PASSWORD: $&#123;&#123; secrets.KEY_STORE_PASSWORD &#125;&#125; KEY_PASSWORD: $&#123;&#123; secrets.KEY_PASSWORD &#125;&#125; ALIAS: $&#123;&#123; secrets.ALIAS &#125;&#125; KEY_PATH: key.jks - run: flutter build web - run: zip -r web.zip ./build/web - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./build/web - uses: benjlevesque/short-sha@v1.1 id: short-sha with: length: 6 - run: echo $SHA env: SHA: $&#123;&#123; steps.short-sha.outputs.sha &#125;&#125; - uses: "marvinpinto/action-automatic-releases@latest" with: repo_token: "$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;" automatic_release_tag: "latest" prerelease: true title: "latest-develop" files: | build/app/outputs/flutter-apk/*.apk web.zip 由于存在 password 这块的配置，所以将这块相关的内容都通过Github actions的secrets形式配置为环境变量。 需要配置的就是 SIGNING_KEY KEY_STORE_PASSWORD KEY_PASSWORD ALIAS 后面三个就是官方文档中的storePassword、keyPassword、keyAlias， 一一对应配置好就行。 SIGNING_KEY 需要通过 openssl base64 -A -in &lt;location of the key store file, such as /Users/&lt;user name&gt;/key.jks&gt; 进行Base64化， 然后将数据填入 SIGNING_KEY , 这里注意base64结尾一般位数不够会补 「=」，如果复制的内容是以 「%」结尾,那就多余了，这应该是终端下文本内容结束的标示 更新 /android/app/gradle.build def keystoreProperties = new Properties()def keystorePropertiesFile = rootProject.file(&apos;key.properties&apos;)if (keystorePropertiesFile.exists()) &#123; keystoreProperties.load(new FileInputStream(keystorePropertiesFile))&#125; else &#123; keystoreProperties.setProperty(&apos;storePassword&apos;, System.getenv(&apos;KEY_STORE_PASSWORD&apos;)); keystoreProperties.setProperty(&apos;keyPassword&apos;, System.getenv(&apos;KEY_PASSWORD&apos;)); keystoreProperties.setProperty(&apos;keyAlias&apos;, System.getenv(&apos;ALIAS&apos;)); keystoreProperties.setProperty(&apos;storeFile&apos;, System.getenv(&apos;KEY_PATH&apos;));&#125; 如果这个签名的 password 忘记了这里有个验证密码的方法 keytool -list -keystore &lt;path/to/key.jks&gt; -storepass &lt;pwd&gt; 如果密码正确，会输出如下内容 密钥库类型: jks密钥库提供方: SUN您的密钥库包含 1 个条目key, 2020-9-11, PrivateKeyEntry,证书指纹 (SHA1): **********************Warning:JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore /Users/shenyu/key.jks -destkeystore /Users/shenyu/key.jks -deststoretype pkcs12" 迁移到行业标准格式 PKCS12。 如果你彻底忘了，那就重复一下官方文档的操作步骤喽。 Electron-builder其实之前还做过electron多平台的打包。方法也是类似。需要将 apple 证书输出base64文本存在网盘，将该地址作为环境变量。但是当时屁事太多，没能记录下来，一些细节问题也都忘了。这个坑先留着，下次出问题了我再记录一下。 需要签名的两个target是 win 的 appx 以及 mac 的 mas 自动发布electron-builder –publish always publish:- provider: github repo: projectname owner: user/org CI内增加 GH_TOKEN 环境变量，用于发布 release 参考: https://www.electron.build/code-signing.html#travis-appveyor-and-other-ci-servers https://github.com/LLK/scratch-desktop/blob/develop/scripts/electron-builder-wrapper.js https://github.com/TurboWarp/desktop/blob/master/package.json#L47]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个关于字符的玄学问题]]></title>
    <url>%2F2020%2F05%2F04%2F%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%9A%84%E7%8E%84%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[之前做了一个练习日文听力的网站 因为一些原因做了一下视频数据的迁移。 然后出现了一个玄学问题 明明是同一个url，但是视频却不一定能显示。 // return false why???? 手动黑人问号'ヤフーで「のりこえよう」と検索→医療従事者に寄付' ==='ヤフーで「のりこえよう」と検索→医療従事者に寄付' 你没看错，上面这两段文字显示是一样的，但扔到js里run 返回的是false 很明显，这里面的字符实际上是不同的，使用网上的字符对比工具 可以发现 「で」被高亮了。 然后使用中文转Unicode工具对比发现 第一个是 「\u3067」 而第二个是 「\u3066\u3099」。 这是什么原因呢 我查了下全角半角相关的问题 https://www.yoheim.net/blog.php?q=20191101 有点像是这个问题，但是这个是片假名的处理，而我这边是平假名。这个问题我搞了半天没搞懂，实在不懂这两者的差别是由于什么。 One hours later…… 在对比了几个不同的标题后发现了一个规律 这些4字节表现形式都是以 「\u3099」结尾的，然后就Google一下，很幸运，首页一片英文结果中出现了一个看起来相关的中文结果提到了这个关键字。 在 Unicode 中，同一个字符可能有多种不同的编码，比如日语中的浊音符号 \u3099（介绍），部分假名与这个字符组合可以生成假名的浊化形式，比如 タ(\u30bf) 加上 \u3099 就可以组成 ダ(\u30bf\u3099)。除了 4 字节的表示形式，ダ 还有一种 2 字节的表示形式 \u30c0。这两种模式，前者叫做 NFD，后者叫做 NFC。不仅仅是日语，其他带有浊音或者重音等发音变体形式的语言字符也存在这个问题。 大概是清楚了问题所在了，查找了一下js相关的转换方法。很令人惊讶，这是一个js的内置函数 str = str.normalize('NFD'); //标准转NFD非标准 也就是上面的 「\u3067」-&gt; 「\u3066\u3099」 就这样一行就解决了问题 有趣的是这个提issus的这个项目还是个乃木坂46相关的项目 小声说一句 西野七濑真可爱！ 好了，到此这个奇怪的问题也解决了。 要说原因的话，这个issus的作者也提到了 macOS 的 APFS 会将字符按照 NFD 模式显示，但是实际上存储时还是按照我原先下载文件时就设定好的 NFC 模式。然后在生成 pic.json 的时候，歌曲名是 shell 自动生成，再复制进 pic.json 的，因为 shell 显示的就是 NFD 模式，pic.json 自然而然地就也是 NFD 模式，Python 就无法将它与 NFC 模式的歌名匹配上了，cover 就会获取错误。 应该是这个OSS的本地客户端调用shell处理导致的，尚不清楚是不是仅限于MacOS。 然后呢 以后不要在饭前搞事情了 本来6点半打算去吃饭的，一顿操作，然后呢 现在晚上9点半了。算了 也算涨了点冷知识。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 大小写敏感问题]]></title>
    <url>%2F2020%2F03%2F10%2Fgit-%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[遇到一个非常智障的问题 git 默认小写不敏感！！！ 那么会发生什么恐怖的事情呢！！！ 二逼的遭遇创建文件夹时使用的驼峰写法，由于使用 docusaurus 框架，根据文件夹自动生成路由。 而后来改成了小写，但是没有git diff, git 仓库中仍然为驼峰写法。导致 ci 打包的路径也出了问题，但是本地开发时写的跳转地址都是 小写 的地址。于是 ci 打包发布后，部分跳转地址 404 。 我一度以为 我本地 build 和 ci 的 build 有什么区别导致的。研究了整整一下午，还研究了下 docker 中的 nginx 和 本地的 nginx， 甚至怀疑nginx 也出了问题。为什么我本地啥事没有，线上就爆炸！！！ 刚刚 晚上 突然发现是文件夹名称大小的原因。 解决首先当然是打开大小写敏感 git config core.ignorecase false 然后把文件/夹名改一下，然后git push 但是 git 线上仓库中出现了大小写两份的文件夹！！！！！！ 本地只有一份 咋办！！ 然后呢还有一步操作 git rm --cached src/dirName1 -rgit rm --cached src/dirName2 -r 这时候就有 git diff 了 然后 git add . 提交 大功告成 希望以后不要再这么二逼了！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[语法整理]]></title>
    <url>%2F2020%2F03%2F01%2F%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理最近看书不太记得的语法 语法整理《日语基础写作》 河野保博 助词的使用「で」と「を」の間違い 人・ものが通る場所 ＋ 「を」 おお通りを歩く 公園の中を走る 飛行機が空を飛ぶ 人・ものが離れる場所 ＋「を」 １０時にうちを出る 船が港を離れる 来年大学を卒業する 訪ねる 訪れる 訪問する 村の歴史をよく知っている老人を訪ねる 友人のお見舞いで病院を訪れる 先生の研究室を訪問する 「を」と「に」の間違い 表达对对方的意见/想法 「に」 部長に賛成する その先生は女子学生にやさしい 情感迅速变化的原因 「に」 先生の言葉に安心する まずいご飯にがっかりする 长久持续性的情感 日本の生活を楽しむ 娘の帰りを心配する 细微差别 恋に落ちる 彼女に恋する 彼女を愛する 「を」と「が」の間違い 感觉的对象 / 情感 / 评价 + が 私は頭が痛い 娘は目が痒いらしい 彼女は料理が上手だ ドイツ人はビールが好きだ 表示希望可能的对象 が・を 息子は携帯電話「が・を」欲しいようだ 私は水「が・を」飲みたい 漢字「が・を」読める人が増えるだろう 复合助词「によって」 用于表原因、受身动作主体 自身によって多くの家が倒壊した （原因） 寺は太子によって建てられた （受身） 「にとれば・によると」 表达所得情报 天気予報による。。。 「は」と「が」の間違いが 表示背景（未知情报） は 表示主题（已知情报） 昔々、なになにがなになに。なになにはなになに。 （先交代背景，后引出主题） が 连接（すぐ後ろの）之后的述語 は 连接（遠く）之后的述語 日本は 日本人 が 思っているほど 狭い 国ではない は 表示对比 兄は背が高い、弟は背が低い 短语使用的区分「そう」の使うかた１ 伝聞 普通形 ＋ そうだ 天気予報によると、明日は雪になるそうだ ２ 様態 ます形・い・な ＋ そうだ 間も無く雪になりそうだ 彼女はとてもうれしそうだ 元気そうだ 「なくて」と「ないで」なくて 原因・理由を表わす 旅行に行きなくて困った ないで 前のことをしない状態で後ろのことをするとき 窓を閉めないで寝る 文末表现１ 「と思う」と「と思っている」 ⑴ と思う 表达自己的思考 ⑵ と思っている ① 强调与以前不同的「现在」 以前はなになにと思っている、今はなになにと思っている ② 强调从以前延续至今 日本に来てからパソコンが買いたいとずっと思っている ③ 他人的想法 みんなは彼が犯人だと思っている ２ 「と思う」「と思われる」 「と思える」 ⑴ と思う 主观性强 ⑵ と思われる 客观性强 说服力最强（如被认为犯法） ⑶ と思える 叙述个人想法，语气显弱 ⑷ という・と言っている 非本人所说 / と言える 本人所说 指示词 こ・そ・あ１ 「あ」 文章中一般不出现 ２ 「こ」 ⑴ 指示后面的内容 友人にこんな話が聞いた。（話し言葉） ⑵ 「今」・「ここ」・「わたし」と関係あるとき この時間 この国 この経験 ⑶ 指示后文（远）内容/总结上文内容 このように こうして ２ 「そ」 ⑴ 指示 指示词的 一部分 「トルコ進行曲」という曲を書いた作曲家がいる。その作曲家はモーツアルト。 （指示前句主题中的部分内容） ⑵ 接续词 それから そして ⑶ 同主语时，对前文内容的附加 对用于意外的情况 妹は子供の頃恥ずかしがり屋で、人前に出ると真っ赤になって下に向いていた。その妹は今女優になっている。 ⑷ 指示不明确的内容 わたしは今一番やりたいことがあって、それは自転車で日本全国を回ることです。 敬语《日本语》 金田一春彦 てやる・てあげる・て差し上げる てくれる・てくださる てもらう・ていただく 与益者 自己/他人 他人 主语之外 受益者 他人 自己 主语 敬语 一般 いかが どう さよう そう いたす する 参る 行き・来る 申す いう 存ずる 思う・知る ござる ある]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早稲田大学よさこいチーム東京花火]]></title>
    <url>%2F2020%2F01%2F27%2F%E6%9D%B1%E4%BA%AC%E8%8A%B1%E7%81%AB%2F</url>
    <content type="text"><![CDATA[多灾多难的2020年1月份还有4天才过去。 这个月唯一幸运的应该是不小心发现这个团体吧 早稲田大学よさこいチーム東京花火 早稲田大学よさこいチーム東京花火团队简介这是一支由早稻田大学学生组成的约150人的高知系表演团体。以扇子、鸣子等作为主要表现形式的演舞团队。主要活跃于よさこい『夜來祭』等庆典。 目前来看各地的夜來祭都会参与。 湘南、原宿、东京、神户…… 特点 小姐姐超可爱 小姐姐超可爱 小姐姐超可爱 小哥哥也好看 别人家的大学 服装日系风格相当华丽 音乐也超棒 酷暑下以舞蹈形式 行进于街道20min以上！！！ この動画見て「美しいなぁ」より「うらやましい」を感じる（Youtube某评论） Youtube频道 https://www.youtube.com/user/tokyohanabi4351new https://www.youtube.com/user/MrChariotto30 https://www.youtube.com/user/TeamRANMAN 部分视频 前往哔哩哔哩 下面的需过一下墙 twitter https://twitter.com/tokyohanabi4351 夜來祭昭和29年時, 在大戰後經濟蕭條之際由高知縣工商會議所為代表, 為達到經濟復甦・振興地區的目的在南國土佐高知誕生了夜來祭。爾後, 大約歷經了50年至今, 藉著深受夜來祭充滿獨特韻味卻又充滿能量的魅力的人們在日本四處各地推廣出去。 鳴子夜來祭中不可缺少的樂器就是鳴子。原本, 鳴子是吊掛在田地中, 藉由聲音來趕走麻雀等的道具。傳統的模樣是朱紅色的木製本體上繫著黑色以及黃色的響板, 但是現今大部分都為了配合隊伍的服裝而改變顏色以及材質甚至是外觀形狀來使用。 最后现已加入未来🇯🇵旅行计划 资料参考 https://www.super-yosakoi.tokyo/tc/ http://www.tokyohanabi.com/]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[危険なビーナス 危险的维纳斯]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%8D%B1%E9%99%BA%E3%81%AA%E3%83%93%E3%83%BC%E3%83%8A%E3%82%B9%2F</url>
    <content type="text"><![CDATA[首先这是本烂书（当时在日本书店的畅销书那堆随手买的）。看完后查了下豆瓣，可怜的6.1分。 本以为是本有趣的书，至少前3/4，但最后犯人的动机实在让人蛋疼。东野圭吾虽然看的不是很多但也不少了，写得这么油腻的还真是第一次。他已经不是那个写《白夜行》的东野圭吾了。 看了大半个月，每天晚上啃一点，最后就当复习单词了。另外还知道了个冷知识 蛇的交尾。 这是真的油腻书中各种对于女性身材、穿着等描写，以及各种大胆的想法。所以说，渡边淳一的《男人这东西》说的一点都没错。如果男主不用下半身思考问题也就没有这本书了。 经常读着读着就是 ↓↓↓↓（各种色气场景的描写 略过几百字）我的内心os: 哇！我有个大胆的想法。作者: 真巧，我也有个大胆的想法。小伙子！快上车！ 作为一本悬疑小说，这是在太影响阅读了。我不想开车啊，放我下车啊。还好作者没把车门给焊死。 然后就是学到了很多关于女性穿着的名词，还行吧，这车开的不亏。 简介男主-一名兽医，某天突然一个声称其弟弟妻子的女性找到男主。希望与男主协力寻找不知下落的老公。在这过程中，牵扯出了一系列鲜为人知的家族秘密。 虽说是弟弟，但实际上是同母异父。亲生父亲是个不知名的画家，继父则是有背景的医生。继父曾经的研究方向是通过对大脑的刺激，来激发人的潜能。然而这项研究的最初对象就是曾经的亲生父亲，因而留下了一幅常人无法完成的画作，后来死于实验产生的并发症。于是医生作为偿罪，与男主母亲二婚，并将实验数据交与母亲。母亲于十多年前一次意外中去世。 继父即将离世，找来家族的人商谈遗产的处理。而这时男主弟弟却消失了。考虑到估计与遗产相关。男主就与弟媳在处理遗产纷争的同时，查找弟弟的下落。男主这边的遗产主要是亲生父母的遗物。特别是父亲留下的鲜为人知的那副绝世画作以及那份被认为掩藏的实验数据。在寻找线索时，确意外发现母亲并非死于非命，也许是他人为了争夺与继父实验相关的资料。 男主与弟媳妇儿去老家寻找线索，确意外碰到了自己的叔叔。原来是自己的叔叔也在觊觎这笔财产。叔叔过去就与男主父亲交好，坚信父亲的那幅画能够解决世界性的数学难题。于是不择手段，于十多年前失手杀害了男主母亲。而现在既然没能找到画作他打算与这间屋子同归于尽。大火起，府警至。最终纷纷被带离现场。 男主弟弟确意想不到的出现在了警察局。他向男主坦白，因为有人（叔叔）在网上匿名悬赏拘禁自己，于是警方在保护他的同时，也在调查这位嫌疑人。而警方的行动就是安插了这位弟媳…………… 人生如戏，全靠演技。开车开得飞起，甚至希望弟弟已经不在人世，而来照顾这位颇有姿色的未亡人的美梦化成泡影。而这位警察小姐姐也是假戏真做，各种暧昧。 唉，心累累。这不是我想上的车。差评。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用typescript]]></title>
    <url>%2F2019%2F10%2F12%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8typescript%2F</url>
    <content type="text"><![CDATA[尝试使用typescript写vue项目，遇到了一些坑 每次遇到问题后，总是后悔为什么当初脑残要用ts 然后解决后，写着写着又觉得真香 😭…. vuex中state定义给对象属性分配数据类型的时候，需要分模块定义每个属性的类型 第三方库的types定义@types中不存在该包许多第三方库并没有相应的类型定义，需要建立 xxx.d.ts 文件定义模块 // echats.d.tsdeclare module 'vue-echarts' &#123; const ECharts: any export default ECharts&#125; @types中存在该包比如lodash yarn add lodash @types/lodash // main.ts 中全局引入import lodash from 'lodash'Vue.prototype['$_'] = lodash // lodash.d.tsimport Vue from 'vue'import lodash from 'lodash'declare module 'vue/types/vue' &#123; interface Vue &#123; $_: typeof lodash &#125;&#125; 引入js文件一些常用函数的js文件，直接改ts,否则用js引入又要报没有类型定义的错误 vue-router中的大坑组件内的路由守卫不能触发 解决办法: 需要路由守卫的组件使用 vue-class-componen 代替 vue-property-decorator 组件结构 import Component from 'vue-class-component'Component.registerHooks([ 'beforeRouteEnter', 'beforeRouteUpdate', 'beforeRouteLeave'])@Component(&#123; components: &#123; Background &#125;&#125;)export default class Home extends Vue &#123; beforeRouteEnter (to: Route, from: Route, next: Function) &#123; console.log('beforeRouteEnter') next() &#125;&#125; 网上能查到 在main文件中引入 Component 并 Component.registerHooks 的方法，但尝试后并不能生效，写在组件内部可行 遇到问题继续更新 つづく 好好写好各个类型定义，typescript还是挺香的]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天気の子]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%A4%A9%E6%B0%97%E3%81%AE%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我只是想吐槽一下这本书 什么鬼剧情啊国庆节我竟然花了两天看这破书！！希望电影版能靠谱一点。 天气之子跑去日本，并没能买到《声之形》，外面人多到爆炸，国庆节就看书度日了。 以后又多了一个不回家的理由，就是买不起回去的机票…. 大概内容 （含剧透）男主 帆高女主 陽菜 男主由于与父亲发生矛盾，独自从岛上离家出走来到东京。 来到东京后发现，仅仅带着3w日元完全无法生存下去，想打工也因为未成年没人要，想靠脸吃饭又长得一般般~ 于是找到了来东京途中，船上认识的一个公司老板。老板是个大好人，看到男主可怜把他收留了下来，但是干一些很不靠谱的工作。 在这工作中，因为日本阴雨连绵，在为“晴れ女”（能够让天空放晴的女孩）这个话题，进行相关素材收集。恰巧认识到了“晴れ女”本尊，就是天气之子的女主。 然后男主出个馊主意主意，可以靠这个赚钱呀，别人在网上提出希望放晴的申请，他们跑去做祈祷，让天空放晴。而且不存在成本，还能得到好评。简直一本万利。 某一天，男主发现女主快过生日了，打算干完最后一单，就买个戒指向女主表白。 在干完最后一单后。男主终于发现了事情的严重性。女主作为上天的人柱，在每次祈祷放晴后，身体都会变得透明，直至消失。 男主想要挽回的时候发现已经来不及了。于是跑到天台，向上天祈求，只要女主能回来，管它天放不放晴呢。 然后日本的雨就没有停过………… 男主回去上学，两年后毕业了，来到东京，找到女友，看着这被水淹的差不多东京，安慰道“没事的，没事的”，然后过上了没羞没臊的生活……………………………… wtf 浓缩版 男主为了💰 ，让天气之子の女友“出卖身体”（想稳赚不赔怎么可能呢） 女友即将消失之际，发出了“我来赚钱养你”的无能怒吼最后为了拯救女友，把🌞 干掉了…… 结局就是两年后的再会，他哭着对女友说了句“僕たち、大丈夫だ” 吐糟哇，你们俩能不能为别人考虑下啊，天天下雨啊，还活不活了，内裤都干不了的啊，人家农村的靠天吃饭不都饿死了啊。 女主还是挺好的，那么小就带着弟弟挑起了生活的重担，后来一直都是照顾着男主，在男主不在的两年，虽然已经不是人柱了，但还是每天面带泪水地为放晴而作祈祷。 心疼。 总结 男主就是个废物 何以解忧，唯有暴富]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还是画画]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%BF%98%E6%98%AF%E7%94%BB%E7%94%BB%2F</url>
    <content type="text"><![CDATA[这几天收拾东西，准备搬家，翻出了快长草的数位板。 之前有点想一出是一出，绕了一大圈，最后觉得还是画画好玩。 就像做视频，还有吉他，虽然觉得这辈子都和这些无缘了。 即使虐我千百遍，还是会充满着热情。 临摹(emmm…就是对着描的)]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[犬夜叉-inuyasha]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%8A%AC%E5%A4%9C%E5%8F%89-inuyasha%2F</url>
    <content type="text"><![CDATA[昨天刚好补完完结篇。 京アニ也这天走了33个人，还有好些重伤的。一直在刷相关的新闻，看的想哭。不知道负责过犬夜叉的京アニ作画监督还在不在了。 不知道那些制作过声之形、冰菓的那些人还在不在了。声之形的小说还没买呢，以后可能看不到这样的作品了。 如果不是这场灾难，都无法想象这些热爱动漫而善良的人就是在这样一座三层小楼里面创作出感动世界的作品。 天佑京阿尼。 前几天正好看到了这个穿越时空的思念，突然好想二刷犬夜叉呀! 随便找了张顺眼的图，要是会画画就好啦。 神乐真可怜，临走前看到杀生丸最后一眼。 我是风，是自由的风。 顺手截图.rmvb_20190704_224952.157.jpg) つづく]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[いたいのいたいの、飛んでゆけ - 不哭不哭，痛痛飞走]]></title>
    <url>%2F2019%2F06%2F09%2F%E3%81%84%E3%81%9F%E3%81%84%E3%81%AE%E3%81%84%E3%81%9F%E3%81%84%E3%81%AE%E3%80%81%E9%A3%9B%E3%82%93%E3%81%A7%E3%82%86%E3%81%91%2F</url>
    <content type="text"><![CDATA[本当に何もかもが嫌になったら、その時は言ってくれ。僕が、君を殺してあげよう。如果这世间的一切，你都那么讨厌的话，就帮你去另一个世界吧。 いたいのいたいの、飛んでゆけ 。 当时在买《我想吃掉你的胰脏》（4月）的时候看到了这本书，觉得书名有些似曾相识，就顺便下单了。然后上个月断断续续的在看这本书，中间还看了些其他的书，或者说上个月真是糟心了，然后终于在这个端午节结束了这本书。 不知道是不是错觉，好像在深田恭子演的某部剧中出现过这句话。 在这本书中一共出现了两次，一次是男主是作为一个消极厌世的废柴，在安慰受伤的女主时说出的这句话。还一次是男女主在互相坦白了隐藏的面具下的自己之后，男主在内心独白中说出的这句话。第一次，我的内心毫无波动，甚至想笑，但第二次时差点没控制住自己的眼泪。 本来只是因为书名看起来很治愈，但打开书时，封面确是男女主浑身沾满鲜血走在万圣节的大街游行中。看到2/3左右，我甚至想弃了这本书，因为他和我想象的不一样呀。 17岁那年，男主因为父亲工作变动而转校，临走时意外结识了一个同班女生，于是决定交个朋友，并且通过书信沟通。一段时间后，女主提出“网恋奔现”，但实际上男主为了尊严，在书信中美化了自己，于是冷处理这这个请求。5年之后，在死党的建议下，主动约女生出来。很可惜，男主借酒消愁，放飞自我，开车时撞到了一个女孩，而女孩却有着能够短暂推迟“不愉快事件”的发生的能力，于是女主临时活了下来。男主作为补偿，需要帮助女主在这短暂的时间里完成她的复仇之路，男主则作为最后一个复仇对象。 于是后面的内容充满大量的血腥、暴力。在完成了15个仇人之后，终于轮到了男主自己，然而女主却心软了，主动离开了男主。而此时，男主才逐渐意识到这一切的不合理性，女主也许就是当年的那个同学。在找到女主后，男主向女主坦白真实的自己，作为一个社会底层的废物，那时的他实在无法去见女主。不久后随着女主消失，男主在一次睡梦中，恢复了另一段记忆。下面就是另一条时间线的事情了。 5年前，也就是转校的那一年，在女主提出见面的提议后，男主实际上是同意了这个请求。同样的，男主早早的就坦白了面具下的自己。然后就是一段正常的交往日常。但好景不长，女主因为父母离异，继父的家暴，同学的霸凌之后，男主也渐渐意识到了这个女孩饱受着身心摧残。在一次家暴事件中，发生了无法挽回的事情，男主为了保护女主，杀了女主的继父，而后两人若无其事的去游乐园坐过山车时发生意外，失去了男主。女主认为这一切都是都是因为自己。于是将这一切推迟了。 在这5年中，女主内心确期待着与男主的重逢，也许就是命运，然后就发生了5年后复仇的事。男主恢复了5年前的记忆后，两人又来到了那个游乐场，既然女主车祸死亡的推迟即将解除，那么随着女主的离开，5年前的那次推迟也将解除。于是，两人在游乐场的旋转木马上静静等待着死亡的审判。 我觉得可以电影化一下呀，就是前段剧情可能很压抑，但这个结局还是很日式的算是goodend吧 end 作者后记 本当に何もかもが嫌になったら、その時は言ってくれ。僕が、君を殺してあげよう。如果这世间的一切，你都那么讨厌的话，就帮你去另一个世界吧。 当时看到这句话，我愣了一下，也许那种情况下，一切安慰都是徒劳吧。 很多人想过死，但又因为怕疼。也许这是最好的答案？]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[君のすい臓を食べたい]]></title>
    <url>%2F2019%2F04%2F29%2F%E4%BA%BA%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%B4%BB%E7%9D%80-%E6%88%91%E6%83%B3%E5%90%83%E6%8E%89%E4%BD%A0%E7%9A%84%E8%83%B0%E8%84%8F%2F</url>
    <content type="text"><![CDATA[一个是习惯了孤独的男主，与周围没有任何的社交，书才是他最终归宿。为自己而活着。 一个是社交狂，每天都乐观阳光，外人看来是那么完美。为他人而活着。 就是这样两个性格完全相反的两个人，或许正是因为性格相反吧，发现互相为对方而活着也挺好呀。 简单来说就是这样一个的故事，但是结局意料之中吧，还是令人略感惋惜。（日本的作品大多应该都是good end的呀！！） 故事是很简单，但是男女主背后的故事却一点都不简单。准确的说是女主。（男主这个比就像我一样，或者如同five，在别人看来不太正常，但实际上就俩字“真实”）。 女主得了癌症。除了男主，这个活得足够真实的人知道这件事外还有父母，其他人并不知道了。 然后呢，从各个不同的人角度来看待一下这件事：真相揭露之前 不明真相的同学们： 女主这么优秀，为什么会和那个five男混在一起。 被女主甩的前男友： 我这么优秀，那个five男有什么好的 渣女！ 挚友： 这个five男主配不上她，表示不服，不想让女主受伤。 男主： 黑人问号脸 女主： 这个人好有趣，我好喜欢他 女主死后-（真相揭露） 不明真相的同学们： 好可惜，红颜薄命 被女主甩的前男友： 心疼一秒， 活该 渣女！ 挚友： 为什么我什么都不知道！为什么？为什么？为什么？ 男主： 生命中的那个她就这样突然走了，心被扎碎了。 女主： 能在生命的最后遇到男主真好呀 emmm… 个人感觉这个作品中，最惨的就是这个挚友了，最后能与男主同归于好，应该是作者没有办法的办法了。 关于这部电影，对于原作的改动基本不大。 相当大一部分豆瓣网友们给了一星、两星。我也不想再去看评论了。铺天盖地的渣女、废物、男主性无能、傻屌剧情…… 也许有些人就是要背负着别人无法感知的重负而前行的吧。明明活着都已经很累了的。想证明自己的存在，但又不想伤害到别人 前几天又买了本 《いたいのいたいの、とんでゆけ》(不哭不哭，痛痛飞走)书名看起来挺治愈的吧，就买了。这本看完后想把之前看的《声之形》原著也看一遍。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[言の葉の庭]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%A8%80%E3%81%AE%E8%91%89%E3%81%AE%E5%BA%AD%2F</url>
    <content type="text"><![CDATA[鸣神の 少しとよみてさし昙り雨も降らんか 君を留めん 鸣神の 少しとよみて降らずとも我は止まらん 妹し留めば些许雷动，阴云遮天。天若降雨，可否留君于此。 些许雷动，阴云遮天。纵天无雨，我亦为君长留。 https://www.zhihu.com/question/63764580 会日语和会翻译就不是一个级别的，更何况我甚至无法意会 (Ｔ▽Ｔ) 又是一个讲师生恋的作品，人物、画面、音乐依旧无可挑剔。仅短短的45分钟，每一帧画面都是壁纸。情节紧凑，节奏舒缓，最后老师的告白完成了最终情感的爆发。看完感到一身舒爽~ 《中学圣日记》呢，也许是因为电视剧的缘故，后半段节奏过于拖沓，最后一集的狗血泰国教书简直可怕。就论前6集，一个动漫，一个电视剧，不相上下吧。 我怎么突然就对师生恋的作品感兴趣了呢，是因为这类题材比较刺激么… 刚刚又看到一个评论，大概知道为什么差距这么大了,因为言叶之庭在老师告白完就基本结束了。而中学圣日记为了happy ending还往后拍了7、8集，这就导致出现了各种恶心的事情，不过最后还能接受吧。渣诚处理地还是妙啊！ https://movie.douban.com/review/5999197/]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些好玩的游戏、好看的剧还有好听的歌]]></title>
    <url>%2F2019%2F01%2F28%2F%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%81%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%89%A7%E8%BF%98%E6%9C%89%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[上周末突然非常想玩游戏。然后想着想着就写下了这些。 这种感觉有过不止一次了，大概是太久不玩游戏了，前阵子也好累。明明以前还是非常爱玩游戏的，估计是老了，一点都不想玩游戏了，熬夜也熬不动了。 睡前突然想玩一下switch的《空洞骑士》，然后立马就下了一单。然后周日自虐了一下午，算不上高玩，但也不至于手残。一下午肝到‘苍绿之径’。不看攻略的话，怕是也肝不动这游戏了/(ㄒoㄒ)/~~。不过就是好玩呀。想到了大学时肝了好几天的《奥日与黑暗森林》，画面、音乐、游戏流程简直爆炸。几乎是所见完成度最高的游戏。当时肝过了普通版，后来发布了终极版但只是炒个冷饭，STEAM也没有中文。开心的是今年预计会出《奥里与精灵意志》，从PV看，还加入了类似“剑”这种武器，真是太秀了。今年非常非常期待的一部作品！ 玩过好多好玩的游戏，看过好看的书，好看的日剧，听过好听的歌。电影…电影院这辈子就没去过几次。渐渐这些都淡忘了。翻了翻b站的关注列表，emmmm…这些人都是谁呀，我只知道这些人应该都是大佬吧。再看看收藏夹，哇这个做得好炫，大毛、小天使唱的真好、这舞真可爱。这些东西扔进收藏夹渐渐也都忘了。应该说幸好还有收藏这个功能，还是说收藏夹就是这个功能呢。 对一些所谓有价值的东西的收藏目前也是有做，但过于分散。目前能想到的有 Google keep （但这主要是近期的记事） 手机截图（这种基本截完图就忘了） 微博关注及收藏点赞 手边的本子(写完估计也不会翻了) 以前还用有道云笔记 b站关注及收藏（基本不碰其他的视频网站） 总之这方面信息的记录过于分散，或者说记录了也未必会去回顾。也不知是否真的有必要记录下这些。毕竟不像写代码，这些东西以后也许真的就渐渐没价值了。反倒觉得某天突然发现： 哇！ 我以前听过这首歌！ 我小时候玩过这游戏！ 这样子更令人感动，有种重逢的感觉相当美好，但更多的是真的忘了吧。那天日推收藏了一首门谷纯的bon vayage，没几天突然日推了一首她的snow night，当时听到前奏，我他妈真差点哭了。我听过！看了评论才想起来3年前B站收藏过这个，当时还循环了好久，然后就那么给忘了…我怎么就这么忘了呢！ 要不是网易云，我真的可能不会再想起这首歌了。 昨晚睡前看了这个视频，本来很晚了，但还是看完了。没错我也有过里面说过的那种感觉，曾经也因为那种感觉做过视频、投过稿。后来也许是太懒了，两年多了再也没有过想做个视频冲动了。这就是大佬和普通人的区别吧，所以现在正用着vscode写这个 (´；ω；｀) 最近睡前看点日剧、日综，突然就会感叹一句 ‘我他妈连这个词都忘了，完了，我的日语没救了！’ 也许真的老了，或许是没有激情了，忘的东西也来越多了。 希望不要遗忘太多美好的东西。也不要太懒。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise的外部处理]]></title>
    <url>%2F2019%2F01%2F25%2FPromise%E7%9A%84%E5%A4%96%E9%83%A8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前看scratch-vm的源码经常能看到这样的处理。但是当年比较蠢，没理解这样做的缘由。 最近也需要处理这样的问题，先说一下场景： 执行某个操作，触发一个事件，触发该事件后作为该操作的resolve。 直接监听后resolve fn() &#123; return new Promise(resolve =&gt; &#123; dosth() sth.onEvent = resolve() &#125;)&#125; 将resolve传出Promise内部 var obj = &#123; ok: null, cancel: null&#125;function fn() &#123; return new Promise((resolve, reject) =&gt; &#123; obj.ok = resolve; obj.cancel = reject; &#125;)&#125;fn().then(res =&gt; console.log('then', res)).catch(err =&gt; console.log('catch', err));sth.onEvent = obj.oksth.onerror = obj.cancel]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrath3.0 插件对外通信]]></title>
    <url>%2F2019%2F01%2F04%2Fscrath%E6%8F%92%E4%BB%B6%E5%AF%B9%E5%A4%96%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[scratch3.0 插件对外通信前天scratch3.0发布，同时也发布了windows和macos离线版的scratch3.0。 今天刚好看到有人也在做GNU/Linux版本。虽然说是离线版本，但是还是不能实现本地的HTTP请求。这个跨域问题对scratch强大的扩展功能来说确实尴尬。 由于不能发送本地请求，对外的通信基本都要经过一个代理去实现。 利用第三方服务 方糖 ★★★★★ 关注方糖的微信公众号，通过发送web请求将信息推送至微信。 IFTTT ★★★★☆ if this then that,同样通过get请求推送事件信息。简单易用，就看脑洞够不够了。这里有个BUG，虽然请求会报跨域，但经测试get请求能够生效，post就不行了，无法携带上参数。 服务器自建后台 node-red ★★★☆☆ 简单入门一下，其实还是挺好用的，官方的生态做的已经很好了。大概可以理解为极客版ifttt。 手写 后台 / 本地服务 ★★☆☆☆ 官方的有scratch-link，但肯定是不够用的。非官方呢，当然自己写啦！ emmmmm本地版不能够发送本地请求真是太蠢了，真的有必要做一下这个功能。应该有个插件将请求代理给electron内的server。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反代]]></title>
    <url>%2F2018%2F11%2F26%2Fnginx%E5%8F%8D%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[记一下反代后台服务器的过程 nginx反代及路径问题基本配置server &#123; listen 80; server_name _; root /web/data; include /etc/nginx/default.d/*.conf; location / &#123; &#125; # 此处反代后台服务器至 /api location /api/ &#123; proxy_pass http://localhost:8080/; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 代理路径问题第一种：location /proxy/ { proxy_pass http://127.0.0.1:81/;}会被代理到http://127.0.0.1:81/test.html 这个url 第二种(相对于第一种，最后少一个 /)location /proxy/ { proxy_pass http://127.0.0.1:81;}会被代理到http://127.0.0.1:81/proxy/test.html 这个url 第三种：location /proxy/ { proxy_pass http://127.0.0.1:81/ftlynx/;}会被代理到http://127.0.0.1:81/ftlynx/test.html 这个url。 第四种：第四种情况(相对于第三种，最后少一个 / )：location /proxy/ { proxy_pass http://127.0.0.1:81/ftlynx;}会被代理到http://127.0.0.1:81/ftlynxtest.html 这个url]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父组件向子组件通信]]></title>
    <url>%2F2018%2F11%2F09%2F%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[昨天一个遇到的一个小问题，一时间没反应过来。父组件怎么将事件通知给子组件？ 正常操作： 子组件向父组件通信 $emit发送事件 父组件向子组件通信 props传递数据 骚操作： 父组件给子组件加上 ref，直接调用子组件的内部方法，没必要通过传递数据来触发事件。 不仅是子组件，router-view也可以这样操作。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感慨一下]]></title>
    <url>%2F2018%2F09%2F15%2F%E6%84%9F%E6%85%A8%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[大四的一年一直到现在真的太混了 混到没事就胡思乱想 我不应该是这样的]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue事件执行顺序]]></title>
    <url>%2F2018%2F09%2F03%2Fvue%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[之前一直有个问题vue中emit的执行顺序是什么？ // 父文件&lt;template @receive=&quot;receive&quot;&gt;&lt;/template&gt;receive() &#123; cosnole.log(&apos;接收到事件&apos;)&#125; // 子组件&lt;button @click=&quot;send&quot;&gt;&lt;/button&gt;send() &#123; this.$emit(&apos;receive&apos;) cosnole.log(&apos;发送事件&apos;)&#125; // 控制台&apos;接收到事件&apos;&apos;发送事件&apos; 原本以为结果是先打印‘发送事件’然后打印‘接收到事件’，结果却是相反，暂时还没想通这是为什么。在我认为应该是先执行send中的同步任务，然后事件的触发应该作为类似于回调在同步任务完成后执行。 关于这个，刚刚写着写着突然想通了，之前看过一个关于简易事件库的实现。简单来说父组件在注册事件时，将对应的方法和事件名做好绑定，在emit时，看起来事件的执行和这个emit时没有直接的联系的，但实际上就是执行了事件中的方法。括号中的参数就是指定的事件名，所以可以理解为emit就是执行了众多一一绑定好的事件中的某一个。所以结果是先执行’接收到事件’后执行’发送事件’。我好蠢啊！终于想通了这个这么简单的问题。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖&节流]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[函数防抖： 防止事件在某一时刻频繁触发 函数节流： 降低事件在一段长时间内频繁触发的次数 记录一下常见的几种写法 // 防抖 延迟执行 （事件触发后一定时间内不立刻执行）const debounce = (func, wait, ...args) =&gt; &#123; let timeout; return function()&#123; // 这里的绑定this是绑定的在addeventlistener时环境中的this const context = this; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, ...args) &#125;, wait); &#125;&#125;// 防抖 立即执行 （事件触发后立刻执行，但在一定时间内不再次执行）const debounce1 = (func, wait, ...args) =&gt; &#123; let timeout; return function(event)&#123; // 这里给个e能够拿到事件信息 const context = this; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;,wait) if (callNow) &#123; func.apply(context, ...args) &#125; &#125;&#125;// 防抖 结合版 这个没进行实际测试function debounceAll(func,wait,immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125;// 节流 时间戳版const throttle = (func, wait, ...args) =&gt; &#123; let pre = 0; return function () &#123; const context = this; let now = Date.now(); if (now - pre &gt;= wait) &#123; func.apply(context, ...args); pre = Date.now(); &#125; &#125;&#125;// 节流 定时器版const throttle1 = (func, wait, ...args) =&gt; &#123; let timeout; return function () &#123; const context = this; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, ...args); &#125;, wait) &#125; &#125;&#125;// 调用document.getElementById('button').addEventListener('click', throttle1(clickEvent, 1000))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emmm...还是画画有趣...]]></title>
    <url>%2F2018%2F07%2F29%2Femmm-%E8%BF%98%E6%98%AF%E7%94%BB%E7%94%BB%E6%9C%89%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[教练！我想学画画！前段时间突然又想学画画了，没错是‘又’，翻了一下说说，上次画画是15年9月份（大二刚开学，都三年过去啦），画了一段时间还是没能坚持下去，好可惜啊，说不定现在都是大触了呢。 然后呢，前阵子一冲动就买了块数位板，坚持每天都画点东西吧！希望能坚持下去吧！！！ 血小板还是可爱的哇 脸画崩了，真是抱歉(｀・∀・´)]]></content>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录工作时遇到的一些问题。 并没什么有深度的内容，主要还是一些技巧/注意点。 创建自定义事件 https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events var event = new Event('build');// Listen for the event.elem.addEventListener('build', function (e) &#123; ... &#125;, false);// Dispatch the event.elem.dispatchEvent(event); 判断字符串起始String.prototype.startsWith()String.prototype.endsWith()// 均可传入第二个参数表示起始位置 简单的任务队列this.queue = Promise.resolve(true);addQueue(job) &#123; this.queue = this.queue.then(job) .catch((e) =&gt; &#123; console.error(e); &#125;); return this.queue;&#125;// 将Promise任务添加至队列，确保上个任务完成后执行该任务 package.json 私有包处理"project": "git+ssh://git@github.com/&lt;username&gt;/&lt;proejct&gt;#&lt;branch/commit&gt;", 安装mecabbrew install mecab//安装字典$ tar zxfv mecab-ipadic-2.7.0-XXXX.tar.gz$ cd mecab-ipadic-2.7.0-XXXX$ ./configure --with-charset=utf8$ make$ sudo make install flex 子元素无法设置为 position stickyflex 默认 子元素为 strech 设置该子元素 align-self: flex-start; useEffect / useLayoutEffect 区别https://juejin.im/post/5de38c76e51d455f9b335eff 文本一行时 居中对齐， 多行时左对齐&lt;div&gt; // 父元素设置 text-align center &lt;p&gt;text&lt;/p&gt; // display inline-block ; text-align left&lt;/div&gt; React、Vue 事件 异步方法使用事件 （合成事件）// https://zh-hans.reactjs.org/docs/events.htmlonClick=(e) =&gt; &#123; let event = e // 需要赋值 promise().then(res =&gt; console.log(e))&#125; 对象扩展 条件赋值&#123; foo: &apos;a&apos;, ...(true ? &#123;boo: &apos;b&apos;&#125; : null)&#125; React 报无限 looponClick=&#123;fun()&#125; React Hook 翻页const [current, setCurrent] = useState(1)useEffect(() =&gt; &#123; cb &amp;&amp; cb(current)&#125;, [current])onClick=&#123;() =&gt; setCurrent(prev =&gt; ++prev)&#125; React Hook 倒计时useEffect 形成闭包，使用 Ref 存储上次time 或使用 time 作为监听值 触发timeout 成为 interval 来使用 字符问题转为 Unicode, 可能带有换行 或者特殊字符 ，使用 normalize 转换 ? / ?? 的使用a?.b?.c = &apos;xxx&apos; React Hook 异步引用 state根本原因 Hook 是向函数中传入函数，形成闭包。 所记录的的函数创建时的引用值，而无法获取更新后（内存地址变化）的值，导致运行异常。 使用 useRef 获得一个，引用类型的变量记录值的变化即可。 之前遇到的一个问题： // stateA stateBconst initCallBack = useCallback(() =&gt; &#123; // do sth&#125;, [stateA, stateB])// pageAuseEffect(() =&gt; &#123; api().then(initCallBack)&#125; [initCallBack])// pageBuseEffect(() =&gt; &#123; api().then(initCallBack)&#125; [initCallBack]) 有2个页面有会在载入时进行init， 后调用 initCallback 会根据 state 状态跳出，防止重复 init。 但是打log可以发现还是重复init了。 原因还是在于异步调用，虽然 dep 是注册了 initcallback 的变化，但是在执行异步方法中所使用的并不是更新后的 callback，从而使用了错误的 init 状态，导致多次 init。 解决办法是在记录 init state 的同时，使用ref或普通变量去记录且用于判断init状态即可。 drag apidom 元素在 drag end 时，默认会有一个元素恢复原位的一个动画。 // https://stackoverflow.com/questions/32206010/disable-animation-for-drag-and-drop-chrome-safaridom.onDragOver = (e) =&gt; e.preventDefault() drag api 兼容桌面端与移动端不兼容，js只有桌面端（鼠标输入）形式的 drag api. 移动端可使用 https://github.com/timruffles/mobile-drag-drop 做兼容 在既有鼠标输入又有触摸输入的设备（可触屏的win10），无法使用触摸拖拽 自定义 font 顺序加载使用自定义字体时,如果使用的是外部资源，会出现文字由默认字体到目标字体闪烁变化的问题 // https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face@font-face &#123; src: url(data:application/octet-stream;base64,xxxx)&#125; 字体文件转为 base64 保证加载顺序 或者 &lt;link rel="preload" href="https://fonts.woff2" as="font" crossorigin="anonymous"/&gt; IOS 视频不显示封面IOS设备默认不显示 video 封面有一个有意思的方法 // https://muffinman.io/blog/hack-for-ios-safari-to-display-html-video-thumbnail/&lt;video&gt; &lt;source src="path-to-video.mp4#t=0.001" type="video/mp4" /&gt;&lt;/video&gt; IOS 文件下载IOS中文件下载,js创建的a标签需要append到body中，不然是下载不了的！！ safari 浏览器 url hash 设置有节流限制出现在使用某个md标题插件，记录当前的位置，过多触发 set url hash, 导致该功能被限制在 30s/次 webpack 打包时记录版本信息// webpack configconst GitRevisionPlugin = require('git-revision-webpack-plugin')const gitRevisionPlugin = new GitRevisionPlugin()const LoadCommitDate = gitprocess .execSync('git log -1 --date=format:"%Y/%m/%d %H:%M:%S" --format="%ad"') .toString()// 也可以用 dayjs 二次处理// 后来也想 直接用 new Date() 记录CI打包的时间不过想想意义不太大。export default &#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env.VERSION': JSON.stringify(gitRevisionPlugin.version()), 'process.env.COMMITDATE': JSON.stringify(LoadCommitDate) &#125;) ]&#125; 复合组件// https://github.com/penouc/blog/issues/7// 调用React的顶层api React.Children 获取child, 处理 Child props。&lt;Stepper.Steps&gt; &lt;Stepper.Step num=&#123;1&#125; text=&#123;"Stage 1"&#125;/&gt; &lt;Stepper.Step num=&#123;2&#125; text=&#123;"Stage 2"&#125;/&gt; &lt;Stepper.Step num=&#123;3&#125; text=&#123;"Stage 3"&#125;/&gt; &lt;Stepper.Step num=&#123;4&#125; text=&#123;"Stage 4"&#125;/&gt;&lt;/Stepper.Steps&gt; 组件数据 部分解耦// 传入children为函数即可， children 渲染，部分依赖父组件，部分依赖该组件内部数据const CustomComponent = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &#123;this.children(data)&#125; &lt;/div&gt;)&#125;&lt;CustomComponent&gt; &#123;(internalProps) =&gt; &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;&lt;/CustomComponent&gt; before / after 伪元素input 没有伪元素！！！ PWA 更新// https://create-react-app.dev/docs/making-a-progressive-web-app/ This means that users will end up seeing older content until they close (reloading is not enough) their existing, open tabs. See this blog post for more details about this behavior. 在资源更新的事件触发后，需要关闭tab，再重新打开才能确保资源成功更新 一种有意思设置默认参数形式当时也不知道怎么想的， 写个这个挺高效的传参方式 const getEvents = (&#123;page_num&#125;=&#123;&#125;) =&gt; instance.get(`/messages`, &#123; params: &#123;page_size: 10, page_num: 1, ...params&#125;&#125;) Typescript 联合类型断言data.forEach(item =&gt; &#123; if (item.topic.startsWith('things/')) &#123; item = item as TYPEA &#125; else if (item.topic.startsWith('scenes/')) &#123; item = item as TYPEB &#125; &#125;) react function children适合我这样的懒人 // array children 需要一个 key 哦 &lt;div className="content"&gt; &#123;(() =&gt; &#123; lists.length &gt; 5 &amp;&amp; (lists[4] = &lt;i key="icon-more" className="iconfont icon-more"/&gt;) return &lt;&gt;&#123;lists.slice(0, 5)&#125;&lt;/&gt; &#125;)()&#125;&lt;/div&gt; webthing 设备卡片 UI 模板的设计第一版考虑到数据与模板尽量解耦 useBaseThing 可以单独使用，用于注册事件等不需要 UI 参与的业务， const useBaseThing = (thingDesc) =&gt; &#123; // propertes state // model ref // action callback // model event update state return &#123; propertes, model, action &#125;&#125;const ThingTemplate = (&#123;propertes, model, action, children&#125;) =&gt; &#123; return ( &lt;div&gt; thing xxxxxx &lt;div&gt;&#123;propertes&#125;&lt;/div&gt; &lt;button onclick=&#123;action&#125;&gt;action&lt;/button&gt; &#123;children&#125; &lt;/div&gt; )&#125;// 一个基本的 thing UIconst data = useBaseThing(thingDesc)return (&lt;ThingTemplate &#123;...data&#125;&gt; &lt;div&gt;自定义icon等&lt;/div&gt;&lt;/ThingTemplate&gt;) 第二版第一版虽然完全分离， 但是有个问题，要使用模板就必然要先 useBaseThing 获取数据 所以考虑重构，将模板创建整合进 useBaseThing 同时一个 thing UI 中，需要自定义的部分需要包含更多的内容，如二级对话框、图标、触发按钮等，还要考虑到后期的扩展性，仅留下一个 ThingTemplate children 作为自定义元素就远远不够了。 const useBaseThing = (&#123; thingDesc, templateConfig: &#123; CustomTemplateA, CustomTemplateB, CustomTemplateC &#125;&#125;) =&gt; &#123; // propertes state // model ref // action callback // model event update state return &#123; propertes, model, action, baseThing: &lt;ThingTemplate customTemplateA=&#123;&lt;CustomTemplateA propertes=&#123;propertes&#125;/&gt;&#125; customTemplateB=&#123;&lt;CustomTemplateB propertes=&#123;propertes&#125;/&gt;&#125; customTemplateC=&#123;&lt;CustomTemplateC propertes=&#123;propertes&#125;/&gt;&#125; /&gt; &#125;&#125;const ThingTemplate = (&#123; propertes, model, action, customTemplateA, customTemplateB, customTemplateC&#125;) =&gt; &#123; return ( &lt;div&gt; thing xxxxxx &lt;div&gt;&#123;propertes&#125;&lt;/div&gt; &lt;button onclick=&#123;action&#125;&gt;action&lt;/button&gt; &#123;customTemplateA&#125; &#123;customTemplateB&#125; &#123;customTemplateC&#125; &lt;/div&gt; )&#125;// 创建一个基本的 thing UI// 这里最好配合 typescript 增加类型提示const CustomTemplateA = (data) =&gt; &lt;&gt;&lt;/&gt;const CustomTemplateB = (data) =&gt; &lt;&gt;&lt;/&gt;const CustomTemplateC = (data) =&gt; &lt;&gt;&lt;/&gt;const &#123;baseThing&#125; = useBaseThing(&#123;thingDesc, templateConfig: &#123; CustomTemplateA, CustomTemplateB, CustomTemplateC &#125;&#125;)return baseThing // thing JSX.Element// 创建一个无 UI thingconst &#123;modal&#125; = useBaseThing(&#123;thingDesc&#125;)modal.on('event', () =&gt; &#123;&#125;) thing UI 也通过 useBaseThing 创建，可以根据 templateConfig，设置 UI 是否创建 第三版目前实际开发下来第二版在扩展性上基本没有什么问题，但感觉还是有一些繁琐了 要说有问题，就是 ThingTemplate 是在 useBaseThing 内部创建，内部的插槽模板是写在外部，传入 useBaseThing， 写起来有一点违和 但是这些 Component 都是依赖 useBaseThing 内部的 state 数据，又没有办法，只能在这个上下文创建。 也许应该还有更加高效的组合方式 input 输入法问题https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart https://juejin.cn/post/6844903950634713096 text input onchange 事件获取的 value，会包含输入法输入的内容 使用 onCompositionStart 记录当前是否为输入法状态，控制onchange执行 react v17https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing 组件卸载时 useEffect 的 return 会异步执行，也就是在完全卸载后执行，dom元素事件监听的卸载需要在useLayoutEffect处理 总结就是 useEffect -&gt; 加载 -&gt; useLayoutEffect -&gt; useLayoutEffect -&gt; 卸载 -&gt; useEffect Electron index.html 加载本地（static）静态 js旧版本可以这么用 &lt;script src="./static/xxx.js"&gt;&lt;/script&gt; 后来为了适配CI升了下版本，过不了打包流程，只能使用一个歪门邪道处理 &lt;script id="syncload"&gt; function loadScriptAsync(url) &#123; var head = document.getElementsByTagName("head")[0]; var s = document.createElement("script"); s.src = url; let referenceNode = document.querySelector('script#syncload') referenceNode.parentNode.insertBefore(s, referenceNode.nextSibling); &#125; loadScriptAsync('./static/xxx.js')&lt;/script&gt; 屏幕 / Canvs录制https://developer.mozilla.org/zh-CN/docs/Web/API/MediaRecorder https://developer.mozilla.org/zh-CN/docs/Web/API/Screen_Capture_API/Using_Screen_Capture 元素滚动检测 APIIntersectionObserver createDocumentFragment可以理解为 React 中的 Fragment, 一个无父节点的元素 https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 Webpack 记录版本 pluginhttps://github.com/LLK/scratch-www/blob/develop/webpack.config.js#L31 网页水印https://www.zhangxinxu.com/wordpress/2020/10/text-as-css-background-image/ 使用文本 svg 作为元素背景 可以实现类似 before/after 伪元素的效果]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天啦噜，这个表情包真是太可爱了]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%A4%A9%E5%95%A6%E5%99%9C%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%A1%A8%E6%83%85%E5%8C%85%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%8F%AF%E7%88%B1%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这个表情包怎么可以这么可爱呢！ 一周事件刷完小说，现在有点不能直视这个表情包了，不过也有说这本小说和表情包没有关系的（莫非是同一个画师？） menharu酱 还有带配音的诶、小姐姐给配成傲娇属性了 (・∀・) mad也来了哦 鬼畜也有 不废话找到原著，立马下个单，话说有段时间没看日文小说啦 关于这本书 这个女主应该和表情包没关系吧 这个女高中生沙优，emmm…..怎么是个失足少女啊。还好男主是个滥好人，也不对，毕竟都开后宫了。剧情一般，人物设定略特殊（为什么是失足少女啊！心疼。大马路上就能捡到，我到也想捡一个哈），情节虽不至于跌宕起伏，还是有一段高潮的，男主的反应emmm….在下佩服….（还好安全下车），结局也不错（标准日系结局），皆大欢喜，就当巩固一下日语单词以上です。]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AE表达式]]></title>
    <url>%2F2018%2F03%2F18%2FAE%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[emmm…. 教程还是边看边整理的好，就怕自己不带脑子 AE表达式整理基本层级关系thisComp.layer(“layerName”).propertyies index二维转三维 position表达式： value + [0, 0, index] slider可以理解为一个可以赋值的变量，然后将这个变量放置于表达式中，用于批量控制 timetime就是合成窗口左上角的时间值 posterizeTime(表达式页面的Global中)posterizeTime(帧速率)按指定的速率显示动画 wigglewiggle(freq, amp) 【频率， 幅度】wiggle返回值不一定是数字，直接写在属性的表达式框框里会返回对应的数据格式的 interpolationinterpolation(time, tmin, tmax, val1, val2)在time的时间段内 tmin - tmax之间这段时间里执行动画属性从val1-val2的动画time也可以为某些运动数值的变化 randomrandom(max) 0~maxrandom(min, max) min~max Math库和js中的功能基本一致 clampclamp(property, min, max)限制某一属性值在某一范围之内 looploopIn在关键帧之前运行关键帧动画loopOut在关键帧之后继续运行关键帧动画 参数 1 string circle 重复执行 pingpong 往复执行 continue 相当于动画的无限延长（根据最后两个关键帧的动画） offset 也是动画的无限延长（但是根据的是前面整个动画的运动趋势继续下去，区别于continue） 参数 2 number numkeyframe 重复帧的区间 1的话就是根据最后一个关键帧进行loop计算，2就是最后两个关键帧帧,0就是所有啦 在loopOutDuration()中 参数2 指的是最后几秒（s）而不是最后的几个关键帧 speedproperty.speed 获得当前属性变化的速度（）property.speedAtTime（time） 获得当前属性在某一时间刻度的速度 keyproperty.key(num) 获得某一属性第num关键帧的相关信息 value 当前的值 time 关键帧对应的合成时间 index 就是指第几个关键帧 marker (shift+num添加关键帧，ctrl+click去掉关键帧)comp.marker.key(num)获得第某个标记的信息（双击标记中的信息） sourceRectAtTimecomp.layer(‘layerName’).sourceRectAtTime(time, false).property这个例子中是获得了形状图层中content的属性 没太懂]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>After Effects</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几本书]]></title>
    <url>%2F2018%2F03%2F11%2F%E8%AE%B0%E5%87%A0%E6%9C%AC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[开学两周，毕业设计什么的还没什么通知，趁现在没什么事，周末图书馆刷些小说，以后毕业了怕是没那么容易找个安静的地方了 手动害怕 各种书翻了翻kindle发现买的书都过百了，看完的不过3，40十本，下班回宿舍看书什么的不存在的，还是去图书馆靠谱。 下面打算看的 世界的凛冬 抽空补完 口吐宝石的女孩 吾辈是猫 乌合之众或者沉默的大多数 刚刷完的 恶意-东野圭吾 这本书的写法很神奇 情人-渡边淳一 湖畔-东野圭吾 布谷鸟的蛋是谁的-东野圭吾 东野圭吾那些不错的 白夜行 嫌疑人X的献身 虚无的十字架 湖畔 彷徨之刃 放学后 我的晃荡青春 一些很好看的 三体 巨人的陨落 人间失格 现在看完了或者之看了开头看不懂的，等长大了再看~~ 情人 失乐园 挪威的森林 王小波所有的 厚黑学 乌合之众]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理and吉他和弦]]></title>
    <url>%2F2018%2F02%2F16%2F%E4%B9%90%E7%90%86and%E5%92%8C%E5%BC%A6%2F</url>
    <content type="text"><![CDATA[啊，回家过个年是真的烦。就想安静地过几天啊。电脑扔学校里没带回来，游戏也没得玩了，房间里倒是还有把吃灰一年多的吉他~~ 然后今天是除夕额，我的微信为什么挂在后台好像被杀掉了，还错过了一波公司群的红包,伤心… 乐理and吉他和弦乐理doyoudo乐理基础很棒的一个网站，之前AE,C4D,PS也在这个网上学的（然而现在在写代码(┬＿┬)） 其实之前应该是看过一点乐理的，但是忘得差不多了，只记得CDEFGAB了，再复习一遍吧 大调主音与三级音构成为大三度的调式为大调 C大调C（全音）D（全音）E（半音）F（全音）G（全音）A（全音）B（半音）C 类似于这样的（全全半全全全半）8度音称为大调，C为主音就是C大调，这样子的话D大调那就是这个样子 D(全)E（全）F#（半）G（全）A（全）B（全）C#（半）D 音的稳定1 5 3 6 2 4 7稳定 -&gt; 不稳定 音的倾向性1 &lt;- 2 | 3 &lt;- 4 | 5 1 音程音程对照 半音数 0 1 2 3 4 5 6 7 8 9 10 11 12 音程 纯一度 小二度 大二度 小三度 大三度 纯四度 增四\减五度 纯五度 小六度 大六度 小七度 大七度 纯八度 三全音三全音： 半音为6个（增四/减五度）称为三全音 【如：B -&gt; F】 音的转位如： B -&gt; F （减五度）与 F -&gt; B （增四度） 度数相加为9 大小增减是互换 纯音程不变 E -&gt; C （小六度） C -&gt; F (大三度) C -&gt; G (纯五度) G -&gt; C（纯四度） 音的协和度 完全协和音程 纯一度、纯八度 协和音程 纯四度、纯五度 不完全协和音程 大小三度、大小六度 不协和音程 大小二度、大小七度、增四减五度 和弦根据三度叠置形成和弦 大三和弦Cmaj 简写 C大三度 小三度C -&gt; E -&gt; G根音 三音 五音 （度数） 小三和弦Dmin 简写 Dm小三度 大三度D -&gt; F -&gt; A C大调和弦 1 2 3 4 5 6 C Dm Em F G Am CEG DFA EGB FAC GBD ACE 减三和弦Bdim (diminished)小三度 小三度B -&gt; D -&gt; F 和弦转位CEGB EGCB GCEB BCEGCM7 CM7/E CM7/G CM7/G原位 第一转位 第二转位 第三转位 三音第一位 五音第一位 大大七和弦大三和弦+距根音大七度音Cmaj7 简写 CM7 C （大三度） E （小三度） G (大三度) B 小七和弦大三和弦+距根音小七度音 Amin7 简写Am7 A (小三度) C (大三度) E (小三度) G 属七和弦大三和弦+小七度音 Gdom7 简写 G7 大调中5级音开始（G转位找大二度为F，然后高八度为F） G(大三度)B(小三度)D(小三度)F 小大七和弦小三和弦+大七度音EminMaj7 简写 EmM7E(小三度)G(大三度)B(大三度)D# 五度循环圈C为主音，以纯五度音相连为循环 在同一个时钟点上的大小调互为“关系大小调”，也叫“平行大小调”，比如C大调和a小调都在12点 时差越近的调，关系也越近，叫做“近关系调”，比如C大调和G大调，时差1小时，关系最近 时差越远的调，关系也越远，叫做“远关系调”，比如C大调和#F大调，时差6小时，关系最远 C - G - D - A - E 音级名称 C D E F G A B C 1 2 3 4 5 6 7 1 主音 上主音 中音 下属音 属音 下中音 导音 主音 上方相邻 主音与属音中间 下方纯五度 上方纯五度 主音与下属音中间 下方相邻 小调主音与三级音构成为小三度的调式为小调 自然小调C大调 C D E F G A B Cc小调 C D Eb F G Ab Bb C 全 半 全 全 半 全 全 关系大小调构成音一致的大小调C大调 C D E F G A Ba小调 A B C D E F G 从五度循环圈中的音小三度的小调即为对应的关系小调 小调的变体a自然小调 A B C D E F G Aa和声小调 A B C D E F G# Aa旋律小调 A B C D E F# G# A 吉他和弦 参考：http://www.17jita.com/hexian/cdiao/ E7 C G7 Am G F Em Dm]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用live2d给博客加个卡哇伊的挂件]]></title>
    <url>%2F2018%2F01%2F17%2F%E7%94%A8live2d%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%AA%E5%8D%A1%E5%93%87%E4%BC%8A%E7%9A%84%E6%8C%82%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[看到右下角的小东西了么，没有？是不是把侧栏打开了？还是没有？那再等等吧…加载有点慢额。其实这个东西好早就见过了，之前看bilibili直播在直播间旁边就挂着一只22还是33来着，点击还能有动画 戳这里，好好玩的，但一直不清楚怎么做的…后来在DIYGOD的博客上也发现了这个,就好好的查了一下这个小玩意儿~~ emm…. 这个插件最近升到3.0了，写这篇博客时还是2.0的，安装的时候要不指定下版本吧，新版功能我也不太清楚额…历史版本 另外推广下前段时间写的vscode的live2d插件 戳这里 Live2D这东西来自于霓虹国的神奇脑洞官网，将二维物体通过位置转换或者形变达到模拟3D的效果。虽然比不上真实3D，不过也很有趣了 HEXO插件在Github上正好有这个插件，就能够很方便的实现这个效果啦~~ 见右下角的那只小猫，以后可以云吸猫了 项目地址hexo-helper-live2d 这个插件已经自带了好些模型了，但是还是觉得不够怎么办呢戳这里,官方已经做了一个用于分享的库，只需要把对应的文件下载下来然后参照上方插件的README中的说明进行配置就能够看到效果了。（这里有个文件版本的问题，见下面） 模型文件版本的问题这个插件是v2.1的，但是上面的库里面下的文件有的是3.0的所以需要转换。 下载下来的文件包应该是类似这样的两种结构 // 这种moc+json+文件夹材质的是2.x版本的工程文件│ model.model.json // 模型json数据│ model.moc // 模型文件│└─model.1024 texture_00.png // 模型材质贴图（不同分辨率用）// json文件内容 是与当前目录的文件对应的&#123; &quot;type&quot;: &quot;Live2D Model Setting&quot;, &quot;name&quot;: &quot;makoto0&quot;, &quot;model&quot;: &quot;makoto0.moc&quot;, &quot;textures&quot;: [ &quot;makoto0.2048/texture_00.png&quot; ]&#125;// 还有一种仅只有单个的.cmox文件，这是3.0版本的项目文件，需要进行转换yukari_model.cmox 2.x版本对于第一种，很简单按照上面插件里面的README，在blog的根目录建立models的文件夹，然后将对应的2.x版本的文件包放进去，最后在config.yml中的model配置上填入对应的名称就ok了 3.0版本这个版本的话，需要进行一下转换。首先要下几个东西 Locale Emulator 用于跑各种日文软件的小工具，安装完后右击要打开的软件选择到Locale Emulator，并选择在日文环境下运行，就不会出现乱码 Live2D Cubism Editor 3.1 安装的时候应该会乱码，不用管，装完用上方的工具打开就行 Live2d-viewer 参照下载的说明就是需要先安装adobe air（下面有链接直接点击下载）,然后下载这个双击安装。 全部安装好了，打开Live2D Cubism Editor 3.1（右击选择Locale Emulator，并选择run in japanses）然后按照步骤 左上角ファイル、ファイルを開く,选择到.cmox的文件打开 应该会跳个框，不用管ok就行 左上角ファイル、組み込む用ファイル書き出し、mocファイル書き出し（2.1） 弹出的框框直接点OK，然后打开文件的目录下就会有类似上面说的2.x版本的那些文件了 然后的处理方法就和上面的2.x版本一样了]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2017%2F11%2F14%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[每天学一点Python ing python学习平时记录 *args是可变参数，args接收的是一个tuple; **kw是关键字参数，kw接收的是一个dict 迭代 dict迭代 // 默认为key d = &#123;'a': 1, 'b': 2, 'c': 3&#125; for key in d: print(key)// 迭代value的话for value in d.values()print(value) str迭代 str = 'hello'for ch in str: print(ch) list迭代 //enumerate 可以获得index值for i, value in enumerate(['A', 'B', 'C']): print(i, value) tuple迭代 for x, y in [(1, 1), (2, 4), (3, 9)]: print(x, y) set迭代 生成器迭代 生成器 生成器 // List生成式 L = [x * x for x in range(10)] L //[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] // 改为生成器 g = (x * x for x in range(10)) next(g) // 0 next(g) // 1 生成器可以被迭代 for n in g: print(n) 使用yield 迭代器 可作用于for的称为可迭代对象 Iterable 可使用next()的称为迭代器 Iterator 把list、dict、str等Iterable变成Iterator可以使用iter()函数 装饰器 简单的装饰器 import functoolsdef log(func):def wrapper(*args, **kw): print 'call', func.__name__ return func(*args, **kw)return wrapperdef logPlus(text): def decorator(func): @functools.wraps(func) // 此处保证函数信息一致 def wrapper(*args, **kw): print text, func.__name__ return func(*args, **kw) return wrapper return decorator@logdef now(): print '2017-11-15'now()// call now// 2017-11-15 带参数的装饰器 def logPlus(text): def decorator(func): def wrapper(*args, **kw): print text, func.__name__ return func(*args, **kw) return wrapper return decorator@logPlus('time')def now(): print '2017-11-15'now()// time now// 2017-11-15 偏函数用于固定部分参数 import functoolsint2 = functools.partial(int, base=2)int2('1000000')//64 类 基本 // object是值该类继承于object类class Student(object): // 这样可以直接定义类的属性 grade = 6 // 这样可以规定属性的个数，使用元祖定义，仅对当前的类起作用 __slot__ = ('name', 'score') // 这相当于js的construct，self为必传参数 def __init__(self, name, score): // 以两个_开头的是私有变量 self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) @property class Student(object): // 这样方法相当于属性值返回 @property def score(self): return self._score // 修改score时自动通过该方法判断 @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 多重继承 class Runnable(object): def run(self): print('Running...')class Flyable(object): def fly(self): print('Flying...')// 在类名的括号中填入需要继承的多个类名class Dog(Mammal, Runnable): pass 元类 这个看起来很厉害是class的上级，具体用到再看看 调试 断言 assert 如果断言处不符，则会报错 启动Python解释器时可以用-O参数来关闭assert logging pdb单步调试 文件读写 文件读操作 with open('/path/to/file', 'r') as f:print(f.read())// 反复调用read(size)可以每次读取固定大小值// readlines() 可以按行读取文件，得到listfor line in f.readlines():print(line.strip()) # 把末尾的'\n'删掉// 读取二进制文件 后面使用参数 'rb'f = open('/Users/michael/test.jpg', 'rb')f.read()// 第三个参数可以确定读取的编码f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')f.read()// 如果不能按编码读取， 第四个参数可以加入errors='ignore'，就可以忽略读取时的报错f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') 文件写操作 with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') 序列化 pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。 pickle.dump()直接把对象序列化后写入一个file-like Object 用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象 f = open('dump.txt', 'wb')pickle.dump(d, f)f.close()// 从保存这序列化对象的文件中读取对象f = open('dump.txt', 'rb')d = pickle.load(f)f.close()// JSON的序列化和反序列化、import jsond = dict(name='Bob', age=20, score=88)json.dumps(d)json_str = '&#123;"age": 20, "score": 88, "name": "Bob"&#125;'json.loads(json_str) 常用模块 datetime from datetime import datetimeprint datetime.now()// datetime.datetime(2017, 11, 17, 16, 12, 24, 665000) collections namedtuplefrom collection import namedtuplePoint = nametuple('Point', ['x', 'y'])p = Ponit(1, 2)p.x // 1p.y // 2 hashlib摘要算法 md5 sha1]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impress.js源码阅读]]></title>
    <url>%2F2017%2F11%2F10%2Fimpress-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[最近有点忙了呀，又过上宿舍-公司-食堂-宿舍的生活了，之前闲的慌，现在发现早上7点起床到晚上吃完饭回宿舍8点多了，都几乎没有能完全自己支配的时间了，不过还好啦，公司下班到挺准时的~~然后还是想找些其他提升自己的事做做啦，正好前些时候用了impress写了个demo,那么这次就看看impress.js的源码啦 impress.js源码阅读CSS前缀的兼容处理var pfx = ( function() &#123; var style = document.createElement( "dummy" ).style, prefixes = "Webkit Moz O ms Khtml".split( " " ), // 此处算是个闭包，做记忆 memory = &#123;&#125;; // prop为css属性 return function( prop ) &#123; // 如果memoory对象中为存储该属性时 if ( typeof memory[ prop ] === "undefined" ) &#123; // 首字母大写 var ucProp = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ), // 此处处理为如下： transition webkitTransition MozTransition props = ( prop + " " + prefixes.join( ucProp + " " ) + ucProp ).split( " " ); // 创建该属性对象 memory[ prop ] = null; for ( var i in props ) &#123; // 判断该属性是否存在 if ( style[ props[ i ] ] !== undefined ) &#123; // 给上一个可用前缀的属性名并且break出去 memory[ prop ] = props[ i ]; break; &#125; &#125; &#125; // 返回这个可用的属性 return memory[ prop ]; &#125;; &#125; )(); 处理类数组// 将类数组转换为数组也可用于数组的克隆 var arrayify = function( a ) &#123; return [].slice.call( a ); &#125;; 设置css的对象// 传入DOM元素以及包含CSS属性的对象，并且通过pfx设置浏览器兼容属性// 传入的对象如： &#123;width：'10px';height: '10px'&#125;var css = function( el, props ) &#123; var key, pkey; for ( key in props ) &#123; if ( props.hasOwnProperty( key ) ) &#123; // 做css的兼容处理 pkey = pfx( key ); if ( pkey !== null ) &#123; el.style[ pkey ] = props[ key ]; &#125; &#125; &#125; return el;&#125;; 处理数字// 判断是否为数字，若不是数字则执行fallback，若未传入fallback则返回0，如果是数字，则处理为数字 var toNumber = function( numeric, fallback ) &#123; return isNaN( numeric ) ? ( fallback || 0 ) : Number( numeric ); &#125;; 元素选择器// 传入上下文和CSS选择器，若未传入上下文则使用document，返回匹配的第一个元素var $ = function( selector, context ) &#123; context = context || document; return context.querySelector( selector );&#125;; // 传入部分同上，返回匹配的所有元素，并且数组化 var $$ = function( selector, context ) &#123; context = context || document; return arrayify( context.querySelectorAll( selector ) ); &#125;; 事件触发器// 事件的触发器// 传入触发元素，事件名var triggerEvent = function( el, eventName, detail ) &#123; var event = document.createEvent( "CustomEvent" ); event.initCustomEvent( eventName, true, true, detail ); el.dispatchEvent( event );&#125;; 根据网址的hash获取dom元素var getElementFromHash = function() &#123; // Get id from url # by removing `#` or `#/` from the beginning, // so both "fallback" `#slide-id` and "enhanced" `#/slide-id` will work return byId( window.location.hash.replace( /^#\/?/, "" ) );&#125;; 设备兼容性的判断var ua = navigator.userAgent.toLowerCase();var impressSupported = // Browser should support CSS 3D transtorms // 是否包含透视属性 ( pfx( "perspective" ) !== null ) &amp;&amp; // Browser should support `classList` and `dataset` APIs // 是否支持Data属性 ( body.classList ) &amp;&amp; ( body.dataset ) &amp;&amp; // But some mobile devices need to be blacklisted, // because their CSS 3D support or hardware is not // good enough to run impress.js properly, sorry... // 去除对移动设备的支持 ( ua.search( /(iphone)|(ipod)|(android)/ ) === -1 );if ( !impressSupported ) &#123; // We can't be sure that `classList` is supported body.className += " impress-not-supported ";&#125; else &#123; body.classList.remove( "impress-not-supported" ); body.classList.add( "impress-supported" );&#125; 移动端添加meta信息var meta = $( "meta[name='viewport']" ) || document.createElement( "meta" ); meta.content = "width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no"; // 此处用于没有viewport的情况，设置好name并且将该元素放入head中 if ( meta.parentNode !== document.head ) &#123; meta.name = "viewport"; document.head.appendChild( meta ); &#125; 函数防抖var throttle = function( fn, delay ) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout( timer ); timer = setTimeout( function() &#123; fn.apply( context, args ); &#125;, delay ); &#125;; &#125;; // 这样写可以得到正确的this var throttle = function( fn, delay ) &#123; var timer = null; // 这里使用箭头函数可以获得正确的this，调用的时候应该使用普通的函数定义方式，否则无法绑定正确的this return () =&gt; &#123; var context = this, args = arguments; clearTimeout( timer ); timer = setTimeout( function() &#123; fn.apply( context, args ); &#125;, delay ); &#125;; &#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impress.js的可视化编辑]]></title>
    <url>%2F2017%2F10%2F09%2Fimpress-js%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[这只是源于某一天的突发奇想，如果用blockly封装一下impress.js，会不会很有趣呢！演示地址：http://summerscar.me/impress-blockly/Github托管：https://github.com/summerscar/impress-blockly 利用blockly包装impress.jsimpress.js官方简介对于impress.js的官方描述：It’s a presentation framework based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com. 官方示例http://impress.github.io/impress.js/ 使用&lt;div id="its" class="step" data-x="850" data-y="3000" data-rotate="90" data-scale="5"&gt; &lt;p&gt; It’s a &lt;strong&gt;presentation tool&lt;/strong&gt; &lt;br&gt; inspired by the idea behind &lt;a href="http://prezi.com"&gt;prezi.com&lt;/a&gt; &lt;br&gt; and based on the &lt;strong&gt;power of CSS3 transforms and transitions&lt;/strong&gt; in modern browsers. &lt;/p&gt;&lt;/div&gt; impress的使用很简单在div中设置对应的class以及相关的data信息，impress就会对这些dom元素进行初始化确定位置，但是对于这整个过程还是需要对html有基本的了解,于是考虑如果用blockly套个壳会怎么样呢？ 对impress的加工blocklyblockly:简单地说就是把代码封装到积木块中，然后通过积木块的拼接生成代码并运行。 Demo运行说明演示地址：http://summerscar.me/impress-blockly/ 主操作界面 右侧就是blockly的操作界面，通过拖入积木块，运行后在主界面自能直接看到效果，左下角能够修改背景色，同时提供了导入导出功能 工作区内容的导出 工作区内容的导入 运行时，默认是将这段代码直接保存在localstorage中，载入页面时自动加载本地的数据，有了导入导出可以方便创建多个不同工作区 最后虽然实现还比较简陋，但功能基本都实现了，在简单了解了impress后就能后通过这个二次包装的impress很快捷的创建演示应用另外还有个成熟的impress可视化编辑的产品：http://strut.io/]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Blockly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆挖个坑用vue写个bilibili]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%9B%BD%E5%BA%86%E6%8C%96%E4%B8%AA%E5%9D%91%E7%94%A8vue%E5%86%99%E4%B8%AAbilibili%2F</url>
    <content type="text"><![CDATA[好久不写CSS了，之前的项目到后面全都是写JS，趁着这假期写个哔哩哔哩的WEB端。 vue-bilibili预览： http://bilibili.summerscar.com/ 在github上能找到很多类似的DEMO啦，但还是想自己从头写一个，包括前端+后端 技术找 vue + koa2 + es6 + async + scss 因为暂时先写个单页，没用vuex 项目托管：https://github.com/summerscar/bilibli-vue 记录第一天打算是VUE+KOA2来完成前后端，今天先完成准备工作，首页header简单的布局 bilibili网站有很多的图标，但是这些图标都是来自于一张PNG图片上，引用的方式是使用行内元素固定宽高，background-image引用图片，设置background-position得到对应图标。 header的横幅是直接div的background-image引入，position设为center 横幅上方有个高斯模糊的效果，实现方式是在横幅内添加固定高度div引入图片，css设为filter：blur(3px)得到模糊后的图片，在该层上方再叠加一层白色带透明的div盖在模糊的图片上即可实现。（注意：由于模糊的边缘是类似AE中蒙板羽化，所以是个渐变的效果，为了隐藏渐变可以把height稍增加，然后定位把那部分藏起来） 第二天还是在写这个header… 清除浮动：在父元素设置 &amp;:after&#123; content: '.'; clear: both; width: 0; height: 0; display: block; visibility: hidden; &#125; 鼠标的各种hover效果，使用js事件+vue的ref去设置css即可 还有些类似tip的小弹窗，暂时不清楚小箭头怎么弄的，我这边直接把这小弹窗放到该元素的after伪元素中，设置改元素的 div:hoer:after{}来设置显示和消失 有些图片直接用接口的链接访问不到，使用后台代理获取图片然后返回给前端(注意：request的encode设为null否则默认为utf8，同时返回时设置type = ‘image/png’) const router = require('koa-router')()const request = require('request-promise');// 处理传来图片router.get(/^\/image\/dynamic(?:\/|$)/, async (ctx, next) =&gt; &#123; console.log(imageUrl.imgPrefix + ctx.url.split('/').slice(3).join('/')) let image = await request(&#123;url: imageUrl.imgPrefix + ctx.url.split('/').slice(3).join('/'), encoding: null&#125;) ctx.type = 'image/png' ctx.body = image&#125;) 在动态的菜单中有一个下划线跟随li运动的动画我参考了官方的自己尝试下了: li的after伪元素给个小点，ul后面给个1px高的div，定位到点上面，根据点击的index,设置left值以及设置好transition就能实现动画效果 opacity失效的问题：在设置渐入渐出动画时发现同时设置display为none会导致opacity动画失效，将display改为visibility属性即可 伪元素可以使用attr获取元素内的属性值 如： content:attr(‘data-url’) 第三天 block中文本overflow显示省略号（block需定义宽度） &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; header中的各种下拉弹窗可以封装为一个基础组件，里面的ul与btn可以通过slot插入，部分css可以预先在基础组件里写好 z-index属性只对有定位的元素起效（除static）！！！ 文字前图标的简单处理：使用padding-left,再设置backround-image至对应处 轮播图处理为基础组件，props接收数据以及相关参数的设置，通过emit将事件数据传递给父组件（组件也可以定义扩展方法，让父组件调用如：调转至某一index的图片） 第四天 一觉醒来，我的天B站不仅换了头图，连主题都变了，还有这种操作的？？？我猜是这个style属性变了，过几天再确认下！！ 今天比较顺利，越写越顺了，发现个问题blackground-color设为线性渐变只写start和end color时，这个属性会间接性的抽风失效，中间加个stop color就又好了，好奇怪 今天的进度 第五天 没错，一觉醒来头图又换回去了，果然是这个style搞的鬼，我昨天补救的代码也生效了，能自动切换颜色了，23333我tm太机智了 现在问题来了，下面的每个类目看起来差不多，但实际上又根据不同类目有区别，暂时想的是用slot插入或者根据不同的传入数据显示不同的组件 background-clip: border-box|padding-box|content-box; 规定背景的绘制区域： v-for与v-if一起使用时v-for的优先级更高，在v-for的外面包一层div写v-if防止渲染报错 overflow：hidden 在定位元素中，被定位元素的overflow是根据定位的父元素属性来的 文字下方的小三角写法回顾一下 .active &#123; color: $hoverBlue; border-bottom: 1px solid $hoverBlue; &amp;:after &#123; content: ' '; width: 0; height: 0; position: absolute; left: 50%; bottom: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 3px solid $hoverBlue; transform: translateX(-50%); &#125;&#125; 今天挺顺利，完成了三个类目 仔细研究了下，一共有5中不同的视频展示小窗口，分别是顶部的排行，紧跟着下面的推广，直播窗口，中部的各大类视频窗口，最后的推荐窗口，每种都单独做了一个组件 第六天 在父子数据通信上遇到了些问题 当子组件的emit出多个数据时 this.$emit(&apos;custom&apos;, 3, 4);// 父组件中&lt;child @custom=&apos;todo(arguments)&apos;&gt;&lt;/child&gt;methods: &#123; todo () &#123; console.log(arguments) &#125;&#125;// 这样可获取传入的多个参数 当父组件额外传入参数时 this.$emit(&apos;custom&apos;, 1); // 父组件中 第一种方法 &lt;child @custom=&apos;todo($enents, &apos;other&apos;)&apos;&gt;&lt;/child&gt; methods: &#123; todo (index, other) &#123; console.log(index, other) &#125; &#125;// 父组件中 第二种方法（接收传出多个数据时） &lt;child @custom=&apos;todo(arguments, &apos;other&apos;)&apos;&gt;&lt;/child&gt; methods: &#123; todo () &#123; console.log(arguments) &#125; &#125; 事件传递多参数时event事件参数 @click=”do($event, ‘click’)” 获取DOM相对于网页的位置 object.getBoundingClientRect(); Boolean({})与Boolean([])为true 卡在了右侧的排行hover的弹窗，因为这里有个类似轮播图的东西，父元素加了overflow，只能在外面增加一个层定位用来显示信息，通过子组件传递信息到父元素获得数据和位置信息来控制这个层的显示 今天进度(循环渲染真的爽，写好了动画一个类目，然后处理好所有数据一个v-for全出来了) 第7天 事件传对象参数时出了点问题 &lt;li @mouseover="change(&#123;type: 0&#125;)" :class="&#123;active: index === 0&#125;"&gt;全部&lt;/li&gt;&lt;li @mouseover="change(&#123;type: 1&#125;)" :class="&#123;active: index === 1&#125;"&gt;原创&lt;/li&gt; //这样写没问题 change (data) &#123; this.index = data.type === undefined ? this.index : data.type &#125; //但是如果这样写的话执行第二次时data参数就消失了，全都跳过了第一个判断 change (data) &#123; this.index = data.type || this.index &#125; Element.scrollIntoView()可以传参数完成平滑滚动] alignToTop一个Boolean值： 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions一个boolean或一个带有选项的object：&#123; behavior: "auto" | "instant" | "smooth", block: "start" | "end",&#125; 在有背景图并且有透明通道的div上可以设置背景色，但background-color属性要设置在背景图下面 今天出了点事，用的几个第三方接口挂了，然后又去官网抓了官方接口重写了后台 因为后台代理了所有图片，跑在我这台电脑上速度还行，挂到阿里云的一兆水管上，图大多GG，然后试着上个redis会不会好点 第8天 整理一下数据接口，完成了各分类的新动态和新投稿的切换 部署到服务器，顺便临时升了下带宽，图片能够陆续正常加载了 刚刚遇到一个很奇怪问题父组件对象的属性更新了，子组件却不更新数据（官方文档上说是对象属性的增加或删除会检测不到变化，而且我这个变化连watch deep都检测不到，见鬼了，这个组件还有个和这个变量一个类型的，同样改属性值却能刷新DOM，简直见鬼了！！！这个变量是掉进异次元了么），试了好几个办法 this.$forceUpdate()完美成功 虽然官方有个this.$set，但文档上说的是在对象的添加或删除时使用，而且在这里我用了这个重设属性值竟然也无效 使用Object.assign创建新对象并整个赋值，能刷新DOM，但是会导致刷新整个DOM（相当于整个数据从null到恢复数据，DOM整个都在闪啊我的天） 现在还剩右侧电梯的排序,动漫时间线,弹幕和预览功能没写]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中导航栏CSS的维护]]></title>
    <url>%2F2017%2F09%2F29%2FVue%E4%B8%AD%E5%AF%BC%E8%88%AA%E6%A0%8FCSS%E7%9A%84%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[vue中对于导航链接自动会对激活的链接添加route-active的class，但是在第三方ui组件中需要另外的维护方式。 vue中导航样式的维护原生的维护方式在对需要的元素添加后，vue会自动对该元素添加route-active的class，写上对应的css即可 第三方UI组件中UI组件中路由跳转的特点 在UI组件中，路由的跳转都是使用事件触发路由的编程式路由来导航 激活的CSS使用UI组件的自带样式，不建议再写route-active这个class的样式 UI组件中导航样式的激活是基于标签中一条active-name属性（以iview为例）来确定激活的对应目标 使用route.path来维护要确保样式能在各种情况下正确激活需要在路由发生变化是实时获取对应的path &lt;Menu :active-name="activeKey" @on-select="show" &gt; &lt;Menu-group title="基础管理"&gt; &lt;Menu-item name="/basManage"&gt; &lt;Icon type="document-text"&gt;&lt;/Icon&gt; 机柜信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/baseDevice"&gt; &lt;Icon type="android-list"&gt;&lt;/Icon&gt; 设备信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/baseUser"&gt; &lt;Icon type="android-document"&gt;&lt;/Icon&gt; 用户信息管理 &lt;/Menu-item&gt; &lt;Menu-item name="/basManage/basePort"&gt; &lt;Icon type="android-document"&gt;&lt;/Icon&gt; 端口信息管理 &lt;/Menu-item&gt; &lt;/Menu-group&gt; &lt;/Menu&gt; 使用一个变量来绑定active-name，之前是在这个单个VUE文件中分别在mounted和menu-item触发时获取path并赋值，但后来发现如果在route-view中使用了keep-alive，mounted这个钩子函数会失效，也就会到时在切换页面时，获取不到正确path. 于是在看在官方的文档后发现$route变量是能够watch的,直接可以在main.js中watch这个route，然后将path维护在Vuex中，然后分发到需要使用的单个VUE文件中 //main.js中mounted () &#123; this.$store.commit('setPath',this.$route.path)&#125;,watch: &#123; $route () &#123; this.$store.commit('setPath',this.$route.path) &#125; &#125; //单个vue组件中 computed: &#123; activeKey () &#123; return this.$store.getters.getPathState &#125; &#125; 这样在每次path变化时都能够的到正确的path，这样也就能激活对应的css了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半个多月终于走完了一条线-美少女万华镜4]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%A7%90%E5%BC%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E7%A6%81%E6%96%AD%E4%B9%8B%E6%81%8B-%E7%BE%8E%E5%B0%91%E5%A5%B3%E4%B8%87%E5%8D%8E%E9%95%9C4%2F</url>
    <content type="text"><![CDATA[距上次接触完全是日文的作品已经快过去半年了（期间忙于准备N1考试和其他事情去了），上次看的是《騎士団長殺し》不过很可惜，最后也没搞懂村上春树想表达什么，感觉我等渣渣还是不适合看这种很隐晦的书( ；o；)、正好7月份的N1也过了，终于可以看些轻松的东西了，也正好赶上这个评价很高的游戏发布,开学后就断断续续玩了半个多月…… 谁的鸡儿都别想放假 【手动狗头】 美少女万华镜4人物介绍 男主： 觋 夕摩 双胞胎 女主： 觋 夕莉 双胞胎 一花： 同学 镜子： 同学 老师 男主母亲 男主父亲又称绿帽侠 男主舅舅即亲生父亲（母亲的弟弟） 剧情 直接讲其中的true end剧情，首先要有个心理准备，男主是一个可以说奥斯卡影帝级别的人物，心机很可怕！！游戏中是倒叙，我这直接顺叙 母亲与舅舅两情相悦，玩禁断之恋怀上孩子，为了家族名誉找来绿帽侠男主父亲来接盘，但是明显母亲并不喜欢这个绿帽侠，然后没办法只能把自己的爱倾注在自己的儿子身上（不喜欢自己女儿），但是自己女儿很喜欢和男主玩，母亲为了把女儿支开，让女儿搬出去做艺人，然后绿帽侠照顾女儿（女儿其实知道这一切，对母亲很反感），在那段时间里母亲就把男主当做他的弟弟一样（不可描述那种），弟弟就对自己的父母以及她的弟弟十分憎恶。直到有一天女儿向母亲坦白了一切并威胁母亲，于是母亲很伤心决定上吊自杀，但是在上吊挣扎时绳子不小心断了，于是儿子上去补了一刀（掐死了，完成了母亲的复仇），然后为了毁尸灭迹把自家房子烧了。工作回来的父亲看到这一切，把一切都归罪于母亲溺爱的儿子（其实这里绿帽侠没错，但是女主一直以为是自己的过错），十分厌恶男主，男主为了逃离这个地方于是装疯卖傻，被父亲送到了精神病院，至此故事到一段落。 儿子在精神病院故意讨好护士们，很快得到了可以出院的许可，儿子便联系了自己的亲生父亲，让他把自己弄出去，但此时儿子是非常痛恨亲生父亲的，把自己的罪过全部交给了绿帽侠，导致母亲还对自己做那种事情，于是就出现了游戏开场的一幕，儿子配合他的秘书把他需要注射的药物给替换了，在他和儿子去祭拜母亲时，病情发作了，GG，男主完成复仇。接下来自己假借亲生父亲的名义，找到女主，顺理成章住到了女主和绿帽侠家里。进入了游戏真正的开场。 男主住到女主家后利用女主上学的时机偷偷跑去女主房间做羞羞的事，后被女主抓了现行，此时女主各种抖S，男主自然也就装作抖M，在日常中玩各种羞耻PLAY（一起买上学的衣服的时候玩优衣库那种的）。某一天女主提议和男主一起去学校，男主也同意，毕竟有能呼风唤雨的姐姐在还怕啥，男主在学校认识了一花和镜子，还有保育处的老师，男主听一花说和这个老师有接触的人会遭遇不幸，同时男主还在一花面前刷了波好感。一天男主和女主社团活动结束后发现手机丢在学校了，就回去拿手机，于是在这过程中惊讶的发现，镜子和老师存在特殊关系。 一天男主身体不舒服，在女主建议下去老师那检查下，然后这剧情就厉害了，男主就算是奥斯卡影帝也没想到老师直接下药夺走了男主的贞操，还录了像，后来还向男主坦白她的真正目标是女主。男主对此事感到悲痛欲绝，甚至想去自杀，但并没有把此时对任何人公开，女主意识到男主的不正常行为后各种安慰，也意识到老师应该是对弟弟做了什么，便假装成男主去校园陷害老师（传绯闻，后遭老师非礼，却发现是女儿身并非男主）。于是老师暂时出局。男主为了保护女主不停女主劝阻要去学校（自己的贞操都没保住，还想着保护女主，小伙子很厉害啊）。然后又是一段很长的日常，女主还在文化祭cos成MIKU和男主玩羞羞的事。这段日常过去后剧情进展就快多了。 一日，一花跑来向男主告白，这里有个分支，当然是选择拒绝（同意的话，剧情会很惊悚男主最后会把女主推下 站台，被车撞死…）拒绝之后剧场正常发展下去，这时候老师又跑来刷存在找来镜子下个套把女主叫出来，同时让镜子去男主家拖住。镜子一各种借口来到男主房里，这里又有分支了，当然是选择拒绝啦（同意的话据说是有一段神奇的发展 你懂得）。在男主说了一通大道理之后，镜子醒悟带男主去找女主。此时女主正和老师对峙，老师威胁女主要把男主的片公开，然后女主并没有惧怕，反而威胁老师公开后受影响的还是老师，男主是我的，不会给你的，于是拔出刀割了自己手腕，老师受惊退场。男主前来救场，安慰女主。后面男女主与镜子决裂，接着又是一段愉快的发展~~。 一天女主有事提前回家，其实之前男主早已打过算盘，男主早晚是要干掉对自己深恶痛绝的绿帽侠的，他在父亲每天的酒中下药，希望某一天父亲对女主做出鬼父的行为后，借女主之手杀掉绿帽侠。于是这天来了，男主当然计划通，一切顺利进行后，男主回来安慰女主，让女主求得心理安慰。接下来当然是一段二人世界的愉快发展~~ 后来男主发现绿帽侠还在苟延残喘，果断又补了一刀（小伙子厉害啊，明白补刀的重要性啊） 但是因为绿帽侠工作上的原因，各种电话打来，女主也疲于应对想去找他们的亲生父亲，但是联系不上（早就被男主做掉啦），这时候男主又机智的站出来了（此时女主与开局高高在上的形象天差地别了），他拿出了早已准备好的机票谎称是亲生父亲留他们的，然后女主如释重负，果断和男主出国过着没羞没臊的生活，并且剩下一对龙凤胎！！！ 没错又是姐弟～～ 结 这个游戏副标题《罪与罚的少女》 ，但整个剧情就是男主自导自演（除了那段被老师强上，男主自己也是郁闷，千算万算没算到还有这种操作），男主的一切罪过（杀了母亲，亲生父亲，绿帽侠），最后的锅全是女主姐姐背。虽然开始女主的形象塑造得很好，最后却成为了炮灰（好惨呀）…在这最后又生下一对姐弟，又是一段轮回？ 这剧情倒是有些像《白夜行》，但是东野圭吾对唐泽雪穗的刻画当然更加深刻，看完真的是能够被震撼到，游戏中剧情并没这么带感（游戏中是倒叙并非上面的顺叙！！），尽管后面男主的翻转很炫酷其实感觉也就那样吧。 画风很棒，音乐也很优雅（这真的没得黑），特效很棒很生动（都快成3D的感觉了，我的天），就是男主的女装大佬形象我略难以接受..反正就当做看一本小说来玩玩，最后还积累了5，6页的生词，我也是棒棒哒~~~ 最后上个隐藏的启动图]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又迷上了一个女神excited！]]></title>
    <url>%2F2017%2F09%2F25%2F%E5%8F%88%E8%BF%B7%E4%B8%8A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A5%B3%E7%A5%9Eexcited%EF%BC%81%2F</url>
    <content type="text"><![CDATA[映画『打ち上げ花火、下から見るか？横から見るか？』主題曲 打上花火循环了一星期了，这首歌真是 聴けば聴くほど楽しむ，也很期待电影上映呀！ 9-25 21：30更新话说今天这事也太邪门了吧，这篇博客是25号上午9点37分创建（还顺便逃了早上的课），10点差不多整理完，然后下午1点多微博上出现了这个视频 ，然后因为原po的这个视频，还上了日本yahoo的新闻 (25号18：39分发布)，当然这还没结束，当我打开网易云音乐打开今日推荐，惊讶的发现最后一首歌竟然就是下面VOICE的初音版 (´ºωº｀)总之感觉今天真tm神奇~~~下面还是回到正题~ 打上花火 官方MV 下面的视频都要过墙了才看得到了 然后很好奇得去youtube搜了搜翻唱，意外的发现了这个拉二胡的小姐姐Ayasa，2333333333 打上花火 Ayasa 然后看到评论说Ayasa还参演过大法的CM( 小姐姐厉害了呀 ヽ〔ﾟДﾟ〕丿ｽｺﾞｲ ),看到这我就不淡定了，作为一个索粉（索狗）很激动的搜索了一番，果然找到了啦，这MV简直 excited！！！ prprprprprpr Voices feat.Ayasa 然而这个还是feat版本，那原版呢？ Voices Voices feat.MIKU 于是又找到了原曲，我的天，这个我看过呀！！！去年某一天就在微博上看过这个MIKU和SONY合作的视频（曾经还又去找过，还没找到），然后今天又找回来了！！！ EXCITING!!! 不多说了，loop start ！ 另外附上另一个女神]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket打造简易聊天室]]></title>
    <url>%2F2017%2F09%2F21%2Fwebsocket%E6%89%93%E9%80%A0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[这两天看了下关于websocket方面的东西，现代浏览器基本都支持websocket,这样可以很方便实现双向的通信。然后简单写了一个聊天室 简单说明下websocket与http，个人理解两者都是在传输层TCP之上的实现方式。HTTP是客户端向服务器发送请求，服务器接收到请求，然后回应客户端，发送数据，但是服务器端不能够主动发送请求让客户端接受信息，这时候，就需要websocket了。简单地说，区别就是服务器端能主动与客户端通信。 websocket简单入门廖雪峰的websocket教程介绍了websocket的基本使用方法 socket.iosocket.io是对websocket的一层封装，准确的说还加入了ajax功能，帮助不支持websocket的浏览器实现接近websocket的功能 聊天室的实现有了socketio，就能够很方便实现，数据的分发，然后这里使用的是koa2作为后台。 socketio事件处理部分io.attach( app )io.on('connection', (ctx, data) =&gt; &#123; let room = url.parse(ctx.socket.request.headers.referer).pathname.substr(1); logger.info(`a user connected to room: $&#123;room&#125;`) ctx.socket.on('join',(username) =&gt; &#123; console.log(username) ctx.socket.join(room); if (!userObj[ctx.socket.id]) &#123; userObj[ctx.socket.id] = username &#125; if (!roomObj[room]) &#123; roomObj[room] = [] roomObj[room].push(ctx.socket.id) &#125; else &#123; roomObj[room].push(ctx.socket.id) &#125; io.broadcast( 'message', &#123;user:'系统',content:`欢迎 $&#123;username&#125; 进入房间 $&#123;room&#125; 当前在线人数：$&#123;io.connections.size&#125;`&#125; ); io.to(room).emit( 'message', &#123;user:'系统',content:`欢迎 $&#123;username&#125; 进入了该房间 该房间人数$&#123; roomObj[room].length&#125;`&#125;); &#125;);&#125;);io.on('disconnect',(ctx, data) =&gt;&#123; logger.warn(`user: $&#123;userObj[ctx.socket.id]&#125; disconnected`); io.broadcast( 'message', &#123;user:'系统',content: `用户 $&#123;userObj[ctx.socket.id]&#125; 下线了`&#125;); for (let item in roomObj) &#123; if (roomObj[item].indexOf(ctx.socket.id) &gt;= -1) &#123; roomObj[item].splice(item.indexOf(ctx.socket.id), 1) &#125; &#125; delete userObj[ctx.socket.id]&#125;);io.on('message', (ctx, data) =&gt; &#123; let rooms = [] for (let item in ctx.socket.rooms) &#123; rooms.push(item) &#125; logger.info('receive a message ' + data); io.to(rooms[0]).emit( 'message', &#123;user:userObj[ctx.socket.id],content:data&#125;);&#125;); 处理socket的事件，并且维护用户列表以及房间的用户列表 聊天室前端部分app.use(require('koa-static')(__dirname + '/public'))router.get('/:roomid', async (ctx, next) =&gt; &#123; const readFile = promisify(fs.readFile) try &#123; let ret = await readFile(__dirname+'/public/room.html', 'utf8') ctx.body = ret; &#125; catch (err) &#123; console.log(err) ctx.throw(500, err) &#125;&#125;);app.use(router.routes(), router.allowedMethods()) 前端部分就两个页面 一个是首页，直接使用koa-static实现，房间页面通过路由匹配发送给客户端。 项目托管地 实现效果]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[micro:bit上手]]></title>
    <url>%2F2017%2F09%2F13%2Fmicro-bit%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一个块好厉害的小板子呀，刚到手就在淘宝买了一堆的东西,等快递的两天，看了遍官方block的reference，大概想了一下然后画了张图，最后觉得感觉自己应该想太多了…其实用芯片本身做点东西就够了…9.19更新我的小车车已经能跑起来啦~~~ 一些脑洞小车var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/car.mp4"}}); 本身自带的传感器电子罗盘给个箭头指向北方,然后就成了个指南针 var dplayer1 = new DPlayer({"element":document.getElementById("dplayer1"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/compass.mp4"}}); 不过好像电池对传感器有一定的影响，用usb线就没错乱问题 亮度内置的亮度传感器，好像是亮光照在led上才有反应，而且灵敏度不高 var dplayer2 = new DPlayer({"element":document.getElementById("dplayer2"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/light.mp4"}}); 蓝牙蓝牙这个..额..真心不太懂，试了下block的几个功能，然后google play上下了几个demo app玩了玩 设备远程控制用官方的device类别下的几个block做了个手机的音乐播放控制 var dplayer3 = new DPlayer({"element":document.getElementById("dplayer3"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/remotecontrol.mp4"}}); Gamepad设备这个是google上的一个demo app，可以控制device中的gamepad var dplayer4 = new DPlayer({"element":document.getElementById("dplayer4"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/gamepad.mp4"}}); 哦对，这个留着，我要试着用这个控制我的小车！！！！ 另外，还有个蓝牙的uart，好像类似于串口通信，不太清楚具体怎么用(google play有个对应的uart应用试了下数据传输，好像和串口没啥区别，不过是无线的啦) serial串口用串口可以直接有线通信啦，正好不会用蓝牙，有了这个就厉害啦 我用的win7,需要装个驱动，不过我这边好像网页装了扩展也没见数据，还是下个调试助手算了 读取传感器信息通过node-red读取microbit的传感器信息做个ui界面 var dplayer5 = new DPlayer({"element":document.getElementById("dplayer5"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/serial.mp4"}}); 这里的node-red跑树莓派上的，后面打算 -&gt; 树莓派 + microbit + 小车 = ？ 来创作音乐？其实那天拿到这个，就对block里面那个music很感兴趣，昨天买的一堆东西到了，立刻就试着搞了下这个 var dplayer6 = new DPlayer({"element":document.getElementById("dplayer6"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/music.mp4"}}); microbit接上我的电脑，用Arduino的一个串口助手，里面正好有一个键盘模式（按下key直接发送串口数据，不过只有13个键），然后microbit检测到对应数据发出对应的音就行了 树莓派的noder-red里面也有个键盘输入的节点,搞个树莓派+node-red+microbit,就能输出所有的音了吧..不过这样太ZZ了 Pins这个外接设备那就无限多啦，但我并不是很懂那些传感器啦，等下还要研究下怎么控制步进电机 光敏传感器之前用树莓派只能读取数字信号，这个貌似数字模拟都能读取，然后直接反馈到LED上啦 var dplayer7 = new DPlayer({"element":document.getElementById("dplayer7"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"http://ojlntnyzt.bkt.clouddn.com/microbit/pinlight.mp4"}}); 最后如果把这些搞下混搭的话…enmmmm….大概都上顶上那张图，然后… 昨天刚搞了辆小车，好不容易装完发现还少个电机驱动板 (T_T) 先放着吃两天灰吧，先想想用这板子能在这车上玩出什么神奇的操作]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node小爬虫]]></title>
    <url>%2F2017%2F09%2F08%2Fnode%E5%B0%8F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[至于为什么突然想写个爬虫…额…只是突然发现了这个老司机网站,看到这么整齐的布局，忍不住想把数据爬下来 一个不可描述的爬虫node.js一般爬虫都是python,但我不会呀，所以还是用node了，还是第一次接触node的爬虫，有点小激动 依赖根据自己已知的+搜索来的确定了基本上是这几个依赖 cheerio 相当于后台的jquery，第一次尝试了下这个模块，简直是写爬虫必备呀，excited! moment 记录下时间用 request 请求网站数据 fs 处理文件 代码部分const http = require('http')const fs = require('fs')const cheerio = require('cheerio')const request = require('request') const moment = require('moment')const arguments = process.argv.splice(2);const url = 'http://www.cilikankan.net/fengmian/'let textData = '车牌,热度,日期,图片链接,下载链接'getImage(arguments[0] || 1);function getImage (page) &#123; request(`$&#123;url&#125;index_$&#123;page&#125;.html`, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; const $ = cheerio.load(body) const items = $('.item ') for (let i = 0; i &lt; items.length; i++) &#123; let title = items[i].children[1].children[1].children[1].attribs.title let targetSrc = items[i].children[1].attribs.href let src = items[i].children[1].children[1].children[1].attribs.src let date = items[i].children[1].children[3].children[1].children[3].children[0].data let heat = items[i].children[1].children[3].children[1].children[6].children[0].data.substr(3) textData += `\r\n$&#123;title&#125;,$&#123;parseInt(heat)&#125;,$&#123;date&#125;,$&#123;src&#125;,$&#123;targetSrc&#125;` let imgName = `./images/$&#123;heat&#125; $&#123;title&#125; $&#123;page&#125;.jpg` request(src).pipe(fs.createWriteStream(imgName)) &#125; &#125; fs.writeFile(`./开车时间：$&#123;moment().format('MM-DD')&#125; page：$&#123;page&#125;.csv`, textData, (err) =&gt; &#123; if(err) &#123; return console.log(err); &#125; console.log("写入完成。"); &#125;) &#125;)&#125; 执行方法npm start 'page' 可以尽情飙车了]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咕咕机-一台有趣的打印机]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%92%95%E5%92%95%E6%9C%BA-%E4%B8%80%E5%8F%B0%E6%9C%89%E8%B6%A3%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前些天看到了这个咕咕机，看起开很有趣，就搞了台玩玩，昨天刚到，也就是上手简单玩了一天 更新： 前阵子直接在node-red平台上封装了这个API，可以直接安装这个节点使用了，不需要调用后台了,机智如我node-red-contrib-memobirdtext PS：昨天七夕，店家还送了很多虐狗的东西，而且官方宣传这小东西都是 情侣，传纸条 ？？ 是我对这东西理解错了么（手动黑人问号） 开箱 差不多一只手的大小，可连接WIFI也可切换本地模式，连接手机热点，打印是会发出“咕~咕~”的声音~~用的是热敏纸，4卷19rmb，还好吧，才买回来24小时不到，一卷纸快被我打完了 官方APP官方APP就不多说了，总之很方便，一键打印APP里各种内容，还有很多网友分享的，总之很丰富。很多模板也很有用，但这些以后再说啦~ 官方API当然我的感兴趣的重点是官方的打印API啦，发了封邮件40分钟就回了，很顺利拿到了appkey 虽然NPM上也有一些别人写的封装API，但看了看官方的文档，一个就仨接口，干脆自己撸算了,直接写在了koa里做个后台github.memobird-api 咕咕机类//post请求 getData (url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data) .then((res) =&gt; &#123; if (res.data.showapi_res_code === 1) &#123; console.log('异步请求ok') resolve(res.data) &#125; else &#123; console.log('失败! 原因：', res.data.showapi_res_error ) reject(res.data) &#125; &#125;) &#125;) &#125; //初始化，绑定用户 async init () &#123; this.initRes = await this.getData(url.account, this.config) &#125; //打印文字功能 async printText (content) &#123; console.log('printText开始') let Content = `来自node平台 $&#123;content&#125; $&#123;moment().format('YYYY-MM-DD HH:mm:ss')&#125;` let print = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, memobirdID: this.config.memobirdID, userID: this.initRes.showapi_userid, printcontent: `T:$&#123;iconv.encode(Content, 'gbk').toString('base64')&#125;` &#125; return await this.getData(url.print, print) &#125; //打印图片功能 async printImg (path) &#123; console.log('printImg开始') let Content = `T:$&#123;iconv.encode('来自node平台', 'gbk').toString('base64')&#125;|$&#123;await this.encodeImg(path)&#125;|T:$&#123;iconv.encode(moment().format('YYYY-MM-DD HH:mm:ss'), 'gbk').toString('base64')&#125;` let print = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, memobirdID: this.config.memobirdID, userID: this.initRes.showapi_userid, printcontent: Content &#125; return await this.getData(url.print, print) &#125; //处理图片encodeImg (path) &#123; return new Promise((resolve, reject) =&gt; &#123; gm(path).resize(384).flip().type('Bilevel').colors(2).toBuffer('bmp', (error, buffer) =&gt; &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(`P:$&#123;buffer.toString('base64')&#125;`); &#125; &#125;); &#125;) &#125; //循环检测是否打印完成 async status (id, time) &#123; let times = 1 let printflag = 0 let status = &#123; timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), ak: this.config.ak, printcontentid: id &#125; do &#123; await this.timeOut(time) let res = await this.getData(url.status, status) printflag = res.printflag console.log(`开始检测 第$&#123;times&#125;次 延时$&#123;time&#125;ms $&#123;printflag === 1 ? '打印完成' : '打印未完成'&#125;`) times++; if(times === 6) break &#125; while (printflag !== 1); return printflag &#125; //延时 timeOut (time = 3000) &#123; return new Promise((resolve, reject) =&gt; &#123; let timer = setTimeout(() =&gt; &#123; resolve('延时完成') &#125;, time) &#125;) &#125; 后台API接口这边简单的功能写好了，然后在router里面写个接口就行了//router接口router.post('/printText', async (ctx, next) =&gt; &#123; const memobird = new Memobird(&#123;ak: '',memobirdID: '',useridentifying: ''&#125;) ctx.body = &#123;code:1&#125; memobird.init() .then(() =&gt; memobird.printText(ctx.request.body.content)) .then( res =&gt; memobird.status(res.printcontentid, 3000)) .then(printflag =&gt; &#123; console.log('检测完成',printflag === 1 ? '打印完成' : '打印未完成') &#125;) .catch((err) =&gt; &#123; console.log(err) ctx.body = err &#125;)&#125;)router.post('/printImg', async (ctx, next) =&gt; &#123; const memobird = new Memobird(&#123;ak: '',memobirdID: '',useridentifying: ''&#125;) ctx.body = &#123;code:1&#125; memobird.init() .then( res =&gt; memobird.printImg(ctx.request.body.content)) .then( res =&gt; memobird.status(res.printcontentid, 3000)) .then(printflag =&gt; &#123; console.log('检测完成',printflag === 1 ? '打印完成' : '打印未完成') &#125;) .catch((err) =&gt; &#123; console.log(err) ctx.body = err &#125;)&#125;) 这样后台基本写完了，然后需要调用接口啦 神器node-red之前一个大佬和我说了这个，试着玩了下，总之超牛逼的一个东西，完全的可视化编程，往下看就知道了 建几个定时任务 一言一言API 通过inject，建立定时任务，会定时触发后面的get请求,然后处理好返回的数据，然后发送post请求到我的后台服务器 这里function模块处理返回的数据，然后post请求到我的后台服务器 天气预报和风天气API这个也是一样啦，inject设定两个固定时间的触发，处理好请求地址，获取数据，处理发送给后台的数据 其他任务当然还有很多有趣的模块，email模块尝试了下qq和163总有些小问题，还有teitter，facebook的模块但有堵墙，最最重要的！！！这个个物联网的可视化平台，是用来监测硬件的（很可惜，我手上没这些东西，到时候搞个树莓派玩玩），任何监测信息都可以直接连接这台小打印机，直接打印输出！！！ UI部分node-red还带一个ui界面两条简单的流程图，text输入后触发post请求到后台就行啦 生成的前端页面 效果以下效果都是通过node后台打出来的，自带APP打出来的总体要美观很多啦 后期其他功能现在只能文本，图片分开来打印，过些天我试下多项内容的打印功能]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由相关]]></title>
    <url>%2F2017%2F08%2F23%2FVue%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[最近看了很多很杂的东西，有点乱，大概整理下 路由路由参数获取通过在路由中定义：param的形式 获取路由匹配参数 this.$route.params.param 路由跳转带参数的地址时，获取参数 this.$route.query.param 跳转 //这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。this.$router.go() 命名路由&lt;router-link :to="&#123;name:'index'&#125;"&gt;&lt;/router-link&gt;//需要参数时&lt;router-link :to="&#123;name:'index'，params:&#123;param:'123'&#125;&#125;"&gt;&lt;/router-link&gt; 命名视图&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name="title"&gt;&lt;/router-view&gt;&lt;router-view name="img"&gt;&lt;/router-view&gt; //路由中定义&#123; path:'/', name:'index', components: &#123; default:Index, title:Title, img:Img &#125;&#125; 路由向组件传参const User = &#123; props: [&apos;id&apos;], template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125; // 对于包含命名视图的路由，你必须分别为每个命名视图添加props选项： &#123; path: &apos;/user/:id&apos;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 传参为方法 const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) axios的传参问题axios的get与post传数据的区别 get请求默认为为params，是跟在地址后面的查询字符，在node中从request.query中 axios.get(&apos;url&apos;,&#123;params: obj&#125;) post请求默认为dara，是提交的数据，在node中从request.body中 axios.post(&apos;url&apos;,obj) axios源码：export default &#123; post(url, data) &#123; return axios(&#123; method: 'post', url: config.api + url, data: qs.stringify(data), timeout: config.timeout, headers: &#123; 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125; &#125;).then(checkStatus).then(checkCode) &#125;, get(url, params) &#123; return axios(&#123; method: 'get', url: config.api + url, params, timeout: config.timeout, headers: &#123; 'X-Requested-With': 'XMLHttpRequest' &#125; &#125;).then(checkStatus).then(checkCode) &#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs后台运行]]></title>
    <url>%2F2017%2F08%2F19%2Fnodejs%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在服务器linux环境下让nodejs后台运行 nohup在LINUX中我们可以使用这种简单的方式让node.js在后台运行： nohup node your_app.js &amp; pm2运行pm2 start app.js 查看运行状态pm2 list 追踪资源运行情况pm2 monit 查看日志pm2 logs 重启应用pm2 restart appId 停止应用pm2 stop app.js 开启api访问pm2 web//浏览器访问http://localhost:9615 foreverforever的安装：npm install forever -g forever的用法：使用forever启动守护进程：forever start your_app.js 关闭守护进程：forever stop your_app.js 重启守护进程：：forever restart your_app.js 如果需要记录输出日志和错误：forever start -l forever.log -o out.log -e err.log your_app.js 查看正在运行的程序：forever list]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr东京VPS搭建SSR+BBR]]></title>
    <url>%2F2017%2F08%2F09%2Fvultr%E4%B8%9C%E4%BA%ACVPS%E6%90%AD%E5%BB%BASSR-BBR%2F</url>
    <content type="text"><![CDATA[最近之前买的55总是抽风，大晚上用不了，一怒之下搞了台vultr的VPS试试搭建SSR 注册 注册个vultr账号 http://www.vultr.com/ 注册paypal有张开了网银的银行卡就能顺利注册 充值 购买VPS选择Debian 7（方便后面安装ssr,bbr,锐速等） 其他选项默认 然后点击Deploy now 了解主机相关信息这就是购买的主机了 需要知道这三个信息 IP Address Username Password 使用putty通过SSH连接VPS填上上一步中显示的IP后OPEN连接 输入用户名和密码，有如上显示则连接成功 安装SSR(可直接安装SSR多用户版见下方)wget http://soft.paozailushang.com/vps/SSR.sh &amp;&amp; chmod +x SSR.sh &amp;&amp; ./SSR.sh 2&gt;&amp;1 | tee ssr.log 复制后在shell终端中右击则会复制，回车即可按步骤输入密码和端口后回车等待完成根据这个配置填写SSR客户端即可正常连接使用 安装谷歌BBR加速 （Debian 8直接安装下方魔改版）wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 使用方法和上步一致，最后会提示是否重启，y重启输入开启bash bbr.sh start 如果看到有 tsunami 就表示开启成功！sysctl net.ipv4.tcp_available_congestion_control SSR配置 http://www.zhouxuanyu.com/381.html 修改ssr配置 vi /etc/shadowsocks.json 一般情况下只需要修改以下五项即可：&quot;server_port&quot;:8388, //端口&quot;password&quot;:&quot;password&quot;, //密码&quot;protocol&quot;:&quot;origin&quot;, //协议插件&quot;obfs&quot;:&quot;http_simple&quot;, //混淆插件&quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方式 多端口配置如果要多个用户一起使用的话，请写入以下配置：&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_ipv6&quot;: &quot;[::]&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;80&quot;:&quot;password1&quot;, &quot;443&quot;:&quot;password2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;protocol&quot;: &quot;auth_sha1_compatible&quot;, &quot;protocol_param&quot;: &quot;&quot;, &quot;obfs&quot;: &quot;http_simple_compatible&quot;, &quot;obfs_param&quot;: &quot;&quot;, &quot;redirect&quot;: &quot;&quot;, &quot;dns_ipv6&quot;: false, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 按照格式修改端口和密码：&quot;port_password&quot;:&#123; &quot;80&quot;:&quot;password1&quot;, //端口和密码1 &quot;443&quot;:&quot;password2&quot; //端口和密码2 &#125; 如果要为每个端口配置不同的混淆协议，请写入以下配置：&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_ipv6&quot;:&quot;::&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8388&quot;:&#123;&quot;protocol&quot;:&quot;auth_simple&quot;, &quot;password&quot;:&quot;abcde&quot;, &quot;obfs&quot;:&quot;http_simple&quot;, &quot;obfs_param&quot;:&quot;&quot;&#125;, &quot;8389&quot;:&#123;&quot;protocol&quot;:&quot;origin&quot;, &quot;password&quot;:&quot;abcde&quot;&#125; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;protocol&quot;: &quot;auth_sha1_compatible&quot;, &quot;protocol_param&quot;: &quot;&quot;, &quot;obfs&quot;: &quot;http_simple_compatible&quot;, &quot;obfs_param&quot;: &quot;&quot;, &quot;redirect&quot;: &quot;&quot;, &quot;dns_ipv6&quot;: false, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 协议文档 http://www.zhouxuanyu.com/384.html 多用户脚本好像相关东西都从github上删了，过段时间再查查 https://www.zhujiboke.com/2017/03/278.htmlwget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh 魔改版BBR （Debian 8 和Ubuntu16 +） https://www.zhujiboke.com/2017/07/589.htmlwget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 重启完成后，运行bash bbr.sh start 即可启动魔改版BBR。查看魔改BBR状态运行命令sysctl net.ipv4.tcp_available_congestion_control 如果看到有 tsunami 就表示开启成功！]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue音乐WebApp开发知识点整理]]></title>
    <url>%2F2017%2F08%2F07%2FVue%E9%9F%B3%E4%B9%90WebApp%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理中… https://github.com/summerscar/vue-music data与props 属性会赋予getter与setter，数据变化时会被观测并更新 其他地方创建的属性值不会被检测 watch/computed的属性值需要在props或data中定义 歌手的类的使用歌手信息通过一个类来实现歌手对象的建立 歌曲类的工场方法歌曲对象的创建通过一个工厂函数传入对象，返回一个歌曲对象来创建 数据到DOM变化的间隔约20ms从数据更新到DOM刷新约1/60秒，设置约20ms对DOM进行操作 点击延迟插件 fastclick消除移动端点击的300ms延迟 betterscroll 插件主要用于移动端滚动，需要以后实际使用 数组迭代方法中（foreach）ruturn无效 用for代替foreach迭代方法中使用ruturn并不能跳出迭代，仍会遍历所有的元素，需要使用for循环 CSS 定位 left top right bottom css使用定位 fixed 或 absolute，left top right bottom设为0 可以 铺满屏幕 若元素存在widtn或height,可以使用margin: auto 进行居中 vuex 在组件中的映射mutaion的映射import {mapMutations} from ‘vuex’ methods中定义...mapMutations(&#123; fuName: &apos;commitName&apos; &#125;)//即可调用this.fuName进行mutation提交 getters的映射 import {mapGetters} from ‘vuex’ computed: &#123; ...mapGetters([ &apos;getters中方法名&apos; ]) &#125; actions action的定义形式 actions: &#123; increment (&#123; commit &#125;, param) &#123; commit(&apos;mutationName&apos;, param) &#125;&#125; 在组件中的映射...mapActions(&#123; add: &apos;increment&apos; // 映射 this.add() 为 this.$store.dispatch(&apos;increment&apos;) &#125;) watch//watch可获得的参数value(newVal, oldVal)&#123;&#125; 数组间的简单拷贝（引用类型）let _arr = arr.slice() Vue的Mixins混合 https://cn.vuejs.org/v2/guide/mixins.html#基础 混合方式同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用var mixin = &#123; created: function () &#123; console.log(&apos;混合对象的钩子被调用&apos;) &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log(&apos;组件钩子被调用&apos;) &#125;&#125;)// -&gt; &quot;混合对象的钩子被调用&quot;// -&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。var mixin = &#123; methods: &#123; foo: function () &#123; console.log(&apos;foo&apos;) &#125;, conflicting: function () &#123; console.log(&apos;from mixin&apos;) &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log(&apos;bar&apos;) &#125;, conflicting: function () &#123; console.log(&apos;from self&apos;) &#125; &#125;&#125;)vm.foo() // -&gt; &quot;foo&quot;vm.bar() // -&gt; &quot;bar&quot;vm.conflicting() // -&gt; &quot;from self&quot; 搜索节流用一个延迟函数代理方法的执行。原理：执行前检查是否存在定时器，有则清空并重新设置 export function debounce(func, delay) { let timer return function (...args) { if (timer) { clearTimeout(timer) } timer = setTimeout(() =&gt; { func.apply(this, args) }, delay) } } 防止子组件的点击冒泡在组件中直接设置 ```@click.stop` 后面为空即可 state中数据的初始化state中的数据初始化可以在通过函数进行赋值 v-show对两组数据变化是的操作监测两组数组的变化时，可以设置computed一个数组为concat两个数组]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zepto源码阅读]]></title>
    <url>%2F2017%2F07%2F26%2Fzepto%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[翻完红宝书，第6,7章看完还是似懂非懂，也不想跟着视频写什么高大上的项目，最后想想还是找个简单的JS库看看源码吧。 zepto版本 v1.2.0 代码折叠后的基本结构//最外层为自执行函数(function(global, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) //这边是AMD的模块？ 不懂，没用过AMD define(function() &#123; return factory(global) &#125;) else factory(global) //为最外层的自执行函数传入this和factory参数&#125;(this, function(window) &#123; var Zepto = (function() &#123; //..... zepto.Z.prototype = Z.prototype = $.fn return $ &#125;)() window.Zepto = Zepto //将Zepto赋值给全局Zepto属性 window.$ === undefined &amp;&amp; (window.$ = Zepto) //若window.$未被定义，将zepto复制给$ //这边的自执行函数传入Zepto将这个变量作为局部变量，提高效率，缩短使用的作用域链 ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) ;(function($)&#123; &#125;)(Zepto) return Zepto &#125;)) 运行原理通过自运行函数，将Zepto（$）暴露给全局变量Zepto($),此时Zeptp（$）为函数，同时该变量下挂载了许多属性方法，通过 $.funName 来调用，当向Zepto（$）传入参数后，执行该函数生成对象,同时通过zepto.Z.prototype =Z.prototype = $.fn为生成的对象挂载上DOM的操作方法，部分方法返回值为this（即当前对象），可用于链式操作。 三元运算符“&amp;&amp;”和“||”源码中使用了很多三元运算符以及赋值问题 操作符|| 只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。 只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。 操作符&amp;&amp; 只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值 只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值 应用 var Yahoo = Yahoo || {}; //赋初值 callback&amp;&amp;callback() //若存在callback则运行callback 执行过程$ = function(selector, context)&#123; return zepto.init(selector, context)&#125; zepto.init = function(selector, context) &#123; var dom //如果传入值空，则返回空对象 if (!selector) return zepto.Z() //当selector为字符串时 else if (typeof selector == &apos;string&apos;) &#123; selector = selector.trim() //判断是否为&apos;&lt;&apos;开头的html标签 if (selector[0] == &apos;&lt;&apos; &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // 否则context不为空时，调用 $(context).find(selector) else if (context !== undefined) return $(context).find(selector) // 否则则为CSS选择器 else dom = zepto.qsa(document, selector) &#125; //如果传入为function else if (isFunction(selector)) return $(document).ready(selector) //如果为zepto对象 else if (zepto.isZ(selector)) return selector else &#123; //如果传入值为数组是，则除去空数组 if (isArray(selector)) dom = compact(selector) //如果为对象，则作为DOM数组的成员 else if (isObject(selector)) dom = [selector], selector = null // 这个是什么意思呢，html传进来不应该在string那边判断么 else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there&apos;s a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it&apos;s a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // 调用zepto.Z创建对象 return zepto.Z(dom, selector)&#125; zepto.Z = function(dom, selector) &#123; return new Z(dom, selector)&#125; function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || &apos;&apos;&#125; //将$.fn的对象集合赋值给zepto.Z与Z的原型zepto.Z.prototype = Z.prototype = $.fn zepto.qsa css选择器 zepto.qsa = function(element, selector)&#123; var found, maybeID = selector[0] == &apos;#&apos;, //判断是否有ID选择器 maybeClass = !maybeID &amp;&amp; selector[0] == &apos;.&apos;, //判断是否为Class选择器 nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = simpleSelectorRE.test(nameOnly) //是否为单选择器 return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? //判断document.getElementByID能否使用 ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // 为单选择器，非id选择器，存在getElementsByClassName maybeClass ? element.getElementsByClassName(nameOnly) : // 为class选择器 element.getElementsByTagName(selector) : // 否则调用getElementsByTagName element.querySelectorAll(selector) // 否则调用原生querySelectorAll )&#125; 内置方法isArray先判断是否有 Array.isArray 方法 否则调用 object instanceof ArrayisArray = Array.isArray ||function(object)&#123; return object instanceof Array &#125; 类型确定方法 $.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) &#123; class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase() &#125;) function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || &quot;object&quot;&#125;/* 生成 &#123; &apos;[object boolean]&apos;: &apos;boolean&apos;, &apos;[object number]&apos;: &apos;number&apos;, &apos;[object string]&apos;: &apos;string&apos;, ... &#125; */ 类型判断function isFunction(value) &#123; return type(value) == &quot;function&quot; &#125;function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125;function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125;function isObject(obj) &#123; return type(obj) == &quot;object&quot; &#125;function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype&#125; //判断是否为纯对象 原型与Object的原型一致function likeArray(obj) &#123;var length = !!obj &amp;&amp; &apos;length&apos; in obj &amp;&amp; obj.length, //对象不为null，存在length属性 则赋值length type = $.type(obj)return &apos;function&apos; != type &amp;&amp; !isWindow(obj) &amp;&amp; ( &apos;array&apos; == type || length === 0 || // 如果为 array 类型或者length 的值为 0，返回true (typeof length == &apos;number&apos; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) // 或者 length 为数字，并且 length的值大于零，并且 length - 1 为 obj 的 key )&#125; 其他方法 //除去数组中为空的元素 function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; //连接数组 function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; camelize = function(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : &apos;&apos; &#125;) &#125; function dasherize(str) &#123; return str.replace(/::/g, &apos;/&apos;) .replace(/([A-Z]+)([A-Z][a-z])/g, &apos;$1_$2&apos;) .replace(/([a-z\d])([A-Z])/g, &apos;$1_$2&apos;) .replace(/_/g, &apos;-&apos;) .toLowerCase() &#125; //数组去重 除去当前index与第一次出现该项相同的数组项 uniq = function(array)&#123; return filter.call(array, function(item, idx)&#123; return array.indexOf(item) == idx &#125;) &#125; function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp(&apos;(^|\\s)&apos; + name + &apos;(\\s|$)&apos;)) &#125; function maybeAddPx(name, value) &#123; return (typeof value == &quot;number&quot; &amp;&amp; !cssNumber[dasherize(name)]) ? value + &quot;px&quot; : value &#125; //在对象中缓存元素节点并默认显示 function defaultDisplay(nodeName) &#123; var element, display if (!elementDisplay[nodeName]) &#123; element = document.createElement(nodeName) document.body.appendChild(element) display = getComputedStyle(element, &apos;&apos;).getPropertyValue(&quot;display&quot;) element.parentNode.removeChild(element) display == &quot;none&quot; &amp;&amp; (display = &quot;block&quot;) elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; function children(element) &#123; return &apos;children&apos; in element ? slice.call(element.children) : $.map(element.childNodes, function(node)&#123; if (node.nodeType == 1) return node &#125;) &#125; //生成DOM zepto.fragment = function(html, name, properties) &#123; var dom, nodes, container // 如果为单个html标签 if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)) if (!dom) &#123; //这边不懂这些正则 if (html.replace) html = html.replace(tagExpanderRE, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;) if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1 if (!(name in containers)) name = &apos;*&apos; container = containers[name] container.innerHTML = &apos;&apos; + html dom = $.each(slice.call(container.childNodes), function()&#123; container.removeChild(this) &#125;) &#125; if (isPlainObject(properties)) &#123; nodes = $(dom) $.each(properties, function(key, value) &#123; if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value) else nodes.attr(key, value) &#125;) &#125; return dom&#125; //这俩看不懂 function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; $.extend = function(target)&#123; var deep, args = slice.call(arguments, 1) if (typeof target == &apos;boolean&apos;) &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; $的工具方法 $.type = type $.isFunction = isFunction $.isWindow = isWindow $.isArray = isArray $.isPlainObject = isPlainObject //判断是否为空对象 $.isEmptyObject = function(obj) &#123; var name for (name in obj) return false return true &#125;//判断是否为数字，并且在范围内 $.isNumeric = function(val) &#123; var num = Number(val), type = typeof val return val != null &amp;&amp; type != &apos;boolean&apos; &amp;&amp; (type != &apos;string&apos; || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125;//i为起始范围 $.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i) &#125;//调用内部驼峰转换功能 $.camelCase = camelize //去除空字符串 $.trim = function(str) &#123; return str == null ? &quot;&quot; : String.prototype.trim.call(str) &#125; $.map = function(elements, callback)&#123; var value, values = [], i, key //如果为数组 if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else //如果为对象 for (key in elements) &#123; value = callback(elements[key], key) //为空则跳过 if (value != null) values.push(value) &#125; return flatten(values) &#125; $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) //根据返回值停止遍历 if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; //调用内部filter方法 $.grep = function(elements, callback)&#123; return filter.call(elements, callback) &#125; //根据判断JSON对象方法的存在确定 if (window.JSON) $.parseJSON = JSON.parse // 生成对象映射数组 $.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) &#123; class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase() &#125;) $.fn的实例DOM方法forEach: emptyArray.forEach,reduce: emptyArray.reduce,push: emptyArray.push,sort: emptyArray.sort,splice: emptyArray.splice,indexOf: emptyArray.indexOf,concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; //将伪数组对象转为数组或连接多个数组项 return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;,// 调用工具方法$.mapmap: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;))&#125;,slice: function()&#123; return $(slice.apply(this, arguments))&#125;,ready: function(callback)&#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn&apos;t yet created the body element if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($) else document.addEventListener(&apos;DOMContentLoaded&apos;, function()&#123; callback($) &#125;, false) return this&#125;,//若传入参数为空，则转换为数组，若非空则返回对应idx值，若为负数则加上length值（与原生方法一致）get: function(idx)&#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;,//调用get方法toArray: function()&#123; return this.get() &#125;,//返回length属性size: function()&#123; return this.length&#125;,//先判断是否有父节点，有则删除该节点remove: function()&#123; return this.each(function()&#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;)&#125;,//判断返回值是否为falseeach: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;,filter: function(selector)&#123; if (isFunction(selector)) return this.not(this.not(selector)) return $(filter.call(this, function(element)&#123; return zepto.matches(element, selector) &#125;))&#125;,//添加元素至集合中add: function(selector,context)&#123; //去除重复元素 return $(uniq(this.concat($(selector,context))))&#125;,//判断第一个元素是否满足选择器is: function(selector)&#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector)&#125;,not: function(selector)&#123; var nodes=[] //如果传入参数为方法 if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx)&#123; //传入每个对象 if (!selector.call(this,idx)) nodes.push(this) &#125;) else &#123; var excludes = typeof selector == &apos;string&apos; ? this.filter(selector) : (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector) this.forEach(function(el)&#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes)&#125;,has: function(selector)&#123; return this.filter(function()&#123; return isObject(selector) ? //若传入参数为DOM对象 $.contains(this, selector) : //若传入参数为css选择器 $(this).find(selector).size() &#125;)&#125;,eq: function(idx)&#123; //若传入为-1 则为最后一个元素，否则为idx,idx+1 return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)&#125;,first: function()&#123; //判断是否为对象，并返回第一个元素 var el = this[0] return el &amp;&amp; !isObject(el) ? el : $(el)&#125;,last: function()&#123; //判断是否为对象，并返回最后一个元素 var el = this[this.length - 1] return el &amp;&amp; !isObject(el) ? el : $(el)&#125;,find: function(selector)&#123; var result, $this = this if (!selector) result = $() else if (typeof selector == &apos;object&apos;) result = $(selector).filter(function()&#123; //若为dom对象通过some过滤出结果 var node = this return emptyArray.some.call($this, function(parent)&#123; return $.contains(parent, node) &#125;) &#125;) //如果对象数量为1，则直接从该DOM对象中寻找 else if (this.length == 1) result = $(zepto.qsa(this[0], selector)) else result = this.map(function()&#123; return zepto.qsa(this, selector) &#125;) return result&#125;,closest: function(selector, context)&#123; var nodes = [], collection = typeof selector == &apos;object&apos; &amp;&amp; $(selector) this.each(function(_, node)&#123; while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;) return $(nodes)&#125;,parents: function(selector)&#123; var ancestors = [], nodes = this while (nodes.length &gt; 0) //返回元素的所有父元素直到document nodes = $.map(nodes, function(node)&#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node) return node &#125; &#125;) return filtered(ancestors, selector)&#125;,parent: function(selector)&#123; return filtered(uniq(this.pluck(&apos;parentNode&apos;)), selector)&#125;,children: function(selector)&#123; return filtered(this.map(function()&#123; return children(this) &#125;), selector)&#125;,contents: function() &#123; // 获得每个匹配元素集合元素的子元素，包括文字和注释节点 return this.map(function() &#123; return this.contentDocument || slice.call(this.childNodes) &#125;)&#125;,siblings: function(selector)&#123; //返回除去当前元素的同级元素，若selector存在则过滤 return filtered(this.map(function(i, el)&#123; return filter.call(children(el.parentNode), function(child)&#123; return child!==el &#125;) &#125;), selector)&#125;,empty: function()&#123; //清空元素的innerHTML return this.each(function()&#123; this.innerHTML = &apos;&apos; &#125;)&#125;,// `pluck` is borrowed from Prototype.jspluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;)&#125;,show: function()&#123; return this.each(function()&#123; //若display属性值为none，则去除该属性值 this.style.display == &quot;none&quot; &amp;&amp; (this.style.display = &apos;&apos;) //获取该元素最终的CSS属性，使用getPropertyValue方法不必可以驼峰书写形式（不支持驼峰写法 if (getComputedStyle(this, &apos;&apos;).getPropertyValue(&quot;display&quot;) == &quot;none&quot;) this.style.display = defaultDisplay(this.nodeName) &#125;)&#125;,replaceWith: function(newContent)&#123; //在该元素前插入元素并删除该元素 return this.before(newContent).remove()&#125;,wrap: function(structure)&#123; var func = isFunction(structure) if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1 return this.each(function(index)&#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;)&#125;,wrapAll: function(structure)&#123; if (this[0]) &#123; $(this[0]).before(structure = $(structure)) var children // drill down to the inmost element while ((children = structure.children()).length) structure = children.first() $(structure).append(this) &#125; return this&#125;,wrapInner: function(structure)&#123; var func = isFunction(structure) return this.each(function(index)&#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;)&#125;,unwrap: function()&#123; this.parent().each(function()&#123; $(this).replaceWith($(this).children()) &#125;) return this&#125;,clone: function()&#123; return this.map(function()&#123; return this.cloneNode(true) &#125;)&#125;,hide: function()&#123; return this.css(&quot;display&quot;, &quot;none&quot;)&#125;,toggle: function(setting)&#123; return this.each(function()&#123; var el = $(this) ;(setting === undefined ? el.css(&quot;display&quot;) == &quot;none&quot; : setting) ? el.show() : el.hide() &#125;)&#125;,prev: function(selector)&#123; return $(this.pluck(&apos;previousElementSibling&apos;)).filter(selector || &apos;*&apos;) &#125;,next: function(selector)&#123; return $(this.pluck(&apos;nextElementSibling&apos;)).filter(selector || &apos;*&apos;) &#125;,html: function(html)&#123; //若有参数修改innerhtml的值 return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : //若没参数则直接返回innerHTML值 (0 in this ? this[0].innerHTML : null)&#125;,//文本内容修改，获取text: function(text)&#123; return 0 in arguments ? this.each(function(idx)&#123; var newText = funcArg(this, text, idx, this.textContent) this.textContent = newText == null ? &apos;&apos; : &apos;&apos;+newText &#125;) : (0 in this ? this.pluck(&apos;textContent&apos;).join(&quot;&quot;) : null)&#125;,attr: function(name, value)&#123; var result //若无第二个参数 return (typeof name == &apos;string&apos; &amp;&amp; !(1 in arguments)) ? //返回第一个DOM的属性值 (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : 若有参数，则set属性的值 this.each(function(idx)&#123; if (this.nodeType !== 1) return if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;)&#125;,removeAttr: function(name)&#123; return this.each(function()&#123; this.nodeType === 1 &amp;&amp; name.split(&apos; &apos;).forEach(function(attribute)&#123; setAttribute(this, attribute) //这个this是怎么传的？ &#125;, this)&#125;)&#125;,//这个是怎么用的 不懂prop: function(name, value)&#123; name = propMap[name] || name return (1 in arguments) ? this.each(function(idx)&#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : (this[0] &amp;&amp; this[0][name])&#125;,//删除DOM节点中的一条属性removeProp: function(name)&#123; name = propMap[name] || name return this.each(function()&#123; delete this[name] &#125;)&#125;,data: function(name, value)&#123; //设置自定义属性data- ,若没有传入属性的值则仅设置属性，返回序列化的data的属性值 var attrName = &apos;data-&apos; + name.replace(capitalRE, &apos;-$1&apos;).toLowerCase() var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName) return data !== null ? deserializeValue(data) : undefined&#125;,val: function(value)&#123; // 有参数，设置值 if (0 in arguments) &#123; if (value == null) value = &quot;&quot; return this.each(function(idx)&#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; // 如果元素是 &lt;select multiple&gt; 多选列表返回数组 return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find(&apos;option&apos;).filter(function()&#123; return this.selected &#125;).pluck(&apos;value&apos;) : this[0].value) &#125;&#125;,offset: function(coordinates)&#123; //如果参数存在，则设置对应的属性 if (coordinates) return this.each(function(index)&#123; var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125; //如果属性为static则改为relaticv并赋值 if ($this.css(&apos;position&apos;) == &apos;static&apos;) props[&apos;position&apos;] = &apos;relative&apos; $this.css(props) &#125;) if (!this.length) return null if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125; var obj = this[0].getBoundingClientRect() return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125;&#125;,css: function(property, value)&#123; if (arguments.length &lt; 2) &#123; //获取第一个元素 var element = this[0] //如果属性为字符串，则修改css的值 if (typeof property == &apos;string&apos;) &#123; if (!element) return return element.style[camelize(property)] || getComputedStyle(element, &apos;&apos;).getPropertyValue(property) //如果属性为数组，则返回对应的属性值 &#125; else if (isArray(property)) &#123; if (!element) return var props = &#123;&#125; var computedStyle = getComputedStyle(element, &apos;&apos;) $.each(property, function(_, prop)&#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;) return props &#125; &#125; var css = &apos;&apos; // 其他情况：有两个参数、property是对象 if (type(property) == &apos;string&apos;) &#123; // property 是字符串，设置单个样式 if (!value &amp;&amp; value !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(property)) &#125;) else css = dasherize(property) + &quot;:&quot; + maybeAddPx(property, value) &#125; else &#123; for (key in property) //property 是对象，若属性值为空或未定义，则删除属性 if (!property[key] &amp;&amp; property[key] !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(key)) &#125;) else css += dasherize(key) + &apos;:&apos; + maybeAddPx(key, property[key]) + &apos;;&apos; &#125; //通过cssText修改CSS return this.each(function()&#123; this.style.cssText += &apos;;&apos; + css &#125;)&#125;,index: function(element)&#123; //有参数则返回该dom的index，否则返回该dom在兄弟元素中的index return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])&#125;,hasClass: function(name)&#123; //判断是否有某一css属性 if (!name) return false return emptyArray.some.call(this, function(el)&#123; return this.test(className(el)) &#125;, classRE(name))&#125;,addClass: function(name)&#123; if (!name) return this return this.each(function(idx)&#123; //判断是否存在className属性 if (!(&apos;className&apos; in this)) return classList = [] //保留原来的class var cls = className(this), newName = funcArg(this, name, idx, cls) //数组中存入不存在的class newName.split(/\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) //传入className classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;)&#125;,removeClass: function(name)&#123; return this.each(function(idx)&#123; //判断是否存在className属性 if (!(&apos;className&apos; in this)) return if (name === undefined) return className(this, &apos;&apos;) classList = className(this) funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass)&#123; //将匹配的cssName替换为空 classList = classList.replace(classRE(klass), &quot; &quot;) &#125;) //赋值cssName className(this, classList.trim()) &#125;)&#125;,toggleClass: function(name, when)&#123; if (!name) return this return this.each(function(idx)&#123; var $this = $(this), names = funcArg(this, name, idx, className(this)) names.split(/\s+/g).forEach(function(klass)&#123; // 如果有 when 参数，则只通过when参数判断，true则只执行addClass，false则只执行removeClass // 如果没有 when 参数，则判断元素有没有该class，有则移除，没有则添加 (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;)&#125;,scrollTop: function(value)&#123; if (!this.length) return var hasScrollTop = &apos;scrollTop&apos; in this[0] //如果无参数，直接返回属性值 if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset return this.each(hasScrollTop ? function()&#123; this.scrollTop = value &#125; : function()&#123; this.scrollTo(this.scrollX, value) &#125;)&#125;,scrollLeft: function(value)&#123; //同上 if (!this.length) return var hasScrollLeft = &apos;scrollLeft&apos; in this[0] if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset return this.each(hasScrollLeft ? function()&#123; this.scrollLeft = value &#125; : function()&#123; this.scrollTo(value, this.scrollY) &#125;)&#125;,position: function() &#123; if (!this.length) return var elem = this[0], // 找到第一个定位过的祖先元素 “relative”, “absolute” or “fixed” offsetParent = this.offsetParent(), // 获取当前偏移 offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset() // 去掉当前元素的 margin 宽度 // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( $(elem).css(&apos;margin-top&apos;) ) || 0 offset.left -= parseFloat( $(elem).css(&apos;margin-left&apos;) ) || 0 // 增加父元素的 border 宽度 parentOffset.top += parseFloat( $(offsetParent[0]).css(&apos;border-top-width&apos;) ) || 0 parentOffset.left += parseFloat( $(offsetParent[0]).css(&apos;border-left-width&apos;) ) || 0 // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125;&#125;,offsetParent: function() &#123; return this.map(function()&#123; var parent = this.offsetParent || document.body // 如果获取的parent不是null、不是body或html、而且position==static，继续查找，直到为根元素 while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(&quot;position&quot;) == &quot;static&quot;) parent = parent.offsetParent return parent &#125;)&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记·失乐园]]></title>
    <url>%2F2017%2F07%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%B1%E4%B9%90%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[最近天气爆炸，天天35°+前些天暂时忙完老师那边的项目，看了些乱七八糟的教程，完全冷静不下来，又打开了尘封快半年的kindle… 就在忙项目那几天，看了两本东野圭吾的小说，毕竟推理小说，拿起kindle就放不下来了，分分钟就看完了，但感觉看的时候自己确完全不带脑子，就想着看结局而去看的…现在回想起来，嗯..真的好没意思啊,不过东野圭吾最近也在也些非纯推理的小说，明明之前就是因为他的纯推理小说才入的坑，现在反而无感了。要是本本都像《嫌疑人X的献身》那样的那简直素晴らしい、但很明显这不可能啦 挑了本之前很早就想看的《失乐园》，应该还有《复乐园》、《欲乐园》但kindle商店里好像没有哎 主要内容男主久木在一次集会中经同事的介绍认识了从事书法工作的女主凛子，几乎可以说是一见钟情，很快两人就发展为了男女关系。而两人却都有各自家庭，为了能个秘密约会，两个通过各种借口经常夜不归宿，最后导致双方家庭破裂，同时男主女主终于能够在伦理道德的压力下生活在一起。但很快他们意识到此刻，是他们快乐的顶峰，面对无法预测的未来，两人最终毅然选择了死亡。 感想感觉整本书3/4都在做爱，见面就做爱，这种做爱，各种花式做爱，还玩起了SM…看到一半甚至疑惑，现实中真会有人这样么？违背社会伦理道德，仅仅用真爱的借口来满足自己。可以说是自私么？确实最后凛子留给世人的表情依旧是快乐的，久木对死前的生活明显也是满足的，于是在这快乐的巅峰，选择了死亡，甚至最后一段时间就是为了能制定一个完美的自杀计划。这大概就是爱的一种最极端表现？ 摘录 “人的一生无论看上去多么波澜壮阔，在到达终点回首往事时，却显得格外平庸。当然，哪种活法都会有遗憾，不过，至少不应该在临死的时候，才想到“糟糕”、“应该早点做”等悔不当初的话。” 对于原本性的快感比较弱的男人们，往往比较关注由于性行为所引起的各种各样的反映更甚于行为本身。因为这是深爱着的女人激情燃烧时的姿态，声音和表情。这些姿态，声音和表情就像万花筒一样不断的变化着，朝着最终目标迈进。认知并实实在在感觉到这一切，男人才能的到身心两方面的满足。 和妻子的关系现在虽说冷若冰霜，然而，一年半之前是很正常的夫妻，再往前推，是十分恩爱的一对儿，若追溯到新婚时期，则是自由恋爱结合的情侣。——你看，每个人都是这样对不对，不管从前多么相爱，到最后仍会考虑分离、全心意为另一个人的欢乐而努力。]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识]]></title>
    <url>%2F2017%2F07%2F23%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[最近又把红宝书翻了一遍，顺便整理下基础的东西前端大坑，现在还是再看看最基础的吧 JavaScript基础整理类型基本类型* number * string * boolean * null * undefined 引用类型* object * array * function(函数对象) 基本包装类型&amp;特殊引用类型（p119 不建议显式创建基本包装类型） * Boolean * Number * String str.tostring() str.substring() 过程* 创建实例 * 在该实例上调用制定方法 * 销毁这个实例 查找字符串中所有字符var str = &apos;hello world&apos;var posArr = new Array()var pos = str.indexOf(&quot;o&quot;)while(pos &gt; -1) &#123; posArr.push(pos) pos = str.indexOf(&quot;0&quot;,pos+1)&#125;console.log(posArr) //[4,7] 基本类型检查测 typeof用于检测基本类型 typeof undefined //undefinedtypeof '123' //stringtypeof 123 //numbertypeof true //booleantypeof &#123;&#125; //objecttypeof [] //objecttypeof null //objecttypeof console.log //function 引用类型检测 Object.prototype.toString.call(arr) //[object Array] arr instanceof Array //true 类型转换 字符串拼接时 let msg = 100 + 10 //110 let msg = 100 + ‘10’ //10010 if语句判断时 ==/===null == undefinednull !== undefined 内置函数 object array boolean number string function data regexp error 数组迭代方法 forEach every some sort //a-b (从小到大) b-a（从大到小） map filter 类数组对象转化为数组Array.prototype.slice.call(arguments,0) 对象APIfor(let key in obj)&#123; if (obj.hasOwnProperty(key)) &#123; //判断是否非原型中属性 console.log(key, obj[key]) &#125;&#125; object主要属性和方法 constructor //保存着创建当前对象的函数（即构造函数） hasOwnProperty(prototype) //判断属性是否在当前实例中 isPrototypeOf(object) //检查传入的对象是否当前对象的原型 垃圾收集 标记清除 引用计数 对象，原型,原型链,继承执行new的过程使用new关键字调用函数（new ClassA(…)）的具体步骤： 创建空对象； var obj = {}; 设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象； obj.proto = ClassA.prototype; 使用新对象调用函数，函数中的this被指向新实例对象： ClassA.call(obj); //{}.构造函数(); 将初始化完毕的新对象地址，保存到等号左边的变量中 创建对象的构造函数模式与原型模式 构造函数模式缺陷：每个方法都在实例上重新创建了 原型模式缺陷：属性与方法被共享，导致引用类型无法保证独立原型与构造函数组合创建对象function Ele (id) &#123; thi.ele = document.getElementById(id)&#125;Ele.prototype.html = function (val) &#123; let ele = this.ele if (val) &#123; ele.innerHTML = val return this //用于链式操作 &#125; else &#123; return ele.innerHTML &#125;&#125;Ele.prototype.on = function (type, fn) &#123; let ele = this.ele ele.addEventListener(type, fn) return this&#125;var div = new Ele(&apos;div&apos;)div.html(&apos;XXX&apos;).on(&apos;click&apos;,() =&gt; &#123;console.log(&apos;&apos;)&#125;) 常用操作instanceofinstanceof 用于判断对象和函数 (即引用类型)instanceof是检测对象的原型链是否指向构造函数的prototype对象 proto指向其构造函数的prototype (指向上一层的原型) hasOwnProtpertyobj.hasOwnProtperty(property) 检测是否为自身属性（不包含来自原型的属性） in操作符property in obj //判断property是否能在对象中访问到 constructorof实例被创建时同时创建prototype对象，对象会自动获得constructor属性（P155）subObj.constructorof == supersubObj.constructorof == Object 继承确定原型与实例关系 实例 instanceof 构造函数 构造函数.prototype.isPrototypeOf(实例) (P165)判断构造函数的原型是否在实例的原型链中 原型链继承的例子function Animal () &#123; this.eat = function () &#123; console.log (&apos;animal eat&apos;) &#125;&#125;function Dog () &#123; this.sleep = function () &#123; console.log(&apos;dog sleep&apos;) &#125;&#125;Dog.prototype = new Animal () //原型链继承let keji = new Dog() 存在的问题 1. 引用类型被共享 2. 无法传递参数（若传递参数，则其他实例也会受影响） 借用构造函数function SuperType (name) &#123; this.name = name this.color = [&apos;red&apos;,&apos;blue&apos;,&apos;black&apos;]&#125;function SubType (name) &#123; //继承Super SuperType.call(this, name)&#125;let instance = new SubType(&apos;Nic&apos;) 存在问题 1. 方法在构造函数中，无法复用 2. 超类中原型中定义的方法，子类无法使用 组合继承function SuperType (name) &#123; this.name = name this.color = [&apos;red&apos;,&apos;blue&apos;,&apos;black&apos;]&#125;SuperType.prototype.sayname = function () &#123; alert(this,name)&#125;function SubType (name, age) &#123; //继承Super属性 SuperType.call(this, name)&#125;SubType.prototype = new SuperType()SubType.prototype.constructor = SubtyppeSubType.prototype.sayage = function () &#123; alert(this.age)&#125;let instance = new SubType(&apos;Nic&apos;,&apos;20&apos;) 函数callee&amp;callerarguments.callee //指向arguments的对象函数本身,可用于递归arguments.callee.calller&amp;fun.caller //指向该函数引用（alert(fun.caller)） this根据函数执行来确定call(obj,param1,param2)apply(obj,arguments)箭头函数 this的指向问题 apply&amp;call appply(this.arguments) call(this,param1,param2) 闭包的应用function isFirstLoad () &#123; var _list = [] //私有变量 return function (id)&#123; if (_list.indexOf(id) &gt;= 0)&#123; return false &#125; else &#123; _list.push(id) return true &#125;&#125;var firstLoad = is FirstLoad()firstLoad(10) //true firstLoad(10) //falsefirstLoad(20) //true 10个li点击的应用//错误方法 var i,a for (i = 0;i &lt; 10;i++) &#123; a=document.createElement(&apos;a&apos;) a.innerHTML = i + &apos;&lt;br&gt;&apos; a.addEventListener(&apos;click&apos;, function (e) &#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125; //正确方法（不传入变量i也可以） var i for (i = 0;i &lt; 10;i++) &#123; (function (i)&#123; var a a=document.createElement(&apos;a&apos;) a.innerHTML = i + &apos;&lt;br&gt;&apos; a.addEventListener(&apos;click&apos;, function (e) &#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125;)(i) &#125; 闭包中this指向（P182）var obj = &#123; name: &apos;summerscar&apos;, sayName: function () &#123; return function () &#123; return(this) &#125; &#125;&#125;console.log(obj.sayName()()) //window 块级作用域（私有作用域）(function()&#123; //此处为块级作用域&#125;)()//相当于建立一个自执行的函数作为一段代码中语句 相当于这种写法let fn = function() &#123; //块级作用域&#125;fn(); 然而这样写会出错function()&#123;&#125;() //出错 P185 function作为关键字，会被认定为函数声明，因而不能使用（），而函数表达式可以使用（），为函数加上（fun(){}）即可 私有属性（P186）私有变量特点：利用构造函数 每个实例拥有自己的属性和方法function MyObject() &#123; //私有变量及方法 var privateVar = 10 function privateFun() &#123; return false &#125; //特权方法 this.publicMethod = function() &#123; privateVar++ return privateFun() &#125;&#125; 静态私有变量特点：利用块级作用域，定义属性，使用函数表达式创建构造函数，方法定义在原型中，每个实例间可以共享方法和属性(function()&#123; var privateVar = 10 function privateFun () &#123; return false &#125; //构造函数 MyObject = function () &#123; &#125; //特权方法 MyObject。prototype.publicMethod = funtion () &#123; privateVar ++ return privateFun () &#125;&#125;)() 以下两种还不太懂 模块模式var sigleton = function () &#123; var privateVar = 10 function privateFun () &#123; return false &#125; //返回对象 return &#123; publicProperty: true, publicMethod: funtion () &#123; privateVar ++ return privateFun () &#125; &#125;&#125; 增强的模块模式var sigleton = function () &#123; var privateVar = 10 function privateFun () &#123; return false &#125; //创建对象 var object object.publicProperty: true, object.publicMethod: funtion () &#123; privateVar ++ return privateFun () &#125; return object&#125; DOM dom数据结构为树形结构 DOM类型 document类型 nodeTyoe: 9 Element类型 nodeType: 1 元素标签判断: elem.tagName.toLowerCase() == ‘div’ get/set/removeAttribute()自定义属性值 Attribute类型 nodeType: 2 Text类型 nodeType: 3 normalize() 合并两个或两个以上的文本节点 splitText(pos)根据pos位置分割文本节点 表格操作的特使方法&gt;P282 DOM对象节点获取 getElementById… querySelector querySelectorAll matchesSelector() el.matchesSelector(“el的CSS选择”) 判断调用元素是否与选择符匹配 自定义属性datalet div = get.elementById(&quot;myDiv&quot;)//获取data-appid的值var apppid = div.dataset.appid//设置data-appid的值div.data.appid = &quot;233&quot; scrollIntoView() (P298)//让元素可见（即出现在视口中） div.scrollIntoView() Attribute&amp;propertyAttribute //标签中属性property //对象属性 DOM2与DOM3的变化访问样式 有连词符的需转换为驼峰式写法 float为JS的保留字，需写为cssFloat cssText 读取模式：访问style特性中的CSS代码 写入模式：重写整个style特性的值，以前指定的样式将丢失 BOMwindownavigatornavigator.userAgent.indexOf(‘Chrome’) screenlocation assign //下者调用该方法 href //完整链接&amp;改变网站地址 replace //跳转但不产生记录 protocol //http: host // xxx/ pathname // /xxx search // ?查询字符 hash // #链接 reload //刷新 若reload(true),则刷新缓存 history back forword go(num) 事件冒泡&amp;捕获DOM2级事件规定的事件流 1.事件捕获阶段2.处于目标阶段3.时间冒泡阶段 事件对象e.preventDefault //阻止默认事件e.stopPropatation //阻止事件冒泡 blur与focus的焦点事件不会冒泡 HTML5事件(P388) contentmenu //右击上下文菜单 beforeunload //浏览器卸载页面之前 DOMContentLoaded //DOM树形成后触发 hashchange //url后#后面字符发生变化时 Canvas合成 globalAlpha globalCompositionOperation HTML5脚本编程 video与audio的属性与方法 （P487） Ajaxvar xhr = new XMLHttpRequest()xhr.open(&quot;GET&quot;, &quot;URL&quot;, false)xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if(xhr.status == 200)&#123; console.log(xhr.responseText) &#125; &#125;&#125;xhr.send(null) readyState 0 未初始化 1 启动 已调用open() 2 发送 已调用send（） 3 接收 已接收到部分数据 4 完成 http返回码 status 2xx 成功 3xx 重定向（会自动跳转） 4xx 客户端请求错误 5xx 服务端错误 跨域条件3个条件 1.协议 2.域名 3.端口 CORS jsonp Jsonp实现原理window.callback = function (data) &#123; console.log(data)&#125;&lt;script src=&quot;api.js&quot;&gt;&lt;/script&gt; //返回 callback(&#123;x: 100&#125;) 即调用callback函数 存储浏览器性能相关浏览器渲染页面过程 根据HTML结构生成DOM tree 根据CSS生成CSSOM 将DOM和CSSM整合形成RenderTree 根据 RenderTree 开始渲染和展示 遇到 script标签时，会执行并阻塞渲染 (所以script放在body最后，不会阻塞Dom加载) load &amp; DOMContentLoaded 事件 load 页面全部资源加载完成 DOM 渲染完即执行，此时图片，视频可能未加载完成 加载资源加载优化 静态资源合并（减少、合并静态资源的加载js,css img base64） 静态资源缓存 使用CDN ssr服务器渲染，数据页面在服务器端完成 渲染优化 JS放后面 懒加载 减少DOM查询 （缓存在变量中） 减少DOM操作（尽量合并操作，使用innerHTML操作） 时间节流（事件的延迟执行，如查询时的输入下拉框） 今早执行操作 DOMContentLoaded 安全 XSS 跨站脚本攻击(Cross Site Scripting) 发送数据中包含script代码（替换关键字如/&lt;） CSRF（Cross-site request forgery跨站请求伪造）伪造正确的链接（电子邮件中隐含的虚假链接，增加验证流程）本文简单的介绍Self-XSS(自跨站脚本攻击)、CSRF(跨站请求伪造攻击)和恶意服务器这三种社会工程学的辅助攻击手段, 希望能够给予自认为身处于安全环境中的网民以自知的同时, 学会不惮以最坏的恶意来推测他人. Self-XSSXSS(跨站脚本攻击)是一种攻击者在目标网站中嵌入恶意客户端脚本以达到其不可告人目的的攻击行为. 现在大多数的网站都对XSS有所防范, 攻击者已经很难在现代网站上找到可以提交恶意脚本的XSS漏洞. 在XSS前加上Self, 就是Self-XSS(自跨站脚本攻击), 与Self这个词的意思一样, 这是一种需要受害者自己配合才能成功的XSS攻击行为, 这也是它被我归类为一种社会工程学攻击的原因. 受害者出于某种原因, 在目标网站上运行了某段由攻击者提供的恶意脚本, 就使得Self-XSS攻击成立. 一些人看到这里可能会嗤之以鼻, 认为自己不会犯下这么低级的错误, 然而事实却是, Self-XSS可以从各种各样的渠道被实现, 尤其是很多没有代码审查能力的”自称极客”所使用的那些工具, 是的, 我说的就是Bookmarklet、Greasemonkey和其他在浏览器上安装的各种Extension, 它们都有可能被用于Self-XSS攻击, 成功的攻击范例数不胜数. 在Google+打开浏览器控制台, 会发现Google直接打印出了不要在此页面运行脚本的警告, 大多数的现代浏览器的地址栏, 也会在用户粘贴以”javascript:”开头的URL时, 自动去除”javascript:”内容, 可见Self-XSS的危险性. CSRFCSRF(Cross-Site Request Forgery)是一种欺骗式的攻击手段, 攻击者会构造一个带有恶意的目标网站的URL, 并引诱受害者点击链接或以其他方式迫使浏览器发出请求来达到攻击者的目的. 是否可以实现CSRF攻击, 与目标网站是否存在可供实现CSRF攻击的漏洞有关. 我们试想这样的一种情况, 目标网站有一个用于删除用户的URL地址, 当然, 只有拥有管理员Cookie的用户才可以通过请求这个URL来删除用户, 攻击者得知这个URL之后, 构造了一个带有欺骗性的链接, 引诱了拥有管理员Cookie的用户的点击, 使得目标用户被成功删除. 在非现代浏览器或同源策略存在漏洞的IE浏览器上, 可能会产生另一种利用带有Cookie的跨站请求实现的CSRF攻击, 不过只要用户使用大部分先进的现代浏览器, 便很难遭遇这种攻击. 另外, 网站开发者如果能严格遵守RESTful的URL规范和CORS协议, 不构建能通过GET请求对数据库进行增减操作的URL, 也能起到对CSRF攻击一定的防范效果. 恶意服务器恶意服务器指那些被带有恶意的网站管理员控制的服务器, 是一个宽泛的概念, 恶意服务器有多种用法, 包括但不限于以下几种: 记录用户输入的错误密码事实上, 有很多网站都可能是恶意服务器, 作为用户, 你不知道他们是否会将你在登录时的错误密码记录下来, 对于同时使用很多种密码的人而言, 这是一个巨大的威胁, 一旦你忘记自己在该网站上的密码, 你就会开始尝试自己常用的几种密码, 而在你使用正确的密码登录服务器之前, 你的错误密码已经被网站后台记录下来, 这在之后可能将被用于其他网站数据库的撞库测试. 要想避免这种攻击, 只能让网站本身不传输明文密码, 例如在前端的登录环节里加上一道单向加密, 这样你的明文密码才不会被传到服务器上, 当然, 后端也不能因为前端进行了加密, 就放弃双端加密的基本原则, 否则将得不偿失. 暴露目标用户的真实IP地址这是一种典型的钓鱼手段, 在用户直接接入互联网的情况下, 如果打开了攻击者提供的网站, 那么用户的真实IP地址就很有可能被暴露给了攻击者, 攻击者就可以以此为基础实行其他的攻击. 不过在中国逐渐局域网化的今天, 这种攻击方式的成功率已经变得越来越低了. 行为记录用户在网站上的行为, 实际上有可能被一一记录下来, 从这些记录里, 攻击者可以轻易的推算你的作息时间等信息, 网站规模越大, 可能掌握的信息也就越多, 可推测的情报也就越丰富. 一些现代浏览器加入了”防止追踪”的功能, 也是基于同样的考量. 恶意服务器的可怕之处在于你几乎无法知道你访问的是否是一个恶意服务器, 任何一个大网站都有可能是恶意服务器, 但你又不得不去使用它们提供的服务, 你时刻都有可能处于监视之中, 却无法自知.]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的常用功能]]></title>
    <url>%2F2017%2F07%2F12%2FES6%2F</url>
    <content type="text"><![CDATA[最近简单浏览了下ES2015的东西，好多看不太懂，看懂了也不清楚怎么去用暂时把一些也许用得到的整理一下 let,const let 仅块级作用域有效 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 class, extends, super与TypeScript一致class Animal &#123; constructor()&#123; this.type = &apos;animal&apos; &#125; says(say)&#123; console.log(this.type + &apos; says &apos; + say) &#125;&#125;let animal = new Animal()animal.says(&apos;hello&apos;) //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = &apos;cat&apos; &#125;&#125;let cat = new Cat()cat.says(&apos;hello&apos;) //cat says hello 模板字符串$(&quot;#result&quot;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 数值number.issafeinterger //math.trunc //取小数 整数部分math.sign //数字正负 解构个人觉得可用于Ajax部分数据的获取let cat = &apos;ken&apos;let dog = &apos;lili&apos;let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125; 数组转换伪数组 如getElementsByClassvar divs = Array.from(document.querySelectorAll(&apos;div&apos;))divs.forEach((value, index) =&gt; &#123;&#125;)Array.from(arr) Array.from([1,2,3],function(item)&#123;return item*2&#125;) 类似map功能[1,2,undefiend].fill(7);[1,2,3].fill(7,1,3) 填充7 从1位置到3[1,2,3,4,5,6].find(function(item)&#123;return item&gt;3&#125;) //返回4[1,2,3,4,5,6].findIndex(function(item)&#123;return item&gt;3&#125;) //返回下标3[1,2,undefiend].includes(1) 函数default, restdefault参数赋默认值function animal(type = &apos;cat&apos;)&#123; console.log(type)&#125;animal() restfunction animals(...types)&#123; console.log(types)&#125;animals(&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;] 对象object.assign(&#123;&#125;,&#123;&#125;); //对象拼接 模块化export//1.变量导出export var firstName = &apos;Michael&apos;;export var lastName = &apos;Jackson&apos;;export var year = 1958;//变量对象导出var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123;firstName, lastName, year&#125;;//函数导出export function multiply(x, y) &#123; return x * y;&#125;;//导出时重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;;//export default仅导出一个export default const str = &apos;hello world&apos;import str from &apos;demo1&apos; //导入的时候没有花括号 importimport &#123;firstName, lastName, year&#125; from &apos;./profile&apos;;//导入后重命名import &#123; lastName as surname &#125; from &apos;./profile&apos;;//全部导入并命名import * as circle from &apos;./circle&apos;; symbola1=symbol() a2=symbol() a1!=a2]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门学习]]></title>
    <url>%2F2017%2F07%2F05%2Fvuex%2F</url>
    <content type="text"><![CDATA[自学习Vue也有一段时间了，感觉还没需要用到Vuex的必要，找了一些入门教程学习了下暂时先了解下主要的用法 gettersgetB：function（state）{ return state.b } computed中 return $store.getters.getB statestate:{b:0} computed return $store.state.XX mutatiomsfunA:function(state,a){ state.b+=a; } 在methods中调用 add:function(){this.$store.commit(&apos;funA&apos;,a);} actions在action中为异步操作（将ajax放入）或者为 多个mutation的封装（同时操作多个mutation） increase:function(context,a){ context.commit(&apos;funA&apos;,a) } 在methods中 add:function(){this.$store.dispatch(&apos;increase&apos;,a);}]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门学习]]></title>
    <url>%2F2017%2F06%2F26%2Fnode-js%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近想写个记事本的webApp，打算上node.js，mongodbnode还不太会用，先学下基本的路由，数据返回，调用mongo这些入门级别的试试看吧 解决NodeJS+Express模块的跨域访问控制问题：Access-Control-Allow-Originvar express = require(&apos;express&apos;);var app = express();//设置跨域访问app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next();&#125;);app.get(&apos;/auth/:id/:password&apos;, function(req, res) &#123; res.send(&#123;id:req.params.id, name: req.params.password&#125;);&#125;);app.listen(3000);console.log(&apos;Listening on port 3000...&apos;); 7.19更新最近忙完老师的项目了，然后把之前的坑补完记事本前台基本差不多完成了有空再写个后台的管理平台]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端meta设置]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFmeta%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近写移动端网站，还有默认全屏运行的设置资料整理下移动端的常用meta的设置以及webApp的设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;/&gt; 1、WebApp全屏模式：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui&quot;&gt; 注意：viewport 后面加上 minimal-ui 在safri 体现效果&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; 2、隐藏状态栏/设置状态栏颜色：&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt; 3、safri 添加到主屏界面的显示标题：&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;应用标题&quot;&gt; 4、忽略自动识别数字为电话号码：&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 5、忽略自动识别邮箱账号：&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 6、常用浏览器全屏设置：&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- 是针对一些老的不识别viewport的浏览器，列如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource中的GET与POST请求]]></title>
    <url>%2F2017%2F06%2F25%2Fvue-resource%E4%B8%AD%E7%9A%84GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[vue-resource 使用比 jQuery 更加简洁的方式实现了异步请求功能，还提供了比如 interceptors 这样处理请求过程中行为的功能。下面介绍下vue-resource中常用的GET与POST请求使用与封装方法。 Get请求function getRequest(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; Vue.http.get( url, &#123; params: params &#125;, &#123;emulateJSON: true&#125; ) .then((res) =&gt; &#123; resolve(res); &#125;) .catch((res) =&gt; &#123; reject(res); &#125;); &#125;);&#125; Post请求function postRequest(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; Vue.http.post( url, &#123; params &#125;, &#123;emulateJSON: true&#125; ) .then((res) =&gt; &#123; resolve(res.body); &#125;) .catch((res) =&gt; &#123; reject(res.body); &#125;); &#125;);&#125; 使用var params = new Object(); //创建params对象var params.id = id; //传递参数var url = url; //url地址postRequest(url, params).then((message) =&gt; &#123; //这里处理成功回调&#125;).catch((message) =&gt; &#123; //这里处理失败回调&#125;);]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB配置]]></title>
    <url>%2F2017%2F06%2F24%2FmongoDB%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[7.19更新 记事本前台部分差不多写完了，找时间撸个后台管理吧 想写个记事本的webApp顺便尝试下mongodb数据库的使用当然还是从最简单的配置入手啦 初始化 根目录建立数据库文件夹D:\Program Files\MongoDB\Server\3.0\db 建立log文件夹D:\Program Files\MongoDB\Server\3.0\log 执行cmd设置数据库文件夹mongod –dbpath “D:\Program Files\MongoDB\Server\3.0\db” 安装至服务 根目录新建mongod.cfg systemLog: destination: file path: D:\Program Files\MongoDB\Server\3.0\log\mongod.logstorage: dbPath: D:\Program Files\MongoDB\Server\3.0\db cmd执行 mongod --config &quot;D:\Program Files\MongoDB\Server\3.0\mongod.cfg&quot; --install 启动服务 在“命令指示符”窗口输入： net start MongoDB mongoskin操作http://www.hacksparrow.com/mongoskin-tutorial-with-examples.htmlhttp://www.jb51.net/article/55752.htm 数据库：同关系数据库一样。 集合： 关系数据库中的表。 文档： 类比关系数据库的记录，实则是JSON对象。 数据库设计：建议考虑NoSQL设计，抛弃关系数据的设计思想；其实NoSQL数据库设计博大精深，需要不断地在项目中实践。 用户体系：每一个数据库都有自己的管理员，可以: use dbname; db.addUser(&apos;root_1&apos; , &apos;test&apos;); 6.建议更改对外端口 7.启动服务（这是win下，linux下稍作修改）： mongod --dbpath &quot;XX\MongoDB\data\db&quot; --logpath &quot;XX\MongoDB\log\mongo.log&quot; --logappend -auth --port 7868 搭建mongodb开发基础设施npm install mongoskin 安装mongoskin 这里不介绍Node.js安装、package等机制。 创建配置文件 config.json{ &quot;dbname&quot;:&quot;TEST&quot;, &quot;port&quot;: &quot;7868&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;test&quot; } 创建util相关类mongo.js ：导出一个DB对象var mongoskin = require(&apos;mongoskin&apos;), config = require(&apos;./../config.json&apos;); /* * @des：导出数据库连接模块 * */ module.exports = (function(){ var host = config.host, port = config.port, dbName = config.dbname, userName = config.username, password = config.password, str = &apos;mongodb://&apos; + userName + &apos;:&apos; + password + &apos;@&apos; + host +&apos;:&apos; + port+ &apos;/&apos; + dbName; var option = { native_parser: true }; return mongoskin.db(str, option); })(); 构建CRUD的基础类：为了减少重复CURD代码，只需要传入相关的JSON对象即可var db = require(&apos;./mongo.js&apos;), status = require(&apos;./status&apos;), mongoskin = require(&apos;mongoskin&apos;);var CRUD = function(collection)&#123; this.collection = collection; db.bind(this.collection);&#125;;CRUD.prototype = &#123; /* * @des: 创建一条记录 * @model: 插入的记录，JSON格式的model * @callback：回调，返回插入成功的记录或者失败信息 * * */ create: function(model, callback)&#123; db[this.collection].save(model, function(err, item)&#123; if(err) &#123; return callback(status.fail); &#125; item.status = status.success.status; item.message = status.success.message; return callback(item); &#125;); &#125;, /* * @des：读取一条记录 * @query：查询条件，Mongo查询的JSON字面量 * @callback：回调，返回符合要求的记录或者失败信息 * * */ read: function(query, callback)&#123; db[this.collection].find(query).toArray(function(err, items)&#123; if(err)&#123; return callback(status.fail); &#125; var obj = &#123; status: status.success.status, message: status.success.message, items: items &#125;; return callback(obj); &#125;); &#125;, /* * @des：更新一条记录 * @query：查询条件，Mongo查询的JSON字面量，此处为_id * @updateModel：需要更新的JSON格式的模型 * @callback：返回成功或者失败信息 * * */ update: function(query, updateModel, callback)&#123; var set = &#123;set: updateModel&#125;; db[this.collection].update(query, set, function(err)&#123; if(err)&#123; return callback(status.fail); &#125;else&#123; return callback(status.success); &#125; &#125;); &#125;, /* * @des：删除一条记录 * @query：查询条件，Mongo查询的JSON字面量 * @callback：返回失败或者成功的信息 * * */ deleteData: function(query, callback)&#123; db[this.collection].remove(query, function(err)&#123; if(err)&#123; return callback(status.fail); &#125; return callback(status.success); &#125;); &#125;&#125;;module.exports = CRUD; 构建status.json，因为需要一些状态表示成功和失败，后期可以拓展为验证码错误、短信验证错误、用户名错误等module.exports = &#123; /* * 成功状态 * * */ success: &#123; status: 1, message: &apos;OK&apos; &#125;, /* * 失败状态 * * */ fail: &#123; status: 0, message: &apos;FAIL&apos; &#125;, /* * 两次输入的密码不一致 * */ repeatPassword: &#123; status: 0, message: &apos;两次输入的密码不一致&apos; &#125; &#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2017%2F06%2F23%2FPromise%2F</url>
    <content type="text"><![CDATA[据说ES6的Promise很厉害，先大概了解下基本用法 基本用法function runAsync()&#123; return new Promise(function(resolve, reject)&#123; //做一些异步操作 axios(...) .then((res) =&gt; &#123;resolve(res&#125;)) .catch((err) =&gt; &#123;reject(err)&#125;) &#125;); &#125;runAsync().then((res) =&gt; &#123;&#125;).catch((err) =&gt; &#123;&#125;) 链式操作//链式操作runAsync() .then((res) =&gt; &#123; &#125;) .then(() =&gt;&#123; return runAsync() &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); race的用法若其中有一个完成则执行thenPromise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 参考：http://www.cnblogs.com/lvdabao/p/es6-promise-1.html]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js的变量与属性]]></title>
    <url>%2F2017%2F06%2F18%2FJs%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[js的全局环境中通过var a 定义的变量能够通过window.a访问，同时不使用var 即直接定义b 可以理解为建立一个全局变量，实际上可以理解为window的b属性。下面就是变量与属性的区分。变量声明是必须通过 var 语句来完成的，未通过var 语句声明的全局变量都是都是window对象的属性。这样就很容易的理解变量和对象属性的关系了。 delete操作符是用来删除对象属性的。通过var声明的变量和通过function声明的函数拥有DontDelete特性，是不能被删除。未通过var声明的全局变量（全局对象的属性）可以删除]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript技巧整理]]></title>
    <url>%2F2017%2F06%2F08%2FJS%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[查找元素$ = function(ele) &#123; return document.querySelector(ele);&#125; JS DATE时间格式化// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)// 例子：// (new Date()).Format(&quot;yyyy-MM-dd hh:mm:ss.S&quot;) ==&gt; 2006-07-02 08:09:04.423// (new Date()).Format(&quot;yyyy-M-d h:m:s.S&quot;) ==&gt; 2006-7-2 8:9:4.18Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; &quot;M+&quot;: this.getMonth() + 1, //月份 &quot;d+&quot;: this.getDate(), //日 &quot;h+&quot;: this.getHours(), //小时 &quot;m+&quot;: this.getMinutes(), //分 &quot;s+&quot;: this.getSeconds(), //秒 &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 &quot;S&quot;: this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125; 兼容的事件方法function addEvent(ele, event, hanlder) &#123; if (ele.addEventListener) &#123; ele.addEventListener(event, hanlder, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent(&apos;on&apos; + event, hanlder); &#125; else &#123; ele[&apos;on&apos; + event] = hanlder; &#125;&#125;``` ``` //utils.jsvar EventHandler = &#123; addEventHandler: function(ele, event, hanlder) &#123; if (ele.addEventListener) &#123; ele.addEventListener(event, hanlder, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent(&quot;on&quot;+event, hanlder); &#125; else &#123; ele[&quot;on&quot; + event] = hanlder; &#125; &#125;, getCharCode: function (event)&#123; if (typeof event.charCode == &quot;number&quot;) &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, getTarget: function (event) &#123; return event.target || event.srcElement; &#125;&#125; 获取字符长度//英文字符长度为1，中文字符长度为2var GetLength = function(str)&#123; var realLength = 0; for (var i = 0; i &lt; str.length; i++) &#123; charCode = str.charCodeAt(i); if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 128) realLength += 1; else realLength += 2; &#125; return realLength;&#125;; 获取index值[].indexOf.call(lis, target) foreachvar divs = document.querySelectorAll(&apos;div&apos;);[].forEach.call(divs, function(div) &#123; // do whatever div.style.color = &quot;red&quot;;&#125;); 冒泡时判断元素target.nodeName.toLowerCase() ===&apos;li&apos; 监听点击li（监听时this会丢失）var ul =document.querySelector(&apos;ul&apos;);var lis =document.querySelectorAll(&apos;ul li&apos;);ul.addEventListener(&apos;click&apos;,function (e) &#123;var target =e.target;if(target.nodeName.toLowerCase() ===&apos;li&apos;) &#123;console.log([].indexOf.call(lis, target));&#125;&#125;,false); 链式调用return this //返回当前对象即可链式调用 继承function extend(subClass, superClass) &#123; var F = function () &#123; &#125;; F.prototype = superClass.prototype; //子类的prototype指向F的_proto_ ， _proto_又指向父类的prototype subClass.prototype = new F(); //在子类上存储一个指向父类的prototype的属性，便于子类的构造方法中与父类的名称解耦 使用subClass.superClass.constructor.call代替superClass.call subClass.superClass = superClass.prototype; &#125; 基本拖动函数window.onload = function ()&#123; // 获取元素和初始值 var oBox = document.getElementById(&apos;box&apos;), disX = 0, disY = 0; // 容器鼠标按下事件 oBox.onmousedown = function (e)&#123; var e = e || window.event; disX = e.clientX - this.offsetLeft; disY = e.clientY - this.offsetTop; document.onmousemove = function (e)&#123; var e = e || window.event; oBox.style.left = (e.clientX - disX) + &apos;px&apos;; oBox.style.top = (e.clientY - disY) + &apos;px&apos;; &#125;; document.onmouseup = function ()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;;&#125;; 定义二维数组//创建二维数组 var arrcj=new Array(); //定义一维数组 for(var i=0;i&lt;td.length/3;i++) &#123; arrcj[i]=new Array(); //将每一个子元素又定义为数组 for(n=0;n&lt;3;n++) &#123; arrcj[i][n]=1; //此时aa[i][n]可以看作是一个二级数组 &#125; &#125; 数组去重对象法（资源占用低）Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125; 临时数组法Array.prototype.method1 = function()&#123; var arr[]; //定义一个临时数组 for(var i = 0; i &lt; this.length; i++)&#123; //判断当前数组下标为i的元素是否已经保存到临时数组 //如果已保存，则跳过，否则将此元素保存到临时数组中 if(arr.indexOf(this[i]) == -1)&#123; arr.push(this[i]); &#125; &#125; return arr; &#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又到了期末评教的季节]]></title>
    <url>%2F2017%2F06%2F06%2F%E5%8F%88%E5%88%B0%E4%BA%86%E6%9C%9F%E6%9C%AB%E8%AF%84%E6%95%99%E7%9A%84%E5%AD%A3%E8%8A%82%2F</url>
    <content type="text"><![CDATA[网上ctrl+c/v过来的 简单修改了下可以在教务系统上用了 我这chrome,IE 11都没问题，其他Webkit内核浏览器应该也没问题 代码var iframe = document.getElementById(&apos;iframeautoheight&apos;);var innerDoc = iframe.contentDocument || iframe.contentWindow.document;var selects = innerDoc.getElementsByTagName(&apos;select&apos;);var scorelist = [];for (var k = 0; k &lt; selects.length; k++) &#123; if (selects[k].id.indexOf(&quot;DataGrid1__&quot;) &gt; -1) &#123; scorelist.push(selects[k]); &#125;&#125;var rid = Math.ceil(Math.random()*scorelist.length)-1;for (var i = 0; i &lt; scorelist.length; i++) &#123; var ops = scorelist[i].options; for (var j = 0; j &lt; ops.length; j++) &#123; var tempValue = ops[j].value; if (i == rid) &#123; if (tempValue == &apos;B同意&apos;) &#123; /* 随机值（防止评分相同） 可选值 &quot;A强烈同意&quot; | &quot;B同意&quot; | &quot;C一般&quot; | &quot;D不同意&quot; */ ops[j].selected = true; &#125; &#125; else &#123; if (tempValue == &apos;A强烈同意&apos;) &#123; /* 主评价 可选值 &quot;A强烈同意&quot; | &quot;B同意&quot; | &quot;C一般&quot; | &quot;D不同意&quot; */ ops[j].selected = true; &#125; &#125; &#125;&#125;var btn_save = innerDoc.getElementById(&apos;Button1&apos;);btn_save.click(); 方法1在评教页面 浏览器 F12 Console 一栏下方框框里 复制粘贴 回车即可，重复 ‘课程.length’ 次 方法2浏览器新建书签，网址填入javascript:(function()&#123; 上方代码 &#125;)(); 在评教页面点击书签即可]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实习面试整理]]></title>
    <url>%2F2017%2F05%2F29%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[最近因为找实习，查了些面试方面的东西，做下准备吧 CSS hack分类 条件注释法 &lt;!--[if IE]&gt; &lt;![endif]--&gt; 类内属性前缀法 *,+,-,_ 选择器前缀法@media screen\9{……}（只对IE6、7生效）@media \0screen{……}（只对IE8生效）@media \0screen\,screen\9{……}（对IE6,7,8生效）@media screen\0{……}（只对IE8、9、10生效）@media screen and (min-width:0\0){……}（只对IE9，10有效）@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){……} 跨域 jsonp 服务器端 继承/原型继承// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos;正在睡觉！&apos;); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos;正在吃：&apos; + food);&#125;; 原型链继承function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = &apos;cat&apos;;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat(&apos;fish&apos;));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到简单，易于实现缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中无法实现多继承来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）创建子类实例时，无法向父类构造函数传参 构造继承function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数可以实现多继承（call多个父类对象）缺点： 实例并不是父类的实例，只是子类的实例只能继承父类的实例属性和方法，不能继承原型属性/方法无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 混合继承function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例不存在引用属性共享问题可传参函数可复用缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 点击livar ul =document.querySelector(&apos;ul&apos;);var lis =document.querySelectorAll(&apos;ul li&apos;);ul.addEventListener(&apos;click&apos;,function (e) &#123;var target =e.target;if(target.nodeName.toLowerCase() ===&apos;li&apos;) &#123;console.log([].indexOf.call(lis, target));&#125;&#125;,false); 使用link和@import有什么区别* link属于XHTML标签，除了加载css外，还能定义RSS，定义rel连接属性等作用；而@import是css提供的，只能用于加载css * link会同时被加载，而@inport引用的css会等到页面被加载完再加载； 简述一下对HTML语义化的理解 用正确的标签做正确的事。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式css情况下也以一种文档格式显示，并且容易阅读；搜索引擎的爬虫也依赖于HTML标记来确定上下文各个关键字的权重，利于SEO；使阅读源代码的人更容易将网站分块，便于阅读维护理解。 JS基本数据类型？Undefined、Null、Boolean、Number、String 数组去除重复数据Array.prototype.method1 = function()&#123; var arr[]; //定义一个临时数组 for(var i = 0; i &lt; this.length; i++)&#123; //判断当前数组下标为i的元素是否已经保存到临时数组 //如果已保存，则跳过，否则将此元素保存到临时数组中 if(arr.indexOf(this[i]) == -1)&#123; arr.push(this[i]); &#125; &#125; return arr; &#125; callee与callercaller是返回一个对函数的引用，该函数调用了当前函数；callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 闭包问题function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = function()&#123; return i; //由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5 &#125; //这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i， &#125; //当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5 return arr;&#125; 方案1function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = (function(num)&#123; //自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数) return num; //这里的num写什么都可以 &#125;)(i); //这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i &#125; return arr;&#125; 方案2function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = (function(num)&#123; //num在这里 //原理和上面一种方法一样的，所以可以实现闭包 return function()&#123; //在这个闭包里面再写一个匿名函数 return num; &#125;; &#125;)(i) &#125; return arr;&#125; 方案3function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = function(num)&#123; return num; &#125;(i); &#125; return arr;&#125; JSaddEventListener最后一个参数规定事件是冒泡还是捕获。false是冒泡，true是捕获 冒泡类型blur focus change不可冒泡 判断类型 typeof返回一个表达式的数据类型的字符串，返回结果为js基本的数据类型，包括number,boolean,string,object,undefined,function.语法为typeof(data) 或 typeof data instanceof则为判断一个对象是否为某一数据类型，或一个变量是否为一个对象的实例;返回boolean类型语法为 o instanceof A alert(Object.prototype.toString.call([]) === ‘[object String]’) ——-&gt; true;类数组对象转化为数组Array.prototype.slice.call()；array方法join slice splice reverse sort foreach every等String方法concat charAt slice substr substring 等replace方法1.RegExp对象或者是字符串2.字符串或者函数 然后替换可以用正则进行全局替换apply/call区别函数声明和函数字面量的区别 CSS文本截取：text-overflow：ellipsis 算法（mark）优先队列堆快速排序 GET和POST的区别html状态码一些常见的状态代码为：200 - 服务器成功返回网页404 - 请求的网页不存在503 - 服务器暂时不可用1xx（临时响应）用于表示临时响应并需要请求者执行操作才能继续的状态代码。2xx（成功）用于表示服务器已成功处理了请求的状态代码。3xx（已重定向）要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。4xx（请求错误）这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。5xx（服务器错误）这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 事件侦听函数的区别IE使用:[Object].attachEvent(“name_of_event_handler”, fnHandler); //绑定函数[Object].detachEvent(“name_of_event_handler”, fnHandler); //移除绑定 DOM使用：[Object].addEventListener(“name_of_event”, fnHandler, bCapture); //绑定函数[Object].removeEventListener(“name_of_event”, fnHandler, bCapture); //移除绑定 HTML51、结构标签（1）section：独立内容区块，可以用h1~h6组成大纲，表示文档结构，也可以有章节、页眉、页脚或页眉的其他部分；（2）article：特殊独立区块，表示这篇页眉中的核心内容；（3）aside：标签内容之外与标签内容相关的辅助信息；（4）header：某个区块的头部信息/标题；（5）hgroup：头部信息/标题的补充内容；（6）footer：底部信息；（7）nav：导航条部分信息（8）figure：独立的单元，例如某个有图片与内容的新闻块。2、表单标签（1）email：必须输入邮件；（2）url：必须输入url地址；（3）number：必须输入数值；（4）range：必须输入一定范围内的数值；（5）Date Pickers：日期选择器；3、媒体标签（1）video：视频（2）audio：音频（3）embed：嵌入内容（包括各种媒体）4、其他功能标签（1）mark：标注（像荧光笔做笔记）（2）progress：进度条；（3）time：数据标签，给搜索引擎使用；发布日期（4）ruby和rt：对某一个字进行注释；（5）wbr：软换行，页面宽度到需要换行时换行；（6）canvas：使用JS代码做内容进行图像绘制；（7）command：按钮；（8）deteils ：展开菜单；（9）dateilst：文本域下拉提示；（10）keygen:加密； 垃圾回收引用计数，标记清除 ES6let,const,箭头函数，字符串模板，模块化，class Content-Type1.text/html2.text/plain3.text/css4.text/javascript5.application/x-www-form-urlencoded6.multipart/form-data7.application/json8.application/xmlapplication/x-www-form-urlencoded 表单发包方式，普通的表单提交，或者js发包multipart/form-data 用在发送文件的POST包。 块级格式化上下文浏览器渲染过程1.解析HTML文件，创建DOM树2.解析CSS3.将CSS与DOM合并，构建渲染树（renderingtree）4.布局和绘制，重绘（repaint）和重排（reflow） 前端性能优化请减少HTTP请求请减少对DOM的操作 使用JSON格式来进行数据交换 高效使用HTML标签和CSS样式 使用CDN加速（内容分发网络） 将CSS和JS放到外部文件中引用，CSS放头，JS放尾 精简CSS和JS文件 压缩图片和使用图片Sprite技术 CSS选择器http://www.w3school.com.cn/cssref/css_selectors.asp 浏览器缓存机制时间Etag304 创建对象 构造函数 function createPerson(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name);&#125;;&#125; var tanya =new createPerson(&quot;tanya&quot;,&quot;30&quot;,&quot;female&quot;); tanya.sayName(); 原型模式 function createPerson()&#123;&#125; createPerson.prototype.name = &quot;tanya&quot;; createPerson.prototype.age = &quot;30&quot;; createPerson.prototype.job = &quot;female&quot;; createPerson.prototype.sayName = function()&#123; alert(this.name);&#125;; var tanya =new createPerson(); tanya.sayName(); 垂直居中 table line-height padding absolute 算法十大经典算法快速排序基本数据结构和算法的前端实现基本数据结构和算法的前端实现 BFChttp://www.jianshu.com/p/66632298e355 深拷贝深拷贝]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式初始化]]></title>
    <url>%2F2017%2F05%2F21%2FCSS%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以前都是简单粗暴padding,margin=0,后来发现有一套专门的用来初始化CSS的东西，在此收集下 CSS样式初始化/移动端适配淘宝的CSS初始化body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; 移动端meta设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;/&gt; webkit中input的样式初始化input,button,select,textarea&#123;outline:none&#125;textarea&#123;resize:none&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中this指向问题]]></title>
    <url>%2F2017%2F05%2F10%2Fbind-this%2F</url>
    <content type="text"><![CDATA[在使用settimeout和settimeinterval时使用this会导致this指向全局对象而出错，查询了一些资料 this的四种机制 函数中调用 默认绑定全局变量window，因为函数在全局作用域中被调用 var name=&quot;xl&quot;;function person()&#123; console.log(this.name);&#125;person(); //输出 xl 对象中的方法 obj.fn this指向当前对象 var name=&quot;XL&quot;;var person=&#123; name:&quot;xl&quot;, showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl 构造函数中的this绑定 执行new时，构造函数中的this就被绑定到当前的新建实例中 function Person(name)&#123; this.name=name;&#125;var personA=Person(&quot;xl&quot;);console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl//上面代码没有进行new操作，相当于window对象调用Person(&quot;xl&quot;)方法，那么this指向window对象，并进行赋值操作window.name=&quot;xl&quot;.var personB=new Person(&quot;xl&quot;);console.log(personB.name);// 输出 xl 显式绑定 利用apply,call,bind的方法绑定this指向 ES6中的常用解决方法利用ES6中箭头函数（）=&gt;&#123;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js钩子函数]]></title>
    <url>%2F2017%2F05%2F05%2FVue-js%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0Mounted%2F</url>
    <content type="text"><![CDATA[生命周期 Mountedmounted并不能保证能被选中#el中的dom元素已经生成，需设置settimeout进行获取dom操作。官方解决方案https://cn.vuejs.org/v2/guide/migration.htmlmounted: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; 路由切换后会触发destroy]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Curl获取教务系统数据]]></title>
    <url>%2F2017%2F04%2F18%2Fcurl%E8%8E%B7%E5%8F%96%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[5.30更新查询课程表需添加字段 $loginParams[&#39;TextBox1&#39;] = $password;查询成绩..还没搞定..不想搞了..反正这学期也差不多了妈的 一学期教务系统改好几次，有病啊 前言 获取验证码时需保存cookie，提交验证码时要一同提交 提交验证码时还需要获取网页内的_viewstate的值（据观察这个值是每天变化一次的） post所需要提交的字段 课程表 $loginParams[‘__VIEWSTATE’] = $getview[0]; $loginParams[‘txtUserName’] = $user; $loginParams[‘TextBox2’] = $password; $loginParams[‘txtSecretCode’] = $code; $loginParams[‘RadioButtonList1’] = ‘学生’; $loginParams[‘Button1’] = ‘’; $loginParams[‘lbLanguage’] = ‘’; $loginParams[‘hidPdrs’] = ‘’; $loginParams[‘hidsc’] = ‘’; 成绩 $logParams[‘__VIEWSTATE’] = $res[0]; $logParams[‘ddlXN’] =$xuenian; $logParams[‘ddlXQ’] =$xueqi; $logParams[‘Button1’] = “按学期查询”; $logParams[‘txtQSCJ’]=”0”; $logParams[‘txtZZCJ’]=”100”; 调用函数部分变量初始化$act=&apos;&apos;;$xuenian=&quot;&quot;;$xueqi=&quot;&quot;;$user = &apos;&apos;;//用户名$password = &apos;&apos;;//密码define(&apos;SCRIPT_ROOT&apos;,dirname(__FILE__).&apos;/&apos;); curl封装函数function curl_request($url,$post=&apos;&apos;,$cookie=&apos;&apos;, $returnCookie=0)&#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_USERAGENT, &apos;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)&apos;); curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($curl, CURLOPT_AUTOREFERER, 1); curl_setopt($curl, CURLOPT_REFERER, &quot;http://XXX&quot;); if($post) &#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($post)); &#125; if($cookie) &#123; curl_setopt($curl, CURLOPT_COOKIE, $cookie); &#125; curl_setopt($curl, CURLOPT_HEADER, $returnCookie); curl_setopt($curl, CURLOPT_TIMEOUT, 10); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $data = curl_exec($curl); curl_close($curl); if($returnCookie)&#123; list($header, $body) = explode(&quot;\r\n\r\n&quot;, $data, 2); preg_match_all(&quot;/Set\-Cookie:([^;]*);/&quot;, $header, $matches); $info[&apos;cookie&apos;] = substr($matches[1][0], 1); $info[&apos;content&apos;] = $body; return $info; &#125;else&#123; return $data; &#125;&#125; 获取_viewstate函数function getView()&#123; $url = &apos;http://jwxt.jit.edu.cn/default2.aspx&apos;; $result =curl_request($url); $pattern = &apos;/&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;(.*?)&quot; \/&gt;/is&apos;; preg_match_all($pattern, $result, $matches); $res[0] = $matches[1][0]; // print_r($res); return $res;&#125; 获取验证码showAuthcode(&apos;http://jwxt.jit.edu.cn/CheckCode.aspx&apos;); 获取验证码图片function showAuthcode( $authcode_url )&#123; $cookieFile = SCRIPT_ROOT.&apos;cookie.tmp&apos;; $ch = curl_init($authcode_url); curl_setopt($ch,CURLOPT_COOKIEJAR, $cookieFile); // 把返回来的cookie信息保存在文件中 curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_REFERER, &apos;&apos;); curl_setopt($ch, CURLOPT_USERAGENT, &apos;Baiduspider&apos;); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $content =curl_exec($ch); header(&apos;Content-type: image/jpeg&apos;); print_r( $content); //var_dump($cookieFile); curl_close($ch);&#125; 读取课程表调用函数 $getview=getView(); //执行获取viewstate// print_r($getview[0]); $user=trim($_REQUEST[&apos;username&apos;]); $password=trim($_REQUEST[&apos;password&apos;]); $code = trim($_REQUEST[&apos;code&apos;]); // $loginParams为curl模拟登录时post的参数 $loginParams[&apos;__VIEWSTATE&apos;] = $getview[0]; $loginParams[&apos;txtUserName&apos;] = $user; $loginParams[&apos;TextBox2&apos;] = $password; $loginParams[&apos;txtSecretCode&apos;] = $code; $loginParams[&apos;RadioButtonList1&apos;] = &apos;学生&apos;; $loginParams[&apos;Button1&apos;] = &apos;&apos;; $loginParams[&apos;lbLanguage&apos;] = &apos;&apos;; $loginParams[&apos;hidPdrs&apos;] = &apos;&apos;; $loginParams[&apos;hidsc&apos;] = &apos;&apos;;// $cookieFile 为加载验证码时保存的cookie文件名 $cookieFile = SCRIPT_ROOT.&apos;cookie.tmp&apos;; // $targetUrl curl 提交的目标地址 $targetUrl = &apos;http://jwxt.jit.edu.cn/default2.aspx&apos;; // 参数重置 $content = curlLogin($targetUrl, $cookieFile, $loginParams); echo $content; break; 获取课程表函数function curlLogin($url, $cookieFile, $loginParams)&#123; global $user; global $password; $ch = curl_init($url); curl_setopt($ch,CURLOPT_COOKIEFILE, $cookieFile); //同时发送Cookie curl_setopt($ch,CURLOPT_RETURNTRANSFER, 1);//设定返回的数据是否自动显示 curl_setopt($ch, CURLOPT_HEADER, 0);//设定是否显示头信 息 curl_setopt($ch, CURLOPT_NOBODY, false);//设定是否输出页面 内容 curl_setopt($ch,CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch,CURLOPT_POSTFIELDS, $loginParams); //提交查询信息 curl_exec($ch);//返回结果 curl_close($ch); //关闭 $curl2=curl_init(); curl_setopt ($curl2,CURLOPT_REFERER,&apos;http://jwxt.jit.edu.cn/xs_main.aspx?xh=&apos;.$user); curl_setopt($curl2, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl2, CURLOPT_HEADER, false); curl_setopt($curl2, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl2, CURLOPT_TIMEOUT, 20); curl_setopt($curl2, CURLOPT_AUTOREFERER, true); curl_setopt($curl2, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl2, CURLOPT_URL, &apos;http://jwxt.jit.edu.cn/xskbcx.aspx?xh=&apos;.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl2),&apos;utf-8&apos;, array(&apos;Unicode&apos;,&apos;ASCII&apos;,&apos;GB2312&apos;,&apos;GBK&apos;,&apos;UTF-8&apos;)); //print_r($en_contents); preg_match_all(&apos;/&lt;span id=&quot;Label[^&gt;]*&gt;(.*)&lt;\/span&gt;/isU&apos;,$en_contents,$out); $student = explode(&apos;：&apos;, $out[1][6]); $studentInfo[0] = $student[1]; $student = explode(&apos;：&apos;, $out[1][5]); $studentInfo[1] = $student[1]; $student = explode(&apos;：&apos;, $out[1][2]); $studentInfo[2] = substr(trim($student[1]), 0,4);// var_dump($studentInfo); preg_match_all(&apos;/&lt;table id=&quot;Table1&quot;[\w\W]*?&gt;([\w\W]*?)&lt;\/table&gt;/&apos;,$en_contents,$out); $table = $out[0][0];//检查 if($table==&apos;&apos;)&#123; echo &quot;&lt;script&gt;alert(&apos;是不是输错了啦QAQ&apos;);&lt;/script&gt;&quot;; return; &#125; preg_match_all(&apos;/&lt;td [\w\W]*?&gt;([\w\W]*?)&lt;\/td&gt;/&apos;,$table,$out); $td = $out[1]; // print_r($table); $length = count($td); //获得课程列表 for ($i=0; $i &lt; $length; $i++) &#123; $td[$i] = str_replace(&quot;&lt;br&gt;&quot;, &quot;&quot;, $td[$i]); $reg = &quot;/&#123;(.*)&#125;/&quot;; if (!preg_match_all($reg, $td[$i], $matches)) &#123; unset($td[$i]); &#125; &#125; $data = array_values($td); //将课程列表数组重新索引 $tdLength = count($td); //将课表转换成数组形式 for($i=0;$i&lt;count($data);$i++) &#123; $data[$i] = str_replace(&apos;（&apos; , &apos;(&apos; , $data[$i]); $data[$i] = str_replace(&apos;）&apos; , &apos;)&apos; , $data[$i]); preg_match_all(&apos;/(?!\d+$)[0-9A-z]&#123;4&#125;/&apos;, $data[$i], $classroom); if (count($classroom[0]) == 2) &#123; // var_dump($data[$i]); $match = preg_split(&quot;/&#123;$classroom[0][0]&#125;/&quot;, $data[$i],2); $match1=preg_split(&quot;/\)/&quot;, $match[1],2); $data[$i] = str_replace($match1[1] , &apos;&apos; , $data[$i]); array_push($data,$match1[1]); &#125; &#125; // var_dump($data);//var_dump($data); $teacher=&apos;&apos;; for($i=0;$i&lt;count($data);$i++)&#123; $str =$data[$i]; preg_match_all(&apos;/(.*?)周(.*?)第/&apos;,$str,$subject); preg_match_all(&apos;/周(.*?)第/&apos;,$str,$day); preg_match_all(&apos;/第(.*?),(.*?)节/&apos;,$str,$time); preg_match_all(&apos;/\&#123;第(.*?)-(.*?)周\&#125;/&apos;,$str,$week); preg_match_all(&apos;/(?!\d+$)[0-9A-z]&#123;4&#125;/&apos;,$str,$classroom); $kcb[$i][0]=$subject[1][0]; $kcb[$i][1]=$day[1][0]; $kcb[$i][2]=$time[1][0]; $kcb[$i][3]=$time[2][0]; $kcb[$i][4]=$week[1][0]; $kcb[$i][5]=$week[2][0]; $kcb[$i][6]=$teacher; $kcb[$i][7]=$classroom[0][0]; &#125; $json_string = json_encode($kcb);// 写入文件file_put_contents(&apos;kcb.json&apos;, $json_string); // echo &quot;&lt;pre&gt;&quot;; //var_dump($kcb); curl_close($curl2); $url = &quot;showkcb.php&quot;; header(&quot;Location: $url&quot;);&#125; 读取成绩调用函数$getview=getView(); // print_r($getview[0]); $user=trim($_REQUEST[&apos;username&apos;]); $password=trim($_REQUEST[&apos;password&apos;]); $code = trim($_REQUEST[&apos;code&apos;]); $xuenian=trim($_REQUEST[&apos;xuenian&apos;]); $xueqi=trim($_REQUEST[&apos;xueqi&apos;]); // $loginParams为curl模拟登录时post的参数 $loginParams[&apos;__VIEWSTATE&apos;] = $getview[0]; $loginParams[&apos;txtUserName&apos;] = $user; $loginParams[&apos;TextBox2&apos;] = $password; $loginParams[&apos;txtSecretCode&apos;] = $code; $loginParams[&apos;RadioButtonList1&apos;] = &apos;学生&apos;; $loginParams[&apos;Button1&apos;] = &apos;&apos;; $loginParams[&apos;lbLanguage&apos;] = &apos;&apos;; $loginParams[&apos;hidPdrs&apos;] = &apos;&apos;; $loginParams[&apos;hidsc&apos;] = &apos;&apos;; // $cookieFile 为加载验证码时保存的cookie文件名 $cookieFile = SCRIPT_ROOT.&apos;cookie.tmp&apos;; // $targetUrl curl 提交的目标地址 $targetUrl = &apos;http://jwxt.jit.edu.cn/default2.aspx&apos;; // 参数重置 $content = curlLogin1($targetUrl, $cookieFile, $loginParams); echo &apos;学年&apos;.$xuenian.&quot;学期&quot;.$xueqi; break; 查询成绩函数function curlLogin1($url, $cookieFile, $loginParams)&#123; global $xuenian; global $xueqi; global $user; global $password; // $user = $user;//用户名 $ch = curl_init($url); curl_setopt($ch,CURLOPT_COOKIEFILE, $cookieFile); //同时发送Cookie curl_setopt($ch,CURLOPT_RETURNTRANSFER, 1);//设定返回的数据是否自动显示 curl_setopt($ch, CURLOPT_HEADER, 0);//设定是否显示头信 息 curl_setopt($ch, CURLOPT_NOBODY, false);//设定是否输出页面 内容 curl_setopt($ch,CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch,CURLOPT_POSTFIELDS, $loginParams); //提交查询信息 curl_exec($ch);//返回结果 curl_close($ch); //关闭 $curl2=curl_init(); curl_setopt ($curl2,CURLOPT_REFERER,&apos;http://jwxt.jit.edu.cn/xs_main.aspx?xh=&apos;.$user); curl_setopt($curl2, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl2, CURLOPT_HEADER, false); curl_setopt($curl2, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl2, CURLOPT_TIMEOUT, 20); curl_setopt($curl2, CURLOPT_AUTOREFERER, true); curl_setopt($curl2, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl2, CURLOPT_URL, &apos;http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh=&apos;.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl2),&apos;utf-8&apos;, array(&apos;Unicode&apos;,&apos;ASCII&apos;,&apos;GB2312&apos;,&apos;GBK&apos;,&apos;UTF-8&apos;)); curl_close($curl2); //print_r($en_contents); $pattern = &apos;/&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;(.*?)&quot; \/&gt;/is&apos;; preg_match_all($pattern, $en_contents, $matches); $res[0] = $matches[1][0]; // print_r($res); $logParams[&apos;__EVENTTARGET&apos;] = &quot;&quot;; $logParams[&apos;__EVENTARGUMENT&apos;] = &quot;&quot;; $logParams[&apos;__VIEWSTATE&apos;] = $res[0]; $logParams[&apos;ddlxn&apos;] =$xuenian; $logParams[&apos;ddlxq&apos;] =$xueqi; $logParams[&apos;btnCx&apos;] = &quot; 查 询 &quot;; $curl3=curl_init(); curl_setopt ($curl3,CURLOPT_REFERER,&apos;http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh=&apos;.$user); curl_setopt($curl3, CURLOPT_COOKIEFILE, $cookieFile); curl_setopt($curl3, CURLOPT_HEADER, false); curl_setopt($curl3, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl3, CURLOPT_TIMEOUT, 20); curl_setopt($curl3, CURLOPT_AUTOREFERER, true); curl_setopt($curl3, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl3,CURLOPT_POSTFIELDS, $logParams); //提交查询信息 curl_setopt($curl3, CURLOPT_URL, &apos;http://jwxt.jit.edu.cn/xscjcx_dq.aspx?xh=&apos;.$user);//登陆后要从哪个页面获取信息 $en_contents=mb_convert_encoding( curl_exec($curl3),&apos;utf-8&apos;, array(&apos;Unicode&apos;,&apos;ASCII&apos;,&apos;GB2312&apos;,&apos;GBK&apos;,&apos;UTF-8&apos;)); curl_close($curl3); preg_match_all(&apos;/&lt;table class=&quot;datelist&quot;[\w\W]*?&gt;([\w\W]*?)&lt;\/table&gt;/&apos;,$en_contents,$xscj); $xscj1=$xscj[0][0];//检查 if($xscj1==&apos;&apos;)&#123; echo &quot;&lt;script&gt;alert(&apos;是不是输错了啦QAQ&apos;);&lt;/script&gt;&quot;; return; &#125; preg_match_all(&apos;/&lt;tr[\w\W]*?&gt;([\w\W]*?)&lt;\/tr&gt;/&apos;,$xscj1,$xscj2); $json_string = json_encode($xscj2[0]);// 写入文件file_put_contents(&apos;cj.json&apos;, $json_string); //print_r($xscj1); $url = &quot;showcj.php&quot;; header( &quot;Location: $url&quot; );&#125; HTML表单部分&lt;form role=&quot;form&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;&quot; id=&quot;hidden&quot;&gt; &lt;span&gt;输入学号：&lt;/span&gt;&lt;input class =&quot;form-control&quot; type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br&gt; &lt;span&gt;输入密码：&lt;/span&gt;&lt;input class =&quot;form-control&quot; type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br&gt; &lt;iframe class=&quot;pull-right&quot; src=&quot;?act=authcode&quot; style=&apos;width: 100px; height:30px; overflow: hidden; display:block;&apos; frameborder=0 &gt;&lt;/iframe&gt;&lt;br&gt; &lt;span&gt;输入验证码：&lt;/span&gt;&lt;input class =&quot;form-control&quot; type=&quot;text&quot; name=&quot;code&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;div style=&quot;margin:0 auto;width:100px&quot;&gt; &lt;input class =&quot;form-control btn btn-primary&quot; id=&quot;sub1&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;查询课表&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;input class =&quot;form-control btn btn-primary&quot; type=button onclick=&quot;javascript:window.location.href=&apos;show1.php&apos;;&quot; value=&quot;首页/刷新&quot;&gt; &lt;/div&gt; &lt;/form&gt;&lt;script src=&quot;css/domain.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var hidden=document.getElementById(&quot;hidden&quot;); var sub1=document.getElementById(&quot;sub1&quot;); var sub2=document.getElementById(&quot;sub2&quot;); sub1.onclick=function () &#123; hidden.value=&quot;login&quot;;&#125;; sub2.onclick=function () &#123; hidden.value=&quot;cxcj&quot;;&#125;; // hidden.value=&quot;cxcj&quot;; // alert(hidden.value);&lt;/script&gt; 效果]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame基本用法]]></title>
    <url>%2F2017%2F04%2F15%2FrequestAnimationFrame%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[兼容性处理requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;; 基本使用function animate() &#123; // Do whatever requestAnimationFrame(animate); // Do something animate &#125; //go-&gt; requestAnimationFrame(animate); requestAnimationFrame(function () &#123; // Do whatever requestAnimationFrame(animate); // Do something animate &#125;) 设定结束var globalID; function animate() &#123; // Do whatever globalID=requestAnimationFrame(animate); // Do something animate &#125; //when ot start globalID=requestAnimationFrame(animate); //when to stop cancelAnimationFrame(globalID);]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas在移动端的缩放模糊问题]]></title>
    <url>%2F2017%2F04%2F10%2FCanvas%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%BC%A9%E6%94%BE%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于移动端的缩放问题Canvas的css宽与高会被缩放而Canvas画板本身不变，导致图形出现模糊获得缩放倍率var canvas = document.getElementById(&quot;canvas&quot;), context= canvas.getContext(&quot;2d&quot;); // 屏幕的设备像素比 var devicePixelRatio = window.devicePixelRatio || 1; // 浏览器在渲染canvas之前存储画布信息的像素比 var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;// canvas的实际渲染倍率 var ratio = devicePixelRatio / backingStoreRatio; 设定height与width的值canvas.width = canvas.width * ratio;canvas.height = canvas.height * ratio; https://sanwen8.cn/p/42bobOb.html]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端自适应CSS媒体查询]]></title>
    <url>%2F2017%2F04%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CSS自适应媒体查询@media only screen and (max-width: 1080px), only screen and (max-device-width:1080px) &#123; html,body &#123; font-size:16.875px; &#125; &#125; @media only screen and (max-width: 960px), only screen and (max-device-width:960px) &#123; html,body &#123; font-size:15px; &#125; &#125; @media only screen and (max-width: 800px), only screen and (max-device-width:800px) &#123; html,body &#123; font-size:12.5px; &#125; &#125; @media only screen and (max-width: 720px), only screen and (max-device-width:720px) &#123; html,body &#123; font-size:11.25px; &#125; &#125; @media only screen and (max-width: 640px), only screen and (max-device-width:640px) &#123; html,body &#123; font-size:10px; &#125; &#125; @media only screen and (max-width: 600px), only screen and (max-device-width:600px) &#123; html,body &#123; font-size:9.375px; &#125; &#125; @media only screen and (max-width: 540px), only screen and (max-device-width:540px) &#123; html,body &#123; font-size:8.4375px; &#125; &#125; @media only screen and (max-width: 480px), only screen and (max-device-width:480px) &#123; html,body &#123; font-size:7.5px; &#125; &#125; @media only screen and (max-width: 414px), only screen and (max-device-width:414px) &#123; html,body &#123; font-size:6.46875px; &#125; &#125; @media only screen and (max-width: 400px), only screen and (max-device-width:400px) &#123; html,body &#123; font-size:6.25px; &#125; &#125; @media only screen and (max-width: 375px), only screen and (max-device-width:375px) &#123; html,body &#123; font-size:5.859375px; &#125; &#125; @media only screen and (max-width: 360px), only screen and (max-device-width:360px) &#123; html,body &#123; font-size:5.625px; &#125; &#125; @media only screen and (max-width: 320px), only screen and (max-device-width:320px) &#123; html,body &#123; font-size:5px; &#125; &#125; @media only screen and (max-width: 240px), only screen and (max-device-width:240px) &#123; html,body &#123; font-size:3.75px; &#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS拖动函数]]></title>
    <url>%2F2017%2F03%2F20%2FJS%E6%8B%96%E5%8A%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JS的基本拖动函数//HTML 结构：&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;//csc 样式：#box&#123;position: absolute;width: 200px;height: 200px;background: red;&#125;//jswindow.onload = function ()&#123; // 获取元素和初始值 var oBox = document.getElementById(&apos;box&apos;), disX = 0, disY = 0; // 容器鼠标按下事件 oBox.onmousedown = function (e)&#123; var e = e || window.event; disX = e.clientX - this.offsetLeft; disY = e.clientY - this.offsetTop; document.onmousemove = function (e)&#123; var e = e || window.event; oBox.style.left = (e.clientX - disX) + &apos;px&apos;; oBox.style.top = (e.clientY - disY) + &apos;px&apos;; &#125;; document.onmouseup = function ()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;;&#125;;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo deploy出错的问题]]></title>
    <url>%2F2017%2F03%2F11%2Fhexo-deploy%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布时出现 Deployer not found: git在终端执行命令：npm install hexo-deployer-git --save然后继续执行hexo deploye指令进行部署。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F10%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[这是搭建Hexo博客的第一天]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
</search>
